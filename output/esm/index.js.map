{"version":3,"sources":["../../src/modules/dsl.ts","../../src/modules/prisma-schema-loader.ts","../../src/modules/utils/prisma-validation.ts","../../src/modules/utils/load-prisma-schema.ts","../../src/modules/field-relation-collector.ts","../../src/modules/field-relation-logger.ts","../../src/modules/prisma-ql-provider.ts","../../src/modules/handler-registries/handler-registry.ts","../../src/modules/utils/model-primary-fields.ts","../../src/modules/utils/schema-helper.ts","../../src/modules/handler-registries/query-handler-registry.ts","../../src/modules/handler-registries/mutation-handler-registry.ts","../../src/modules/prehandlers/render-handlers/index.ts","../../src/modules/prehandlers/render-handlers/get-enum-relations.ts","../../src/modules/prehandlers/render-handlers/get-model-names.ts","../../src/modules/prehandlers/render-handlers/get-enums.ts","../../src/modules/prehandlers/render-handlers/get-fields.ts","../../src/modules/prehandlers/render-handlers/get-model.ts","../../src/modules/prehandlers/render-handlers/get-models.ts","../../src/modules/prehandlers/render-handlers/get-relations.ts","../../src/modules/prehandlers/json-handlers/index.ts","../../src/modules/prehandlers/json-handlers/get-enum-relations.ts","../../src/modules/prehandlers/json-handlers/get-enums.ts","../../src/modules/prehandlers/json-handlers/get-fields.ts","../../src/modules/prehandlers/json-handlers/get-model-names.ts","../../src/modules/prehandlers/json-handlers/get-model.ts","../../src/modules/prehandlers/json-handlers/get-models.ts","../../src/modules/prehandlers/json-handlers/get-relations.ts","../../src/modules/prehandlers/mutation-handlers/index.ts","../../src/modules/prehandlers/mutation-handlers/add-enum.ts","../../src/modules/prehandlers/mutation-handlers/add-field.ts","../../src/modules/prehandlers/mutation-handlers/add-model.ts","../../src/modules/prehandlers/mutation-handlers/add-relation.ts","../../src/modules/prehandlers/mutation-handlers/delete-enum.ts","../../src/modules/prehandlers/mutation-handlers/delete-field.ts","../../src/modules/prehandlers/mutation-handlers/delete-model.ts","../../src/modules/prehandlers/mutation-handlers/delete-relations.ts","../../src/modules/prehandlers/mutation-handlers/update-enum.ts","../../src/modules/prehandlers/mutation-handlers/update-field.ts","../../src/modules/prehandlers/mutation-handlers/add-generator.ts","../../src/modules/prehandlers/mutation-handlers/update-generator.ts","../../src/modules/prehandlers/mutation-handlers/update-db.ts","../../src/modules/handlers/mutation-handler.ts","../../src/modules/prehandlers/render-handlers/get-generators.ts","../../src/modules/prehandlers/render-handlers/get-db.ts","../../src/modules/handlers/query-render-handler.ts","../../src/modules/prehandlers/json-handlers/get-generators.ts","../../src/modules/handlers/query-json-handler.ts"],"sourcesContent":["import { PrismaQlRelationType } from \"./field-relation-collector.js\";\r\n\r\nexport type BasePrismaQlDSLAction = \"GET\" | \"ADD\" | \"DELETE\" | \"UPDATE\" | \"PRINT\" | \"VALIDATE\";\r\n\r\nexport type BasePrismaQLDSLCommand =\r\n    | \"MODELS\"\r\n    | \"MODEL\"\r\n    | \"FIELD\"\r\n    | \"FIELDS\"\r\n    | \"RELATIONS\"\r\n    | \"DB\"\r\n    | \"ENUM_RELATIONS\"\r\n    | \"ENUMS\"\r\n    | \"ENUM\"\r\n    | \"MODELS_LIST\"\r\n    | \"RELATION\"\r\n    | \"GENERATOR\"\r\n    | \"GENERATORS\";\r\n\r\nexport type PrismaQlDSLAction<A extends string = BasePrismaQlDSLAction> = A;\r\nexport type PrismaQLDSLCommand<C extends string = BasePrismaQLDSLCommand> = C;\r\n\r\nexport type PrismaQlDSLType = \"query\" | \"mutation\";\r\n\r\nexport type PrismaQlDSLMutationAction = \"ADD\" | \"DELETE\" | \"UPDATE\";\r\nexport type PrismaQlDSLQueryAction = \"GET\" | \"PRINT\" | \"VALIDATE\";\r\n\r\nexport type PrismaQLDSLArgs<A extends PrismaQlDSLAction, C extends PrismaQLDSLCommand | undefined> = {\r\n    models?: string[];\r\n    fields?: string[];\r\n    enums?: string[];\r\n    generators?: string[];\r\n};\r\n\r\nexport type DSLPrismaRelationType = PrismaQlRelationType;\r\n\r\nexport type PrismaQlDSLOptionMap = {\r\n    GET: {\r\n        ENUMS: { raw?: boolean };\r\n        RELATIONS: { depth?: number };\r\n    },\r\n    ADD: {\r\n        RELATION: {\r\n            type: DSLPrismaRelationType,\r\n            pivotTable?: string | true,\r\n            pivotOnly?: boolean,\r\n            fkHolder?: string,\r\n            required?: boolean,\r\n            relationName?: string,\r\n        };\r\n        MODEL: {\r\n            empty?: boolean;\r\n        }\r\n    },\r\n    UPDATE: {\r\n        ENUM: {\r\n            replace: boolean;\r\n        },\r\n        GENERATOR: {\r\n            output?: string;\r\n            provider?: string;\r\n        },\r\n        DB: {\r\n            provider?: string;\r\n            url?: string;\r\n        }\r\n    },\r\n    DELETE: {\r\n        RELATION: {\r\n            fieldA?: string;\r\n            fieldB?: string;\r\n            relationName?: string;\r\n        }\r\n    }\r\n};\r\n\r\nexport type PrismaQlDSLOptions<A extends PrismaQlDSLAction, C extends PrismaQLDSLCommand | undefined> =\r\n    A extends keyof PrismaQlDSLOptionMap\r\n    ? C extends keyof PrismaQlDSLOptionMap[A]\r\n    ? PrismaQlDSLOptionMap[A][C]\r\n    : Record<string, string | number | boolean | Array<string>>\r\n    : Record<string, string | number | boolean | Array<string>>;\r\n\r\n\r\nexport interface PrismaQLParsedDSL<\r\n    A extends PrismaQlDSLAction = PrismaQlDSLAction,\r\n    C extends PrismaQLDSLCommand = PrismaQLDSLCommand,\r\n    T extends PrismaQlDSLType = PrismaQlDSLType\r\n> {\r\n    action: A;\r\n    command?: C;\r\n    args?: PrismaQLDSLArgs<A, C>;\r\n    options?: PrismaQlDSLOptions<A, C>;\r\n    prismaBlock?: string;\r\n    raw: string;\r\n    type: T;\r\n}\r\n\r\nexport type PrismaQlDSLArgsProcessor<\r\n    A extends PrismaQlDSLAction = PrismaQlDSLAction,\r\n    C extends PrismaQLDSLCommand = PrismaQLDSLCommand\r\n> = (\r\n    parsedArgs: PrismaQLDSLArgs<A, C>,\r\n    rawArgs: string | undefined\r\n) => PrismaQLDSLArgs<A, C>;\r\n\r\nconst DSL_PATTERN = /^([A-Z]+)(?:\\s+([A-Z_]+))?(?:\\s+([\\w\\s,*]+))?(?:\\s*\\(\\{([\\s\\S]*?)\\}\\))?(?:\\s*\\(([^)]*?)\\))?$/i;\r\n\r\nconst ACTION_COMMAND_MAP: Record<PrismaQlDSLAction, PrismaQLDSLCommand[]> = {\r\n    GET: [\"MODELS\", \"DB\", \"GENERATORS\", \"MODEL\", \"ENUM_RELATIONS\", \"FIELDS\", \"RELATIONS\", \"ENUMS\", \"MODELS_LIST\"],\r\n    ADD: [\"MODEL\", \"GENERATOR\", \"FIELD\", \"RELATION\", \"ENUM\"],\r\n    DELETE: [\"MODEL\", \"FIELD\", \"RELATION\", \"ENUM\", \"GENERATOR\"],\r\n    UPDATE: [\"FIELD\", \"ENUM\", \"GENERATOR\", \"DB\"],\r\n    PRINT: [],\r\n    VALIDATE: [],\r\n};\r\n\r\nexport class PrismaQlDslParser<\r\n    A extends string = PrismaQlDSLAction,\r\n    C extends string = PrismaQLDSLCommand\r\n> {\r\n    private customCommands: Record<A, C[]> = {} as Record<A, C[]>;\r\n    private actionTypeMap: Record<PrismaQlDSLAction, PrismaQlDSLType> = {\r\n        GET: \"query\",\r\n        ADD: \"mutation\",\r\n        DELETE: \"mutation\",\r\n        UPDATE: \"mutation\",\r\n        PRINT: \"query\",\r\n        VALIDATE: \"query\",\r\n    };\r\n    constructor(\r\n        public argsProcessors: Record<\r\n            PrismaQlDSLAction,\r\n            { default: PrismaQlDSLArgsProcessor<any, any> } & Partial<Record<PrismaQLDSLCommand, PrismaQlDSLArgsProcessor<any, any>>>\r\n        >\r\n    ) {\r\n    }\r\n    public registerCommand(action: A, command: C, type: PrismaQlDSLType) {\r\n        if (!this.customCommands[action]) {\r\n            this.customCommands[action] = [];\r\n        }\r\n        this.customCommands[action].push(command);\r\n        (this.actionTypeMap as Record<string, PrismaQlDSLType>)[action] = type;\r\n    }\r\n    public getCommands(): Record<A, C[]> {\r\n        return {\r\n            ...ACTION_COMMAND_MAP,\r\n            ...this.customCommands,\r\n        } as Record<A, C[]>;\r\n    }\r\n\r\n    parseCommand<A extends PrismaQlDSLAction, C extends PrismaQLDSLCommand, T extends 'query' | 'mutation'>(input: string): PrismaQLParsedDSL<A, C, T> {\r\n        const trimmed = input.trim();\r\n        if (!trimmed.endsWith(\";\")) {\r\n            throw new Error(\"DSL command must end with a semicolon.\");\r\n        }\r\n        const raw = trimmed.slice(0, -1).trim();\r\n\r\n        const match = raw.match(DSL_PATTERN);\r\n        if (!match) {\r\n            throw new Error(`Unable to parse DSL line: \"${raw}\"`);\r\n        }\r\n\r\n        const actionStr = match[1].toUpperCase() as PrismaQlDSLAction;\r\n        const commandStr = match[2]?.toUpperCase() as C;\r\n        const argsStr = match[3]?.trim() || undefined;\r\n        let prismaBlockStr = match[4]?.trim() || undefined;\r\n        if (prismaBlockStr) {\r\n            prismaBlockStr = prismaBlockStr.replace(/'/g, '\"');\r\n            prismaBlockStr = prismaBlockStr.replace(/\\\\n/g, \"\\n\");\r\n            prismaBlockStr = prismaBlockStr.replace(/\\|/g, \"\\n\");\r\n        }\r\n        let optionsStr = match[5]?.trim() || undefined;\r\n        if (optionsStr) {\r\n            optionsStr = optionsStr.replace(/'/g, '\"');\r\n            optionsStr = optionsStr.replace(/\\\\n/g, \"\\n\");\r\n            optionsStr = optionsStr.replace(/\\|/g, \"\\n\");\r\n        }\r\n\r\n        if (!(actionStr in ACTION_COMMAND_MAP) && !(actionStr in this.customCommands)) {\r\n            throw new Error(`Unsupported action \"${actionStr}\". Supported actions: ${Object.keys(ACTION_COMMAND_MAP).join(\", \")}`);\r\n        }\r\n\r\n        let finalCommand: C | undefined;\r\n        const actionKey = actionStr as A;\r\n        const commands = this.getCommands() as unknown as Record<A, C[]>;\r\n        const availableCommands = commands[actionKey] || [];\r\n\r\n        if (commandStr) {\r\n            if (!availableCommands.includes(commandStr)) {\r\n                throw new Error(`Invalid command \"${commandStr}\" for action \"${actionStr}\". Supported: ${availableCommands.join(\", \")}`);\r\n            }\r\n            finalCommand = commandStr;\r\n        }\r\n\r\n        const parsedOptions = optionsStr ? this.parseParams(optionsStr) : undefined;\r\n        const baseArgs = this.parseArgs<A, C>(argsStr);\r\n        const argsProcessor = this.argsProcessors[actionStr][finalCommand || \"default\"];\r\n        const finalArgs = argsProcessor ? argsProcessor(baseArgs, argsStr) : baseArgs;\r\n\r\n        return {\r\n            action: actionStr as A,\r\n            command: finalCommand as C,\r\n            args: finalArgs,\r\n            options: parsedOptions,\r\n            prismaBlock: prismaBlockStr,\r\n            raw: input,\r\n            type: this.actionTypeMap[actionStr] as T,\r\n        };\r\n    }\r\n    parseParams(input: string): PrismaQlDSLOptions<any, any> {\r\n        const result: PrismaQlDSLOptions<any, any> = {};\r\n        const tokens = input.split(\",\").map(t => t.trim()).filter(Boolean);\r\n        for (const token of tokens) {\r\n            const eqIndex = token.indexOf(\"=\");\r\n            if (eqIndex > 0) {\r\n                const key = token.slice(0, eqIndex).trim();\r\n                let valueStr = token.slice(eqIndex + 1).trim();\r\n                if (/^\\d+$/.test(valueStr)) {\r\n                    result[key] = parseInt(valueStr, 10);\r\n                } if (valueStr === \"true\") {\r\n                    result[key] = true;\r\n                }\r\n                else if (valueStr === \"false\") {\r\n                    result[key] = false;\r\n                }\r\n                else {\r\n                    result[key] = valueStr;\r\n                }\r\n                if (valueStr.includes(\",\")) {\r\n                    result[key] = valueStr.split(\",\").map(v => v.trim());\r\n                } else {\r\n                    try {\r\n                        result[key] = JSON.parse(valueStr);\r\n                    } catch (e) {\r\n                        result[key] = valueStr;\r\n                    }\r\n                }\r\n            } else {\r\n                const flag = token.trim();\r\n                result[flag] = true;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    parseArgs<A extends PrismaQlDSLAction, C extends PrismaQLDSLCommand | undefined>(argsStr: string | undefined): PrismaQLDSLArgs<A, C> {\r\n        const args: PrismaQLDSLArgs<A, C> = {};\r\n        if (!argsStr) return args;\r\n\r\n        const tokens = argsStr.split(\",\").map(t => t.trim()).filter(Boolean);\r\n        for (const token of tokens) {\r\n            args.models = args.models || [];\r\n            args.models.push(token);\r\n        }\r\n        return args;\r\n    }\r\n    detectActionType(source: string): PrismaQlDSLType | null {\r\n        const DSL_ACTION_PATTERN = /^([A-Z]+)/i;\r\n        const match = source.match(DSL_ACTION_PATTERN);\r\n        if (!match) return null;\r\n        const actionStr = match[1].toUpperCase() as PrismaQlDSLAction;\r\n        return this.actionTypeMap[actionStr] || null;\r\n    }\r\n    isValid(source: string): boolean | Error {\r\n        try {\r\n            this.parseCommand(source);\r\n            return true;\r\n        } catch (e) {\r\n            return e;\r\n        }\r\n    }\r\n}\r\n\r\nexport const basePrismaQlAgsProcessor: Record<\r\n    PrismaQlDSLAction,\r\n    { default: PrismaQlDSLArgsProcessor<any, any> } & Partial<Record<PrismaQLDSLCommand, PrismaQlDSLArgsProcessor<any, any>>>\r\n> = {\r\n    GET: {\r\n        default: (parsedArgs) => parsedArgs,\r\n        MODEL: (parsedArgs, rawArgs) => {\r\n            if (rawArgs?.includes(\"IN\")) {\r\n                return { models: [rawArgs.split(\"IN\")[1].trim()] };\r\n            }\r\n            return parsedArgs;\r\n        },\r\n        MODELS: (_, rawArgs) => {\r\n            return { models: rawArgs ? rawArgs.split(\",\").map(m => m.trim()) : [] };\r\n        },\r\n        RELATIONS: (_, rawArgs) => {\r\n            return { models: rawArgs ? rawArgs.split(\",\").map(r => r.trim()) : [] };\r\n        },\r\n        FIELDS: (parsedArgs, rawArgs) => {\r\n            const [fieldsStr, modelName] = rawArgs?.split(\"IN\") || [];\r\n            if (!fieldsStr || !modelName) return parsedArgs;\r\n            return { models: [modelName.trim()], fields: fieldsStr.split(\",\").map(f => f.trim()) };\r\n        },\r\n        ENUMS: (_, rawArgs) => {\r\n            return { enums: rawArgs ? rawArgs.split(\",\").map(e => e.trim()) : [] };\r\n        },\r\n        ENUM_RELATIONS: (_, rawArgs) => {\r\n            return { enums: rawArgs ? rawArgs.split(\",\").map(e => e.trim()) : [] };\r\n        }\r\n    },\r\n    ADD: {\r\n        default: (parsedArgs) => parsedArgs,\r\n        MODEL: (_, rawArgs) => {\r\n            return { models: rawArgs ? rawArgs.split(\",\").map(m => m.trim()) : [] };\r\n        },\r\n        GENERATOR: (parsedArgs, rawArgs) => {\r\n            return { generators: rawArgs ? rawArgs.split(\",\").map(g => g.trim()) : [] };\r\n        },\r\n        ENUM: (_, rawArgs) => {\r\n            return { enums: rawArgs ? rawArgs.split(\",\").map(e => e.trim()) : [] };\r\n        },\r\n        FIELD: (parsedArgs, rawArgs) => {\r\n            const [fieldName, modelName] = rawArgs?.split(\"TO\") || [];\r\n            if (!fieldName || !modelName) return parsedArgs;\r\n            return { models: [modelName.trim()], fields: [fieldName.trim()] };\r\n        },\r\n        RELATION: (parsedArgs, rawArgs) => {\r\n            const [fromModel, toModel] = rawArgs?.split(\"AND\") || [];\r\n            if (!fromModel || !toModel) return parsedArgs;\r\n            return { models: [fromModel.trim(), toModel.trim()] };\r\n        }\r\n    },\r\n    DELETE: {\r\n        default: (parsedArgs) => parsedArgs,\r\n        MODEL: (_, rawArgs) => {\r\n            return { models: rawArgs ? rawArgs.split(\",\").map(m => m.trim()) : [] };\r\n        },\r\n        ENUM: (_, rawArgs) => {\r\n            return { enums: rawArgs ? rawArgs.split(\",\").map(e => e.trim()) : [] };\r\n        },\r\n        FIELD: (parsedArgs, rawArgs) => {\r\n            const [fieldName, modelName] = rawArgs?.split(\"IN\") || [];\r\n            if (!fieldName || !modelName) return parsedArgs;\r\n            return { models: [modelName.trim()], fields: [fieldName.trim()] };\r\n        },\r\n        RELATION: (_, rawArgs) => {\r\n            return { models: rawArgs ? rawArgs.split(\",\").map(e => e.trim()) : [] };\r\n        },\r\n        GENERATOR: (_, rawArgs) => {\r\n            return { generators: rawArgs ? rawArgs.split(\",\").map(e => e.trim()) : [] };\r\n        }\r\n    },\r\n    UPDATE: {\r\n        default: (parsedArgs) => parsedArgs,\r\n        FIELD: (parsedArgs, rawArgs) => {\r\n            const [fieldName, modelName, prismaBlock] = rawArgs?.split(\"IN\") || [];\r\n            if (!fieldName || !modelName) return parsedArgs;\r\n            return {\r\n                models: [modelName.trim()], fields: [fieldName\r\n                    .trim()], prismaBlock: prismaBlock?.trim()\r\n            };\r\n        },\r\n        ENUM: (_, rawArgs) => {\r\n            return { enums: rawArgs ? rawArgs.split(\",\").map(e => e.trim()) : [] };\r\n        },\r\n        GENERATOR: (parsedArgs, rawArgs) => {\r\n            return { generators: rawArgs ? rawArgs.split(\",\").map(g => g.trim()) : [] };\r\n        }\r\n    },\r\n    PRINT: {\r\n        default: (parsedArgs) => parsedArgs,\r\n    },\r\n    VALIDATE: {\r\n        default: (parsedArgs) => parsedArgs,\r\n    },\r\n};\r\n\r\nexport const prismaQlParser = new PrismaQlDslParser(basePrismaQlAgsProcessor);\r\n\r\n/**\r\n * Example of extending the base parser with custom actions and commands\r\n *\r\ntype CustomAction = BasePrismaQlDSLAction | \"SAY\";\r\ntype CustomCommand = BasePrismaQLDSLCommand | \"HI\";\r\ntype CustomParserArgsProcessors = Record<\r\n    CustomAction,\r\n    {\r\n        default: PrismaQlDSLArgsProcessor<any, any>;\r\n    } & Partial<Record<CustomCommand, PrismaQlDSLArgsProcessor<any, any>>>\r\n>;\r\n\r\nconst customArgsProcessors: CustomParserArgsProcessors = {\r\n    ...basePrismaQlAgsProcessor,\r\n    SAY: {\r\n        default: (parsedArgs) => parsedArgs,\r\n        HI: (parsedArgs, rawArgs) => {\r\n            return {\r\n                models: rawArgs ? rawArgs.split(\",\").map(m => m.trim()) : [],\r\n            };\r\n        },\r\n    },\r\n};\r\n\r\nexport const customParser = new PrismaQlDslParser<CustomAction, CustomCommand>(\r\n    customArgsProcessors\r\n);\r\ncustomParser.registerCommand(\"SAY\", \"HI\", \"query\");\r\nconsole.log('test', customParser.parseCommand('SAY HI model1, model2;'));\r\n*/","import fs from \"fs\";\r\nimport fsx from \"fs-extra\";\r\nimport path from \"path\";\r\nimport { getSchema, createPrismaSchemaBuilder } from \"@mrleebo/prisma-ast\";\r\nimport { validatePrismaSchema } from \"./utils/prisma-validation.js\";\r\nimport { loadPrismaSchema } from \"./utils/load-prisma-schema.js\";\r\nimport pkg from '@prisma/internals';\r\nconst { getDMMF } = pkg;\r\nimport type { DMMF } from \"@prisma/generator-helper\";\r\nimport { PrismaQlRelationCollector, PrismaQLRelation } from \"./field-relation-collector.js\";\r\nimport { PrismaHighlighter } from \"prismalux\";\r\nimport chalk from \"chalk\";\r\nconst HighlightPrismaSchema = new PrismaHighlighter();\r\n\r\nexport type PrismaQlSchemaData = {\r\n    schemaPath?: string;\r\n    schema: string;\r\n    ast: ReturnType<typeof getSchema>;\r\n    builder: ReturnType<typeof createPrismaSchemaBuilder>;\r\n    relations: PrismaQLRelation[]\r\n}\r\n\r\nexport type PrismaQlSchemaLoaderOptions = {\r\n    backupPath?: string;\r\n}\r\nexport class PrismaQlSchemaLoader {\r\n    private lastValidatedSchema: string | null = null;\r\n    private readonly prismaState: PrismaQlSchemaData | null = null;\r\n    private backupPath: string | null = null;\r\n    constructor(\r\n        public relationCollector: PrismaQlRelationCollector,\r\n        public options: PrismaQlSchemaLoaderOptions = {}\r\n    ) {\r\n        if (options.backupPath) {\r\n            this.backupPath = options.backupPath;\r\n        }\r\n    }\r\n    async rebase() {\r\n        const schema = this.prismaState?.builder.print({ sort: true });\r\n        const parsedSchema = getSchema(schema!);\r\n        const builder = createPrismaSchemaBuilder(schema);\r\n        this.setPrismaState({ schemaPath: this.prismaState?.schemaPath, schema: schema!, ast: parsedSchema, builder, relations: this.relationCollector.getRelations() });\r\n        await this.collectRelations();\r\n    }\r\n    getSchemaPath() {\r\n        return this.prismaState?.schemaPath;\r\n    }\r\n    private setPrismaState(newState: PrismaQlSchemaData) {\r\n        (this.prismaState as PrismaQlSchemaData) = newState;\r\n    }\r\n    async loadFromFile(filePath?: string, forceReload = false) {\r\n        if (this.prismaState && !forceReload) {\r\n            return this.prismaState;\r\n        }\r\n        const { schema, path } = await loadPrismaSchema(filePath);\r\n        return this.prepareSchema(schema, path);\r\n    }\r\n    async collectRelations() {\r\n        const prismaSchema = this.prismaState?.schema || '';\r\n        const dmmf = await getDMMF({ datamodel: prismaSchema });\r\n        const models = dmmf.datamodel.models as DMMF.Model[];\r\n        return this.relationCollector.setModels(models);\r\n    }\r\n    private async prepareSchema(sourcePrismaSchema: string, schemaPath?: string) {\r\n        const isValid = await this.isValid(sourcePrismaSchema);\r\n        if (isValid instanceof Error) {\r\n            throw isValid;\r\n        }\r\n        const parsedSchema = getSchema(sourcePrismaSchema);\r\n        const builder = createPrismaSchemaBuilder(sourcePrismaSchema);\r\n        this.setPrismaState({ schemaPath: schemaPath || '', schema: sourcePrismaSchema, ast: parsedSchema, builder, relations: this.relationCollector.getRelations() });\r\n        await this.collectRelations();\r\n        return this.prismaState;\r\n    }\r\n    loadFromText(sourcePrismaSchema: string) {\r\n        return this.prepareSchema(sourcePrismaSchema);\r\n    }\r\n    async getState(): Promise<PrismaQlSchemaData> {\r\n        if (!this.prismaState) {\r\n            await this.loadFromFile();\r\n        }\r\n        const relations = this.relationCollector.getRelations();\r\n        return {\r\n            ...this.prismaState! || {},\r\n            relations\r\n        }\r\n    }\r\n    clonePrismaState(): PrismaQlSchemaData {\r\n        if (!this.prismaState) {\r\n            throw new Error(\"No schema loaded.\");\r\n        }\r\n        const { schema: sourcePrismaSchema, schemaPath } = this.prismaState;\r\n        const cloneBuilder = createPrismaSchemaBuilder(sourcePrismaSchema);\r\n        const parsedSchema = getSchema(sourcePrismaSchema);\r\n        return { schemaPath, schema: sourcePrismaSchema, ast: parsedSchema, builder: cloneBuilder, relations: this.relationCollector.getRelations() };\r\n    }\r\n    async save(commits: Array<string> | string, sourcePath?: string) {\r\n        if (!this.prismaState) {\r\n            throw new Error('No schema loaded to save. Please load a schema first.');\r\n        }\r\n\r\n        const messages = Array.isArray(commits) ? commits : [commits];\r\n        console.log(`ðŸ”„ Saving schema with ${messages.length} commit(s):`);\r\n\r\n        for (let i = 0; i < messages.length; i++) {\r\n            const message = messages[i];\r\n            const commitNumber = i + 1;\r\n            console.log(chalk.grey(`Commit ${commitNumber}:`), chalk.cyanBright(message));\r\n        }\r\n\r\n        let outputPath = sourcePath;\r\n        if (sourcePath && !path.isAbsolute(sourcePath)) {\r\n            outputPath = path.join(process.cwd(), sourcePath);\r\n        }\r\n\r\n        if (!this.prismaState?.schemaPath && !outputPath) {\r\n            throw new Error('Cannot save schema without a path, please provide a path!');\r\n        }\r\n\r\n        try {\r\n            this.check();\r\n        } catch (e) {\r\n            throw new Error('Cannot save invalid schema. Please fix the schema before saving.');\r\n        }\r\n\r\n        const finalPath = outputPath || this.prismaState.schemaPath;\r\n\r\n        if (!finalPath) {\r\n            throw new Error('Cannot save schema without a path, please provide a path!');\r\n        }\r\n        // âœ… Generate timestamped backup\r\n        if (fs.existsSync(finalPath)) {\r\n            const backupDir = this.backupPath ? this.backupPath : path.join(path.dirname(finalPath), \".prisma\", \"backups\");\r\n            fsx.ensureDirSync(backupDir);\r\n            const backupPath = path.join(backupDir, `${path.basename(finalPath)}_${new Date().toISOString().replace(/[:.]/g, \"-\")}.bak.prisma`);\r\n            fsx.copyFileSync(finalPath, backupPath);\r\n        }\r\n\r\n        // âœ… Print the schema using builder (formatted output)\r\n        const updatedsourcePrismaSchema = this.prismaState.builder.print({ sort: true });\r\n\r\n        // âœ… Save schema\r\n        fs.writeFileSync(finalPath, updatedsourcePrismaSchema, \"utf-8\");\r\n\r\n        console.log(chalk.greenBright(`âœ… Schema saved successfully to ${finalPath}`));\r\n        console.log(chalk.grey(`ðŸ“… Timestamp: ${new Date().toLocaleString()}`));\r\n    }\r\n    print() {\r\n        if (!this.prismaState) {\r\n            return \"No schema loaded.\";\r\n        }\r\n        return HighlightPrismaSchema.highlight(this.prismaState.builder.print({ sort: true }));\r\n    }\r\n    async isValid(sourceSchema?: string): Promise<true | Error> {\r\n        if (!sourceSchema && !this.prismaState) {\r\n            throw new Error(\"No schema loaded.\");\r\n        }\r\n        const sourcePrismaSchema = sourceSchema || this.prismaState?.builder.print({ sort: true });\r\n        if (!sourcePrismaSchema) {\r\n            return new Error(\"No schema content provided.\");\r\n        }\r\n        if (this.lastValidatedSchema === sourcePrismaSchema) {\r\n            return true;\r\n        }\r\n        const validation = await validatePrismaSchema(sourcePrismaSchema);\r\n        if (validation === true) {\r\n            this.lastValidatedSchema = sourcePrismaSchema;\r\n        } else {\r\n            this.lastValidatedSchema = null;\r\n        }\r\n        return validation;\r\n    }\r\n    check() {\r\n        if (!this.prismaState) {\r\n            throw new Error(\"No schema loaded.\");\r\n        }\r\n        this.isValid();\r\n    }\r\n}\r\n\r\nexport default PrismaQlSchemaLoader;\r\n","import pkg from '@prisma/internals';\r\nconst { getDMMF } = pkg;\r\n\r\n/**\r\n * Finds and validates the Prisma schema.\r\n * @returns Promise<void> Resolves if valid, throws an error if invalid.\r\n */\r\nexport async function validatePrismaSchema(schema: string): Promise<true | Error> {\r\n    try {\r\n        await getDMMF({ datamodel: schema });\r\n        return true;\r\n    } catch (error) {\r\n        return error\r\n    }\r\n}\r\n","import fs from \"fs\";\r\nimport path from \"path\";\r\n\r\nexport const loadPrismaSchema = async (inputPath?: string): Promise<{ schema: string; path: string }> => {\r\n    const cwd = process.cwd();\r\n    let schemaPath: string | null = null;\r\n\r\n    // Check if a path is provided\r\n    if (inputPath) {\r\n        // Determine if the path is absolute or relative\r\n        const resolvedPath = path.isAbsolute(inputPath) ? inputPath : path.resolve(cwd, inputPath);\r\n\r\n        if (fs.existsSync(resolvedPath)) {\r\n            const stat = fs.statSync(resolvedPath);\r\n\r\n            if (stat.isDirectory()) {\r\n                // If it's a directory, look for `schema.prisma`\r\n                const possibleSchemaPaths = [\r\n                    path.join(resolvedPath, \"prisma\", \"schema.prisma\"),\r\n                    path.join(resolvedPath, \"schema.prisma\")\r\n                ];\r\n\r\n                schemaPath = possibleSchemaPaths.find(fs.existsSync) || null;\r\n            } else if (stat.isFile()) {\r\n                // If it's a file, use it directly\r\n                schemaPath = resolvedPath;\r\n            }\r\n        }\r\n\r\n        if (!schemaPath) {\r\n            throw new Error(`âŒ Path \"${inputPath}\" does not point to a valid Prisma schema file or directory.`);\r\n        }\r\n    } else {\r\n        // If no path is provided, look in standard locations\r\n        const possibleSchemaPaths = [\r\n            path.join(cwd, \"prisma\", \"schema.prisma\"),\r\n            path.join(cwd, \"schema.prisma\")\r\n        ];\r\n        schemaPath = possibleSchemaPaths.find(fs.existsSync) || null;\r\n    }\r\n\r\n    // If no file is found, throw an error\r\n    if (!schemaPath) {\r\n        throw new Error(`âŒ Prisma schema file not found. Please ensure that the schema.prisma file exists in the \"prisma\" directory or provide a valid path.`);\r\n    }\r\n\r\n    // Read the file\r\n    const schemaContent = await fs.promises.readFile(schemaPath, \"utf-8\");\r\n\r\n    // Check if it's really a Prisma schema (look for keywords)\r\n    if (!/^\\s*(generator|datasource|client)\\b/m.test(schemaContent)) {\r\n        throw new Error(`âŒ The file at \"${schemaPath}\" does not appear to be a valid Prisma schema.`);\r\n    }\r\n\r\n    return { schema: schemaContent, path: schemaPath };\r\n};","import pkg from '@prisma/internals';\r\nconst { getDMMF } = pkg;\r\nimport type { DMMF } from \"@prisma/generator-helper\";\r\nimport pluralize from 'pluralize';\r\nimport { pascalCase } from 'change-case';\r\n\r\nexport type PrismaQlRelationType = \"1:1\" | \"1:M\" | \"M:N\";\r\n\r\nexport interface PrismaQLRelation {\r\n    type: PrismaQlRelationType;\r\n    fieldName?: string;\r\n    modelName: string;\r\n    relatedModel: string;\r\n    foreignKey?: string;\r\n    referenceKey?: string;\r\n    inverseField?: string;\r\n    relationDirection?: \"forward\" | \"backward\" | \"bidirectional\";\r\n    relationTable?: string;\r\n    relationName: string;\r\n    constraints?: string[];\r\n\r\n}\r\n\r\ntype Model = DMMF.Model;\r\nexport class PrismaQlRelationCollector {\r\n    private relations: PrismaQLRelation[] = [];\r\n    getRelations(): PrismaQLRelation[] {\r\n        return this.relations;\r\n    }\r\n    async setModels(models: Model[]) {\r\n        this.relations = [];\r\n        this.models = models;\r\n        await this.parsePrismaSchema();\r\n        return this.relations;\r\n    }\r\n    constructor(private models: Model[] = []) { }\r\n\r\n    getRelation(modelName: string, fieldName: string): PrismaQLRelation | null {\r\n        return this.relations.find(r => r.modelName === modelName && r.fieldName === fieldName) || null;\r\n    }\r\n\r\n    /**\r\n * Function to detect one-to-one relationships in Prisma DMMF models.\r\n * It now detects **both** sides of the relationship (forward & reverse).\r\n */\r\n    detectOneToOneRelations(models: Model[]): PrismaQLRelation[] {\r\n        const relations: PrismaQLRelation[] = [];\r\n\r\n        // Step 1: Identify explicit M:N join tables to exclude\r\n        const joinTables = models.filter(model => {\r\n            const relationFields = model.fields.filter(f => f.kind === \"object\" && !f.isList);\r\n            const scalarFields = model.fields.filter(f => f.kind === \"scalar\");\r\n\r\n            // Must have exactly two foreign key relations\r\n            if (relationFields.length !== 2) return false;\r\n\r\n            // Must have a composite primary key\r\n            return model.primaryKey?.fields?.every(f =>\r\n                scalarFields.some(sf => sf.name === f)\r\n            );\r\n        }).map(m => m.name);\r\n\r\n        for (const model of models) {\r\n            // Step 2: Skip explicit Many-to-Many join tables\r\n            if (joinTables.includes(model.name)) continue;\r\n\r\n            for (const field of model.fields) {\r\n                if (field.kind !== \"object\" || field.isList) {\r\n                    continue;\r\n                }\r\n\r\n                if (!field.relationFromFields || field.relationFromFields.length === 0) {\r\n                    continue;\r\n                }\r\n\r\n                // Step 3: Identify the foreign key\r\n                let isUniqueRelation = false;\r\n                let foreignKeys: string[] = [];\r\n                const relationFromFields = field.relationFromFields;\r\n\r\n                if (relationFromFields.length === 1) {\r\n                    const fkField = model.fields.find(f => f.name === relationFromFields[0]);\r\n                    if (fkField?.isUnique || model.primaryKey?.fields.includes(fkField?.name!)) {\r\n                        isUniqueRelation = true;\r\n                        foreignKeys.push(fkField?.name!);\r\n                    }\r\n                } else {\r\n                    const isCompositePrimaryKey = model.primaryKey?.fields.every(f => relationFromFields.includes(f));\r\n                    const isCompositeUnique = model.uniqueIndexes?.some(idx =>\r\n                        idx.fields.length === relationFromFields.length &&\r\n                        idx.fields.every(f => relationFromFields.includes(f))\r\n                    );\r\n\r\n                    if (isCompositePrimaryKey || isCompositeUnique) {\r\n                        isUniqueRelation = true;\r\n                        foreignKeys = [...relationFromFields];\r\n                    }\r\n                }\r\n\r\n                if (!isUniqueRelation) {\r\n                    continue;\r\n                }\r\n\r\n                // Step 4: Find the related model\r\n                const relatedModel = models.find(m => m.name === field.type);\r\n                if (!relatedModel) {\r\n                    continue;\r\n                }\r\n\r\n                // Step 5: Find the inverse field\r\n                const inverseField = relatedModel.fields.find(f =>\r\n                    f.relationName === field.relationName && f.name !== field.name\r\n                );\r\n\r\n                // Step 6: Determine reference keys\r\n                const referenceKeys = field.relationToFields || [];\r\n\r\n                // Step 7: Avoid duplicate detection\r\n                const existingRelation = relations.find(r =>\r\n                    r.modelName === model.name &&\r\n                    r.relatedModel === relatedModel.name &&\r\n                    r.fieldName === field.name\r\n                );\r\n                if (existingRelation) {\r\n                    continue; // Skip if already recorded\r\n                }\r\n\r\n                // Step 8: Push the forward relation (owning side)\r\n                relations.push({\r\n                    type: \"1:1\",\r\n                    fieldName: field.name,\r\n                    modelName: model.name,\r\n                    relatedModel: relatedModel.name,\r\n                    relationName: field.relationName!,\r\n                    foreignKey: foreignKeys.join(\", \"),\r\n                    referenceKey: referenceKeys.join(\", \"),\r\n                    inverseField: inverseField?.name,\r\n                    relationDirection: \"forward\",\r\n                    constraints: [...foreignKeys]\r\n                });\r\n\r\n                // Step 9: Push the backward relation (inverse side) if an inverse field exists\r\n                if (inverseField) {\r\n                    relations.push({\r\n                        type: \"1:1\",\r\n                        fieldName: inverseField.name,\r\n                        modelName: relatedModel.name,\r\n                        relatedModel: model.name,\r\n                        relationName: field.relationName!,\r\n                        foreignKey: undefined,\r\n                        referenceKey: undefined,\r\n                        inverseField: field.name,\r\n                        relationDirection: \"backward\",\r\n                        constraints: [...referenceKeys]\r\n                    });\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        return relations;\r\n    }\r\n    detectOneToManyRelations(models: Model[]): PrismaQLRelation[] {\r\n        const relations: PrismaQLRelation[] = [];\r\n\r\n        for (const model of models) {\r\n            for (const field of model.fields) {\r\n                if (field.kind !== \"object\" || !field.isList) {\r\n                    continue;\r\n                }\r\n\r\n                // Find the related model by matching the field type\r\n                const relatedModel = models.find(m => m.name === field.type);\r\n                if (!relatedModel) continue;\r\n\r\n                // Look for the inverse field in the related model\r\n                const inverseField = relatedModel.fields.find(f =>\r\n                    f.relationName === field.relationName && !f.isList\r\n                );\r\n                if (!inverseField) continue;\r\n\r\n                // Ensure that the inverse field has a defined foreign key (relationFromFields)\r\n                if (!inverseField.relationFromFields || inverseField.relationFromFields.length === 0) {\r\n                    continue;\r\n                }\r\n\r\n                // Join fields for composite keys, if necessary\r\n                const fk = inverseField.relationFromFields.join(\", \");\r\n                const rk =\r\n                    inverseField.relationToFields && inverseField.relationToFields.length > 0\r\n                        ? inverseField.relationToFields.join(\", \")\r\n                        : undefined;\r\n\r\n                // Avoid duplicates in self-relations by checking if we already recorded this\r\n                const existingRelation = relations.find(r =>\r\n                    r.modelName === model.name &&\r\n                    r.relatedModel === relatedModel.name &&\r\n                    r.fieldName === field.name &&\r\n                    r.relationName === field.relationName\r\n                );\r\n                if (existingRelation) {\r\n                    continue; // Skip if already recorded\r\n                }\r\n\r\n                // Forward relation: The \"many\" side (students)\r\n                relations.push({\r\n                    type: \"1:M\",\r\n                    fieldName: inverseField.name, // The field that holds the FK\r\n                    modelName: relatedModel.name,\r\n                    relatedModel: model.name,\r\n                    relationName: field.relationName!, // Track relationName!\r\n                    foreignKey: fk,\r\n                    referenceKey: rk,\r\n                    inverseField: field.name,\r\n                    relationDirection: \"forward\",\r\n                    constraints: [...inverseField.relationFromFields]\r\n                });\r\n\r\n                // Backward relation: The \"one\" side (teacher)\r\n                relations.push({\r\n                    type: \"1:M\",\r\n                    fieldName: field.name,\r\n                    modelName: model.name,\r\n                    relatedModel: relatedModel.name,\r\n                    relationName: field.relationName!, // Track relationName!\r\n                    foreignKey: undefined,\r\n                    referenceKey: undefined,\r\n                    inverseField: inverseField.name,\r\n                    relationDirection: \"backward\",\r\n                    constraints: [...inverseField.relationFromFields]\r\n                });\r\n            }\r\n        }\r\n        return relations;\r\n    }\r\n    private getManyToManyTableName(modelA: string, modelB: string, relationName?: string): string {\r\n        return getManyToManyTableName(modelA, modelB, relationName);\r\n    }\r\n    detectManyToManyRelations(models: Model[]): PrismaQLRelation[] {\r\n        const relations: PrismaQLRelation[] = [];\r\n        const seenRelations = new Set<string>(); // Prevent duplicate relations\r\n\r\n        for (const model of models) {\r\n            for (const field of model.fields) {\r\n                // Skip non-list and non-object fields\r\n                if (field.kind !== \"object\" || !field.isList) {\r\n                    continue;\r\n                }\r\n\r\n                // Find the related model\r\n                const relatedModel = models.find(m => m.name === field.type);\r\n                if (!relatedModel) continue;\r\n\r\n                // Find all inverse fields (not just the first match)\r\n                const inverseFields = relatedModel.fields.filter(f =>\r\n                    f.relationName === field.relationName && f.isList\r\n                );\r\n\r\n                if (inverseFields.length === 0) continue;\r\n\r\n                // Ensure this is truly an implicit M:N relation (no foreign keys)\r\n                const hasExplicitForeignKey = models.some(m =>\r\n                    m.fields.some(f =>\r\n                        f.relationName === field.relationName && (f.relationFromFields || []).length > 0\r\n                    )\r\n                );\r\n                if (hasExplicitForeignKey) {\r\n                    continue; // Skip 1:M relations like `TeacherStudents`\r\n                }\r\n\r\n                for (const inverseField of inverseFields) {\r\n                    // **Fix 1: Avoid adding same field as inverse**\r\n                    if (field.name === inverseField.name) {\r\n                        continue; // Skip redundant self-mapping\r\n                    }\r\n\r\n                    // **Fix 2: Ensure only unique relations are added**\r\n                    const relationKey = [model.name, relatedModel.name, field.relationName]\r\n                        .sort() // Ensures consistency (A-B == B-A)\r\n                        .join(\"|\");\r\n\r\n                    if (seenRelations.has(relationKey)) {\r\n                        continue; // Avoid duplicate bidirectional relations\r\n                    }\r\n\r\n                    seenRelations.add(relationKey);\r\n\r\n                    const isExplicit = models.some(m =>\r\n                        m.fields.some(f => f.relationName === field.relationName && (f.relationFromFields || []).length > 0)\r\n                    );\r\n                    const tableName = this.getManyToManyTableName(model.name, relatedModel.name, isExplicit ? field.relationName : undefined);\r\n\r\n                    // Add relation for the current field\r\n                    relations.push({\r\n                        type: \"M:N\",\r\n                        fieldName: field.name,\r\n                        modelName: model.name,\r\n                        relatedModel: relatedModel.name,\r\n                        relationName: field.relationName!,\r\n                        foreignKey: undefined,\r\n                        referenceKey: undefined,\r\n                        inverseField: inverseField.name,\r\n                        relationDirection: \"bidirectional\",\r\n                        relationTable: tableName, // Prisma implicit table naming convention\r\n                        constraints: []\r\n                    });\r\n\r\n                    if (inverseField.name) {\r\n                        // Add relation for the inverse field\r\n                        relations.push({\r\n                            type: \"M:N\",\r\n                            fieldName: inverseField.name,\r\n                            modelName: relatedModel.name,\r\n                            relatedModel: model.name,\r\n                            relationName: field.relationName!,\r\n                            foreignKey: undefined,\r\n                            referenceKey: undefined,\r\n                            inverseField: field.name,\r\n                            relationDirection: \"bidirectional\",\r\n                            relationTable: tableName, // Prisma implicit table naming convention\r\n                            constraints: []\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return relations;\r\n    }\r\n    detectExplicitManyToManyRelations(models: Model[]): PrismaQLRelation[] {\r\n        const relations: PrismaQLRelation[] = [];\r\n\r\n        for (const model of models) {\r\n            // Step 1: Identify potential join tables\r\n            const relationFields = model.fields.filter(f => f.kind === \"object\" && !f.isList);\r\n            const scalarFields = model.fields.filter(f => f.kind === \"scalar\");\r\n\r\n            // A join table must have **exactly two foreign key relations**\r\n            if (relationFields.length !== 2) {\r\n                continue;\r\n            }\r\n\r\n            // Step 2: Ensure both relations are linked via foreign keys\r\n            const [relation1, relation2] = relationFields;\r\n            if (\r\n                !relation1.relationFromFields?.length ||\r\n                !relation2.relationFromFields?.length\r\n            ) {\r\n                continue;\r\n            }\r\n\r\n            // Step 3: Find the related models\r\n            const model1 = models.find(m => m.name === relation1.type);\r\n            const model2 = models.find(m => m.name === relation2.type);\r\n            if (!model1 || !model2) {\r\n                continue;\r\n            }\r\n\r\n            // Step 4: Ensure that **both foreign keys** form a composite primary key\r\n            const compositePK = model.primaryKey?.fields?.every(f =>\r\n                scalarFields.some(sf => sf.name === f)\r\n            );\r\n\r\n            if (!compositePK) {\r\n                continue; // If the table does not use a composite key, it's not an explicit M:N relation\r\n            }\r\n\r\n            // Step 5: Register the **Explicit Many-to-Many Relation**\r\n            relations.push({\r\n                type: \"M:N\",\r\n                fieldName: pluralize(model1.name), // Example: \"posts\"\r\n                modelName: model1.name,\r\n                relatedModel: model2.name,\r\n                relationName: relation1.relationName!,\r\n                foreignKey: relation1.relationFromFields.join(\", \"),\r\n                referenceKey: relation1.relationToFields?.join(\", \"),\r\n                inverseField: pluralize(model2.name.toLowerCase()), // Example: \"categories\"\r\n                relationDirection: \"bidirectional\",\r\n                relationTable: model.name, // The join table\r\n                constraints: [...relation1.relationFromFields, ...relation2.relationFromFields]\r\n            });\r\n\r\n            relations.push({\r\n                type: \"M:N\",\r\n                fieldName: pluralize(model2.name),\r\n                modelName: model2.name,\r\n                relatedModel: model1.name,\r\n                relationName: relation2.relationName!,\r\n                foreignKey: relation2.relationFromFields.join(\", \"),\r\n                referenceKey: relation2.relationToFields?.join(\", \"),\r\n                inverseField: pluralize(model1.name.toLowerCase()),\r\n                relationDirection: \"bidirectional\",\r\n                relationTable: model.name, // The join table\r\n                constraints: [...relation1.relationFromFields, ...relation2.relationFromFields]\r\n            });\r\n\r\n            // Add the join table model itself to the relations if it has relations\r\n            relations.push({\r\n                type: \"M:N\",\r\n                fieldName: undefined,\r\n                modelName: model.name,\r\n                relatedModel: `${model1.name}, ${model2.name}`,\r\n                relationName: `${relation1.relationName}, ${relation2.relationName}`,\r\n                foreignKey: `${relation1.relationFromFields.join(\", \")}, ${relation2.relationFromFields.join(\", \")}`,\r\n                referenceKey: `${relation1.relationToFields?.join(\", \")}, ${relation2.relationToFields?.join(\", \")}`,\r\n                inverseField: `${pluralize(model1.name)}, ${pluralize(model2.name)}`,\r\n                relationDirection: \"bidirectional\",\r\n                relationTable: model.name,\r\n                constraints: [...relation1.relationFromFields, ...relation2.relationFromFields]\r\n            });\r\n\r\n        }\r\n\r\n        return relations;\r\n    }\r\n    private deduplicateRelations(relations: PrismaQLRelation[]): PrismaQLRelation[] {\r\n        const seen = new Set<string>();\r\n        const result: PrismaQLRelation[] = [];\r\n\r\n        for (const r of relations) {\r\n            const key = [\r\n                r.type,\r\n                r.modelName,\r\n                r.relatedModel,\r\n                r.fieldName,\r\n                r.relationName,\r\n                r.foreignKey || '',\r\n                r.referenceKey || '',\r\n                r.inverseField || '',\r\n                r.relationTable || '',\r\n                r.relationDirection || '',\r\n                (r.constraints || []).join(',')\r\n            ].join('|');\r\n\r\n            if (!seen.has(key)) {\r\n                seen.add(key);\r\n                result.push(r);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n    async collectRelations(models: Model[]): Promise<PrismaQLRelation[]> {\r\n        // 1) Detect explicit M:N relations\r\n        const explicitM2MRelations = this.detectExplicitManyToManyRelations(models);\r\n        // Collect join table names to exclude them from 1:1 and 1:M detection\r\n        const explicitJoinTableNames = new Set(\r\n            explicitM2MRelations\r\n                .filter(r => r.modelName === r.relationTable)\r\n                .map(r => r.modelName)\r\n        );\r\n\r\n        // 2) Detect implicit M:N relations\r\n        const implicitM2MRelations = this.detectManyToManyRelations(models);\r\n\r\n        // 3) Filter models to exclude join tables for 1:1 and 1:M detection\r\n        const modelsForOneX = models.filter(m => !explicitJoinTableNames.has(m.name));\r\n\r\n        // 4) Detect 1:1 and 1:M relations on filtered models\r\n        const oneToOneRelations = this.detectOneToOneRelations(modelsForOneX);\r\n        const oneToManyRelations = this.detectOneToManyRelations(modelsForOneX);\r\n\r\n        // 5) Combine all relations into one array\r\n        let relations: PrismaQLRelation[] = [\r\n            ...explicitM2MRelations,\r\n            ...implicitM2MRelations,\r\n            ...oneToOneRelations,\r\n            ...oneToManyRelations\r\n        ];\r\n        relations = this.deduplicateRelations(relations);\r\n        return relations;\r\n    }\r\n    async parsePrismaSchema(schema?: string): Promise<void> {\r\n        const dmmf = schema ? await getDMMF({ datamodel: schema }) : null;\r\n        const models = dmmf ? dmmf.datamodel.models as DMMF.Model[] : this.models;\r\n        const relations = this.collectRelations(models);\r\n        this.relations = await relations;\r\n    }\r\n}\r\n\r\nexport const getManyToManyTableName = (modelA: string, modelB: string, relationName?: string) => {\r\n    // If the relation is explicit (relationName is set), use it\r\n    if (relationName) return relationName;\r\n\r\n    // In implicit M:N relations, Prisma automatically names tables as _ModelAToModelB (in alphabetical order)\r\n    const [first, second] = [modelA, modelB].sort();\r\n    return `_${pascalCase(first)}To${pascalCase(second)}`;\r\n}\r\nexport const getManyToManyModelName = (modelA: string, modelB: string, relationName?: string) => {\r\n    // If the relation is explicit (relationName is set), use it\r\n    if (relationName) return relationName;\r\n\r\n    // In implicit M:N relations, Prisma automatically names tables as _ModelAToModelB (in alphabetical order)\r\n    const [first, second] = [modelA, modelB].sort();\r\n    return `${pascalCase(first)}To${pascalCase(second)}`;\r\n}","import { createPrismaSchemaBuilder } from \"@mrleebo/prisma-ast\";\r\nimport treeify from \"treeify\";\r\nimport chalk from 'chalk';\r\nimport boxen from 'boxen';\r\nimport { PrismaQlRelationCollector, PrismaQLRelation } from \"./field-relation-collector.js\";\r\nimport pkg from '@prisma/internals';\r\nconst { getDMMF } = pkg;\r\nimport type { DMMF } from \"@prisma/generator-helper\";\r\nimport fs from 'fs';\r\nconst collector = new PrismaQlRelationCollector();\r\n\r\nexport type PrismaQlModelTree = {\r\n    model: string;\r\n    relations: PrismaQlRelationNode[];\r\n};\r\nexport type PrismaQlJsonRelationTree = {\r\n    trees: PrismaQlModelTree[];\r\n    models: Set<string>;\r\n    relations: Set<string>;\r\n};\r\nexport type PrismaQlRelationNode = {\r\n    relatedModel: string;\r\n    field: string;\r\n    type: string;\r\n    alias?: string;\r\n    foreignKey?: string;\r\n    referenceKey?: string;\r\n    relationTable?: string;\r\n    inverseField?: string;\r\n    constraints?: string[];\r\n    isSelfRelation?: boolean;\r\n    isList?: boolean;\r\n    subTree?: PrismaQlModelTree;\r\n};\r\n\r\nexport type PrismaQLRelationStatistics = {\r\n    uniqueModels: number;\r\n    totalRelations: number;\r\n    maxDepth: number;\r\n}\r\nexport class PrismaQlFieldRelationLogger {\r\n    relations: PrismaQLRelation[];\r\n    setRelations(relations: PrismaQLRelation[]) {\r\n        this.relations = relations;\r\n    }\r\n    constructor(relations?: PrismaQLRelation[]) {\r\n        if (relations) {\r\n            this.setRelations(relations);\r\n        }\r\n    }\r\n    buildJsonModelTrees(\r\n        rootModel: string,\r\n        relations: PrismaQLRelation[],\r\n        maxDepth: number,\r\n        depth = 0,\r\n        visitedModels = new Set<string>()\r\n    ): PrismaQlJsonRelationTree {\r\n        if (depth > maxDepth || visitedModels.has(rootModel)) {\r\n            return { trees: [], models: new Set(), relations: new Set() };\r\n        }\r\n        visitedModels.add(rootModel);\r\n\r\n        let trees: PrismaQlModelTree[] = [];\r\n        let models = new Set<string>();\r\n        let relationsSet = new Set<string>();\r\n\r\n        const modelRelations = relations.filter(rel => rel.modelName === rootModel);\r\n\r\n        let relationNodes: PrismaQlRelationNode[] = [];\r\n\r\n        for (const relation of modelRelations) {\r\n            const isSelfRelation = relation.modelName === relation.relatedModel;\r\n            const isList = (relation.type === \"1:M\" || relation.type === \"M:N\") && !relation.foreignKey;\r\n\r\n            let relationNode: PrismaQlRelationNode = {\r\n                relatedModel: relation.relatedModel,\r\n                field: relation.fieldName || relation.modelName,\r\n                type: relation.type,\r\n                alias: relation.fieldName || relation.relationName,\r\n                foreignKey: relation.foreignKey,\r\n                referenceKey: relation.referenceKey,\r\n                relationTable: relation.relationTable,\r\n                inverseField: relation.inverseField,\r\n                constraints: relation.constraints || [],\r\n                isSelfRelation,\r\n                isList,\r\n            };\r\n\r\n            models.add(rootModel);\r\n            models.add(relation.relatedModel);\r\n            relationsSet.add(`${rootModel} -> ${relation.relatedModel}`);\r\n\r\n            const subTree = this.buildJsonModelTrees(relation.relatedModel, relations, maxDepth, depth + 1, visitedModels);\r\n            if (subTree.trees.length > 0) {\r\n                relationNode.subTree = subTree.trees[0];\r\n            }\r\n\r\n            relationNodes.push(relationNode);\r\n        }\r\n\r\n        trees.push({ model: rootModel, relations: relationNodes });\r\n\r\n        return { trees, models, relations: relationsSet };\r\n    }\r\n\r\n    buildModelTrees(\r\n        rootModel: string,\r\n        relations: PrismaQLRelation[],\r\n        maxDepth: number,\r\n        depth = 0,\r\n        visitedModels = new Set<string>()\r\n    ): { trees: Record<string, any>[], models: Set<string>, relations: Set<string> } {\r\n        if (depth > maxDepth || visitedModels.has(rootModel)) return { trees: [], models: new Set(), relations: new Set() };\r\n        visitedModels.add(rootModel);\r\n\r\n        let trees: Record<string, any>[] = [];\r\n        let models = new Set<string>();\r\n        let relationsSet = new Set<string>();\r\n\r\n        const modelRelations = relations.filter(rel => rel.modelName === rootModel);\r\n\r\n        let table: Record<string, any> = {};\r\n        for (const relation of modelRelations) {\r\n            const relationType = relation.type;\r\n            const name = relation.fieldName || relation.modelName;\r\n            const relationAlias = `(as ${relation.fieldName || relation.relationName})`;\r\n            // Determine if the relation is self-referencing\r\n            const isSelfRelation = relation.modelName === relation.relatedModel;\r\n            const selfRelationIcon = isSelfRelation ? chalk.yellow(\"ðŸ”\") : \"\"; // Add self-relation icon\r\n\r\n            let keyInfo = chalk.gray(\"[-]\");\r\n            if (relation.foreignKey) {\r\n                const direction = relation.relationDirection === \"backward\" ? \"â†\" : \"â†’\";\r\n                keyInfo = `[FK: ${chalk.blue(relation.foreignKey)} ${direction} ${chalk.green(relation.referenceKey || \"id\")}]`;\r\n            } else if (relation.relationTable) {\r\n                keyInfo = `[M:N via ${chalk.yellow(relation.relationTable)}]`;\r\n            }\r\n            if (relation.relationTable && relation.relationTable !== relation.modelName) {\r\n                if (!table[relation.relationTable]) {\r\n                    table[relation.relationTable] = {}; // Adding join table\r\n                }\r\n\r\n                // Add relation inside join table\r\n                table[relation.relationTable][\r\n                    `â†’ ${chalk.yellow(relation.modelName)}:${chalk.cyan(relation.fieldName)} [FK: ${chalk.blue(relation.foreignKey || \"?\")} â†’ ${chalk.green(relation.referenceKey || \"?\")}]`\r\n                ] = {};\r\n\r\n                table[relation.relationTable][\r\n                    `â†’ ${chalk.yellow(relation.relatedModel)}:${chalk.cyan(relation.inverseField)} [FK: ${chalk.blue(relation.foreignKey || \"?\")} â†’ ${chalk.green(relation.referenceKey || \"?\")}]`\r\n                ] = {};\r\n            }\r\n\r\n            const constraints = relation?.constraints?.length\r\n                ? `Constraints: ${chalk.magenta(relation.constraints.join(\", \"))}`\r\n                : \"\";\r\n\r\n            const isList = (relationType === \"1:M\" || relationType === \"M:N\") && !relation?.foreignKey;\r\n\r\n            let relationLabel = `â†’ ${chalk.yellow(relation.relatedModel + (isList ? '[]' : ''))}:${chalk.cyan(name)} ${relationAlias} ${chalk.red(relationType)} ${keyInfo} ${constraints} ${selfRelationIcon}`;\r\n\r\n            if (!table[relationLabel]) {\r\n                table[relationLabel] = {};\r\n            }\r\n\r\n            // Add to statistics\r\n            models.add(rootModel);\r\n            models.add(relation.relatedModel);\r\n            relationsSet.add(`${rootModel} -> ${relation.relatedModel}`);\r\n        }\r\n\r\n        trees.push({ [chalk.bold(rootModel)]: table });\r\n\r\n        for (const relation of modelRelations) {\r\n            const subTree = this.buildModelTrees(relation.relatedModel, relations, maxDepth, depth + 1, visitedModels);\r\n            trees = trees.concat(subTree.trees);\r\n            subTree.models.forEach(m => models.add(m));\r\n            subTree.relations.forEach(r => relationsSet.add(r));\r\n        }\r\n\r\n        return { trees, models, relations: relationsSet };\r\n    }\r\n    getRelationStatistics(modelName: string, maxDepth: number = 1): PrismaQLRelationStatistics {\r\n        if (!this.relations?.length) {\r\n            throw new Error('No relations found. Please run relation-collector first and use the setRelations method to set the relations.');\r\n        }\r\n\r\n        let relatedModels = new Set<string>(); // Unique models\r\n        let relationCount = 0; // Number of relations\r\n\r\n        // Recursive function to traverse relations\r\n        const exploreRelations = (currentModel: string, depth: number) => {\r\n            if (depth > maxDepth || relatedModels.has(currentModel)) return;\r\n\r\n            relatedModels.add(currentModel);\r\n\r\n            // Filter relations for the current model\r\n            for (const rel of this.relations.filter(r => r.modelName === currentModel)) {\r\n                relationCount++;\r\n                exploreRelations(rel.relatedModel, depth + 1);\r\n            }\r\n        };\r\n\r\n        // Start traversal from `modelName`\r\n        exploreRelations(modelName, 1);\r\n\r\n        return {\r\n            uniqueModels: relatedModels.size, // Number of unique models\r\n            totalRelations: relationCount, // Total number of relations\r\n            maxDepth // Depth passed from outside\r\n        };\r\n    }\r\n\r\n    collectRelationStatistics(models: Set<string>, relations: Set<string>, rootModel: string, maxDepth: number) {\r\n        const directRelations = rootModel ? [...relations].filter(r => r.startsWith(rootModel)) : [...relations];\r\n        return {\r\n            uniqueModels: models.size,\r\n            totalRelations: relations.size,\r\n            directRelations: directRelations.length,\r\n            maxDepth\r\n        };\r\n    }\r\n    private async parseSchemaAndSetRelations(schema: string) {\r\n        const dmmf = await getDMMF({ datamodel: schema });\r\n        const models = dmmf.datamodel.models as DMMF.Model[];\r\n        this.setRelations(await collector.setModels(models));\r\n        return this.relations;\r\n    }\r\n    async provideRelationsFromBuilder(builder: ReturnType<typeof createPrismaSchemaBuilder>) {\r\n        const schema = builder.print({ sort: true });\r\n        return this.parseSchemaAndSetRelations(schema);\r\n    }\r\n    async provideRelationsFromSchema(schema: string) {\r\n        return this.parseSchemaAndSetRelations(schema);\r\n    }\r\n    async privideRelationByPrismaPath(prismaPath: string) {\r\n        const prismaSchemaContent = fs.readFileSync(prismaPath, 'utf-8');\r\n        return this.parseSchemaAndSetRelations(prismaSchemaContent);\r\n    }\r\n    generateRelationTreeLog(\r\n        rootModel: string,\r\n        maxDepth: number = 1,\r\n        relations?: PrismaQLRelation[]\r\n    ) {\r\n        if (relations?.length) {\r\n            this.setRelations(relations);\r\n        }\r\n        if (!this.relations?.length) {\r\n            throw new Error('No relations found.');\r\n        }\r\n\r\n        const { models, relations: rels, trees } = this.buildModelTrees(rootModel, this.relations, maxDepth);\r\n\r\n        // Collect statistics\r\n        const stats = this.collectRelationStatistics(models, rels, rootModel, maxDepth);\r\n\r\n        let output = `${chalk.green.bold('ðŸ“Š Relation Tree Statistics')}\\n`;\r\n        output += `${chalk.yellow('Model:')} ${chalk.bold(rootModel)}\\n`;\r\n        output += `${chalk.cyan('Max Depth:')} ${chalk.bold(maxDepth)}\\n`;\r\n        output += `${chalk.blue('Related Models:')} ${chalk.bold(stats.uniqueModels)}\\n`;\r\n        output += `${chalk.magenta('Total Relations:')} ${chalk.bold(stats.totalRelations)}\\n`;\r\n        output += `${chalk.redBright('Direct Relations:')} ${chalk.bold(stats.directRelations)}\\n`;\r\n        // direct relations\r\n\r\n        let treeOutput = '';\r\n        for (const tree of trees) {\r\n            treeOutput += treeify.asTree(tree, true, true) + '\\n';\r\n        }\r\n\r\n        const results = [...rels.values()].filter(el => {\r\n            return el.startsWith(rootModel) || el.endsWith(rootModel);\r\n        }).map(r => chalk.gray(r)).join('\\n');\r\n        const relsList = `${chalk.white.bold('ðŸ”— Direct Relations')}\\n${results}`;\r\n\r\n        // Output statistics + tree, without extra spaces\r\n        return boxen(output.trim() + '\\n' + treeOutput.trim() + `\\n\\n${relsList}`, {\r\n            padding: 1,\r\n            borderColor: 'green',\r\n            borderStyle: 'round'\r\n        })\r\n    }\r\n}\r\n\r\n\r\nexport const getRelationStatistics = (relations: PrismaQLRelation[], modelName: string, maxDepth: number = 1): PrismaQLRelationStatistics => {\r\n\r\n    let relatedModels = new Set<string>(); // Unique models\r\n    let relationCount = 0; // Number of relations\r\n\r\n    // Recursive function to traverse relations\r\n    const exploreRelations = (currentModel: string, depth: number) => {\r\n        if (depth > maxDepth || relatedModels.has(currentModel)) return;\r\n\r\n        relatedModels.add(currentModel);\r\n\r\n        // Filter relations for the current model\r\n        for (const rel of relations.filter(r => r.modelName === currentModel)) {\r\n            relationCount++;\r\n            exploreRelations(rel.relatedModel, depth + 1);\r\n        }\r\n    };\r\n\r\n    // Start traversal from `modelName`\r\n    exploreRelations(modelName, 1);\r\n\r\n    return {\r\n        uniqueModels: relatedModels.size, // Number of unique models\r\n        totalRelations: relationCount, // Total number of relations\r\n        maxDepth // Depth passed from outside\r\n    };\r\n}\r\n","import chalk from \"chalk\";\r\nimport { PrismaQlDSLAction, PrismaQLDSLCommand, prismaQlParser, PrismaQLParsedDSL, PrismaQlDSLQueryAction, PrismaQlDSLMutationAction } from \"./dsl.js\";\r\nimport { PrismaQLHandlerResponse, handlerResponse } from \"./handler-registries/handler-registry.js\";\r\nimport { PrismaQlMutationHandlerRegistry } from \"./handler-registries/mutation-handler-registry.js\";\r\nimport { PrismaQlQueryHandlerRegistry } from \"./handler-registries/query-handler-registry.js\";\r\nimport PrismaQlSchemaLoader from \"./prisma-schema-loader.js\";\r\nimport { validatePrismaSchema } from \"./utils/prisma-validation.js\";\r\nimport { PrismaHighlighter } from \"prismalux\";\r\nconst highlightPrismaSchema = new PrismaHighlighter();\r\n\r\nexport type PrismaQlMutationOptions = {\r\n    save?: boolean;\r\n    dryRun?: boolean;\r\n    confirm?: (schema: string) => Promise<boolean>;\r\n}\r\nexport class PrismaQlProvider {\r\n    private queryHandler: PrismaQlQueryHandlerRegistry;\r\n    private mutationHandler: PrismaQlMutationHandlerRegistry;\r\n    private loader: PrismaQlSchemaLoader;\r\n    private mutationState: PrismaQLParsedDSL<PrismaQlDSLAction, PrismaQLDSLCommand, 'mutation'>[] = [];\r\n\r\n    constructor(config: {\r\n        queryHandler: PrismaQlQueryHandlerRegistry;\r\n        mutationHandler: PrismaQlMutationHandlerRegistry;\r\n        loader: PrismaQlSchemaLoader;\r\n    }) {\r\n        this.queryHandler = config.queryHandler;\r\n        this.mutationHandler = config.mutationHandler;\r\n        this.loader = config.loader;\r\n    }\r\n\r\n    async multiApply(commands: string[] | string, options: PrismaQlMutationOptions = {}): Promise<PrismaQLHandlerResponse[]> {\r\n        const commandsArray = Array.isArray(commands) ? commands : commands.split(';').map((c) => c.trim()).filter((c) => c.length > 0).map((c) => c + ';');\r\n        const responses: Array<{\r\n            parsedCommand: PrismaQLParsedDSL<PrismaQlDSLAction, PrismaQLDSLCommand, 'query' | 'mutation'>,\r\n            response: PrismaQLHandlerResponse\r\n        }> = [];\r\n\r\n        for (const command of commandsArray) {\r\n            try {\r\n                const result = await this.apply(command);\r\n                if (result?.response?.error) {\r\n                    throw new Error(\"string\" === typeof result.response.error ? result.response.error : \"Error applying command\");\r\n                }\r\n                responses.push(result);\r\n            } catch (e) {\r\n                console.log(chalk.red(`Error processing command: ${e.message}`));\r\n                throw e;\r\n            }\r\n        }\r\n        const hasMutations = responses.some((r) => r.parsedCommand.type === 'mutation');\r\n        if (options.confirm && options.save && hasMutations && !options.dryRun) {\r\n            const confirmed = await options.confirm(highlightPrismaSchema.highlight(this.loader.print()));\r\n            if (confirmed) {\r\n                await this.save();\r\n            }\r\n        }\r\n        return responses.map((r) => r.response);\r\n    }\r\n\r\n    async apply<A extends PrismaQlDSLAction, C extends PrismaQLDSLCommand>(input: string | PrismaQLParsedDSL<PrismaQlDSLAction, PrismaQLDSLCommand, 'query' | 'mutation'>, options?: PrismaQlMutationOptions): Promise<{\r\n        parsedCommand: PrismaQLParsedDSL<A, C, 'query' | 'mutation'>,\r\n        response: PrismaQLHandlerResponse\r\n    }> {\r\n        const parsedCommand = \"string\" === typeof input ? this.parseCommand<A, C, 'query' | 'mutation'>(input) : input;\r\n        if (parsedCommand.type === 'query') {\r\n            return {\r\n                parsedCommand: parsedCommand as PrismaQLParsedDSL<A, C, 'query'>,\r\n                response: await this.query(parsedCommand as PrismaQLParsedDSL<PrismaQlDSLQueryAction, PrismaQLDSLCommand, 'query'>)\r\n            }\r\n        }\r\n        if (parsedCommand.type === 'mutation') {\r\n            return {\r\n                parsedCommand: parsedCommand as PrismaQLParsedDSL<A, C, 'mutation'>,\r\n                response: await this.mutation(parsedCommand as PrismaQLParsedDSL<PrismaQlDSLMutationAction, PrismaQLDSLCommand, 'mutation'>, options)\r\n            }\r\n        }\r\n        throw new Error(`Invalid command type: expected \"query\" or \"mutation\", got \"${parsedCommand.type}\"`);\r\n    }\r\n\r\n    async query<A extends PrismaQlDSLQueryAction, C extends PrismaQLDSLCommand>(input: string | PrismaQLParsedDSL<PrismaQlDSLQueryAction, PrismaQLDSLCommand, 'query'>): Promise<PrismaQLHandlerResponse> {\r\n        const parsedCommand = \"string\" === typeof input ? this.parseCommand<A, C, 'query'>(input) : input;\r\n        if (parsedCommand.type !== 'query') {\r\n            throw new Error(`Invalid command type: expected \"query\", got \"${parsedCommand.type}\"`);\r\n        }\r\n        if (!parsedCommand.command) {\r\n            const isPrint = parsedCommand.action === 'PRINT';\r\n            const isValidate = parsedCommand.action === 'VALIDATE';\r\n            if (!isPrint && !isValidate) {\r\n                throw new Error(`Invalid command: command is required`);\r\n            }\r\n            if (isPrint) {\r\n                return handlerResponse(parsedCommand).result(this.loader.print());\r\n            }\r\n            if (isValidate) {\r\n                return handlerResponse(parsedCommand).result(await this.loader.isValid());\r\n            }\r\n        }\r\n        return this.queryHandler.execute(parsedCommand.action, parsedCommand.command!, this.loader.clonePrismaState(), parsedCommand);\r\n    }\r\n\r\n    async dryMutation<A extends PrismaQlDSLMutationAction, C extends PrismaQLDSLCommand>(input: string | PrismaQLParsedDSL<PrismaQlDSLMutationAction, PrismaQLDSLCommand, 'mutation'>): Promise<string> {\r\n        const parsedCommand = \"string\" == typeof input ? this.parseCommand<A, C, 'mutation'>(input) : input;\r\n        if (parsedCommand.type !== 'mutation') {\r\n            throw new Error(`Invalid command type: expected \"mutation\", got \"${parsedCommand.type}\"`);\r\n        }\r\n        const clone = this.loader.clonePrismaState();\r\n\r\n        const displayCommand = `${parsedCommand.action} ${parsedCommand.command} >`;\r\n        try {\r\n            const result = await this.mutationHandler.execute(parsedCommand.action, parsedCommand.command!, clone, parsedCommand);\r\n            if (result?.error) {\r\n                if (\"string\" === typeof result.error) {\r\n                    throw new Error(result.error);\r\n                } else {\r\n                    throw result.error;\r\n                }\r\n            }\r\n            console.log('âœ…', chalk.gray(displayCommand), chalk.green(`Dry run success!`));\r\n        } catch (e) {\r\n            throw new Error(`Modification failed: ${e.message}`);\r\n        }\r\n\r\n        // Validate the modified schema\r\n        const updatedSchema = clone.builder.print({ sort: true });\r\n        const validation = await validatePrismaSchema(updatedSchema);\r\n        if (validation instanceof Error) {\r\n            throw new Error(`Modification failed: ${validation.message}`);\r\n        }\r\n        console.log('âœ…', chalk.gray(displayCommand), chalk.green(`Validation success!`));\r\n        return updatedSchema;\r\n    }\r\n\r\n    async mutation<A extends PrismaQlDSLMutationAction, C extends PrismaQLDSLCommand>(input: string | PrismaQLParsedDSL<PrismaQlDSLMutationAction, PrismaQLDSLCommand, 'mutation'>, options: PrismaQlMutationOptions = {}): Promise<PrismaQLHandlerResponse> {\r\n        const parsedCommand = \"string\" === typeof input ? this.parseCommand<A, C, \"mutation\">(input) : input;\r\n        if (parsedCommand.type !== 'mutation') {\r\n            throw new Error(`Invalid command type: expected \"mutation\", got \"${parsedCommand.type}\"`);\r\n        }\r\n\r\n        const updatedSchema = await this.dryMutation<A, C>(input);\r\n        if (!updatedSchema) {\r\n            return handlerResponse(parsedCommand).error(`Dry run failed`);\r\n        }\r\n\r\n        if (options.dryRun) {\r\n            return handlerResponse(parsedCommand).result(highlightPrismaSchema.highlight(updatedSchema));\r\n        }\r\n        if (options.confirm) {\r\n            const message = `${highlightPrismaSchema.highlight(updatedSchema)}`;\r\n            const confirmed = await options.confirm(message);\r\n            if (!confirmed) {\r\n                return handlerResponse(parsedCommand).error(`Modification cancelled`);\r\n            }\r\n        }\r\n        // Apply the modification to the main schema because it's valid\r\n        try {\r\n            const state = await this.loader.getState();\r\n            this.mutationHandler.execute(parsedCommand.action, parsedCommand.command!, state, parsedCommand);\r\n\r\n            this.mutationState.push(parsedCommand);\r\n\r\n            const displayCommand = `${parsedCommand.action} ${parsedCommand.command} > `;\r\n            console.log('âœ…', chalk.white(displayCommand), chalk.green('Mutation success'));\r\n        } catch (e) {\r\n            throw new Error(`Modification failed: ${e.message}`);\r\n        }\r\n        // We need to rebase parsedSchema to the updated schema\r\n        if (options.save) {\r\n            await this.save();\r\n        }\r\n        await this.loader.rebase();\r\n        return handlerResponse(parsedCommand).result(highlightPrismaSchema.highlight(updatedSchema));\r\n    }\r\n\r\n    async save(): Promise<void> {\r\n        if (this.mutationState.length === 0) {\r\n            return;\r\n        }\r\n        const messages = this.mutationState.map((mutation) => mutation.raw);\r\n        this.loader.save(messages);\r\n        this.mutationState = [];\r\n    }\r\n\r\n    private parseCommand<A extends PrismaQlDSLAction, C extends PrismaQLDSLCommand, T extends 'query' | 'mutation'>(input: string): PrismaQLParsedDSL<A, C, T> {\r\n        return prismaQlParser.parseCommand(input);\r\n    }\r\n}","import {\r\n    PrismaQlDSLAction,\r\n    PrismaQLDSLCommand,\r\n    PrismaQLParsedDSL,\r\n    PrismaQlDSLType,\r\n} from '../dsl.js';\r\nimport { PrismaQlSchemaData } from '../prisma-schema-loader.js';\r\n\r\nexport type PrismaQLHandlerResponse = {\r\n    dsl: PrismaQLParsedDSL<PrismaQlDSLAction, PrismaQLDSLCommand, PrismaQlDSLType>;\r\n    result?: any;\r\n    error?: string | Error;\r\n}\r\n\r\nexport type PrismaQlHandler<A extends PrismaQlDSLAction, C extends PrismaQLDSLCommand, T extends PrismaQlDSLType> = (\r\n    prismaState: PrismaQlSchemaData,\r\n    dsl: PrismaQLParsedDSL<A, C, T>\r\n) => PrismaQLHandlerResponse;\r\n\r\n\r\nexport const handlerResponse = (dsl: PrismaQLParsedDSL<PrismaQlDSLAction, PrismaQLDSLCommand, PrismaQlDSLType>): {\r\n    error: (error: string | Error) => PrismaQLHandlerResponse;\r\n    result: (result: any) => PrismaQLHandlerResponse;\r\n} => {\r\n    return {\r\n        error: (error: string | Error) => {\r\n            return { dsl, error };\r\n        },\r\n        result: (result: any) => {\r\n            return {\r\n                dsl, result\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport class PrismaQlHandlerRegistry<A extends PrismaQlDSLAction, C extends PrismaQLDSLCommand, T extends PrismaQlDSLType> {\r\n    protected handlers: Record<string, PrismaQlHandler<A, C, T>> = {};\r\n\r\n    constructor(\r\n        initialHandlers?: Record<string, PrismaQlHandler<A, C, T>>,\r\n    ) {\r\n        if (initialHandlers) {\r\n            this.handlers = { ...initialHandlers };\r\n        }\r\n    }\r\n\r\n    register(action: A, command: C, handler: PrismaQlHandler<A, C, T>) {\r\n        this.handlers[action + '_' + command as string] = handler;\r\n    }\r\n\r\n    execute(action: A, command: C, prismaState: PrismaQlSchemaData | null, dsl: PrismaQLParsedDSL<A, C, T>) {\r\n        const handler = this.handlers[action + '_' + command as string];\r\n        if (!handler) {\r\n            throw new Error(`Handler for command \"${command}\" not found.`);\r\n        }\r\n        return handler(prismaState!, dsl);\r\n    }\r\n}","import { Model, Property } from \"@mrleebo/prisma-ast\";\r\nimport { PrismaQLRelation } from \"../field-relation-collector.js\";\r\nimport { FieldSummary } from \"../prehandlers/render-handlers/get-model.js\";\r\n\r\n\r\nexport function extractModelSummary(model: Model, relations: PrismaQLRelation[]): FieldSummary[] {\r\n    const fields = model?.properties?.filter(\r\n        (prop): prop is Property => prop.type === \"field\" &&\r\n\r\n            ((prop?.attributes?.some(attr => attr.name === \"unique\") === true) || (prop?.attributes?.some(attr => attr.name === \"id\") === true))\r\n\r\n    ) || [];\r\n\r\n    return fields.map((field: any) => {\r\n        const isId = field?.attributes?.some((attr: any) => attr.name === \"id\") || false;\r\n        const isUnique = field?.attributes?.some((attr: any) => attr.name === \"unique\") || false;\r\n        let relation;\r\n        let fieldType = field.fieldType;\r\n\r\n        relations.find((rel) => {\r\n            if (rel.modelName === model.name) {\r\n                if (rel.fieldName === field.name || rel.foreignKey === field.name) {\r\n                    relation = rel;\r\n                    fieldType = `${rel.relatedModel}.id`;\r\n                }\r\n            }\r\n        });\r\n        if (isId) {\r\n            const defAttr = field?.attributes?.find((attr: any) => attr.name === \"default\")?.args[0]?.value;\r\n            if (defAttr?.type === \"function\") {\r\n                fieldType = defAttr.name;\r\n            }\r\n        }\r\n        return {\r\n            name: field.name,\r\n            type: fieldType,\r\n            isId,\r\n            isUnique,\r\n            isRelation: !!relation\r\n        };\r\n    });\r\n}\r\n","import { Schema, Model, Field, Enum, Block } from \"@mrleebo/prisma-ast\";\r\nimport { PrismaQlSchemaData } from \"../prisma-schema-loader.js\";\r\nimport { Property } from \"@mrleebo/prisma-ast\";\r\n\r\n/**\r\n * ÐŸÐ°Ñ€ÑÐ¸Ñ‚ Ð¿Ð¾Ð»Ðµ AST Ð¸ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ð¾Ð±ÑŠÐµÐºÑ‚, Ð¿Ñ€Ð¸Ð³Ð¾Ð´Ð½Ñ‹Ð¹ Ð´Ð»Ñ Ð¿ÐµÑ€ÐµÐ´Ð°Ñ‡Ð¸ Ð² fieldBuilder.\r\n * @param {Property} prop - ÐŸÐ¾Ð»Ðµ Ð¸Ð· AST Prisma\r\n * @returns {object | null} - Ð¡Ñ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¸Ð»Ð¸ null (ÐµÑÐ»Ð¸ Ð¿Ð¾Ð»Ðµ Ð½ÐµÐ´Ð¾Ð¿ÑƒÑÑ‚Ð¸Ð¼Ð¾)\r\n */\r\nexport function parseFieldForBuilder(prop: Property) {\r\n    if (prop.type !== \"field\") return null;\r\n\r\n    const { name, fieldType, array, optional, attributes } = prop;\r\n\r\n    if (typeof name !== \"string\" || typeof fieldType !== \"string\") return null;\r\n\r\n    // ÐŸÑ€Ð¾Ð¿ÑƒÑÐºÐ°ÐµÐ¼ relation-Ð¿Ð¾Ð»Ñ (Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¾Ð½Ð¸ Ð½Ðµ Ð»Ð¾Ð¼Ð°Ð»Ð¸ Ð»Ð¾Ð³Ð¸ÐºÑƒ)\r\n    if (attributes?.some(attr => attr.name === \"relation\")) return null;\r\n\r\n    // ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼ Ñ„Ð¸Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ñ‚Ð¸Ð¿ Prisma-Ð¿Ð¾Ð»Ñ\r\n    let prismaFieldType = fieldType;\r\n    if (optional) prismaFieldType += \"?\";\r\n    if (array) prismaFieldType += \"[]\";\r\n\r\n    // ÐžÐ±Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÐµÐ¼ Ð°Ñ‚Ñ€Ð¸Ð±ÑƒÑ‚Ñ‹ (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, @id, @default, @unique)\r\n    const parsedAttributes: { name: string; args: any[] }[] = [];\r\n    for (const attr of attributes || []) {\r\n        let attrArgs = attr.args?.map(arg => arg.value) || [];\r\n        parsedAttributes.push({ name: attr.name, args: attrArgs });\r\n    }\r\n\r\n\r\n    return {\r\n        name,\r\n        fieldType: prismaFieldType,\r\n        attributes: parsedAttributes,\r\n        sourceType: fieldType\r\n    };\r\n}\r\n\r\nexport class PrismaQlSchemaHelper {\r\n    private parsedSchema: Schema;\r\n\r\n    constructor(parsedSchema: Schema) {\r\n        this.parsedSchema = parsedSchema;\r\n    }\r\n    getModels(names?: Array<string>): Model[] {\r\n        const models = this.parsedSchema.list\r\n            .filter((item): item is Model => item.type === \"model\");\r\n        if (names?.length) {\r\n            return models.filter((model) => names.includes(model.name));\r\n        }\r\n        return models;\r\n    }\r\n\r\n    getModelByName(name: string): Model | undefined {\r\n        return this.getModels().find((model) => model.name === name);\r\n    }\r\n\r\n    getFieldByName(modelName: string, fieldName: string): Field | undefined {\r\n        const model = this.getModelByName(modelName);\r\n        if (!model) return undefined;\r\n        return model.properties.find((prop): prop is Field => prop.type === \"field\" && prop.name === fieldName);\r\n    }\r\n    getFields(modelName: string): Field[] {\r\n        const model = this.getModelByName(modelName);\r\n        if (!model) return [];\r\n        return model.properties.filter((prop): prop is Field => prop.type === \"field\");\r\n    }\r\n\r\n    getIdFieldTypeModel(modelName: string): string | undefined {\r\n        const model = this.getModelByName(modelName);\r\n        if (!model) return undefined;\r\n        const idField = model.properties.find((prop): prop is Field => prop.type === \"field\" && (prop as Field)?.attributes?.some(attr => attr.name === \"id\")!);\r\n        return idField?.fieldType as string | undefined;\r\n    }\r\n\r\n    getEnums(): Enum[] {\r\n        return this.parsedSchema.list\r\n            .filter((item): item is Enum => item.type === \"enum\");\r\n    }\r\n\r\n    getEnumByName(name: string): Enum | undefined {\r\n        return this.getEnums().find((enumItem) => enumItem.name === name);\r\n    }\r\n\r\n    getEnumRelations(enumName: string): Array<{\r\n        model: Model,\r\n        field: Field\r\n    }> {\r\n        const models = this.getModels();\r\n        return models.filter((model) => {\r\n            return model.properties.some((prop): prop is Field => {\r\n                return prop.type === \"field\" && prop.fieldType === enumName;\r\n            });\r\n        }).map((model) => {\r\n            const field = model.properties.find((prop): prop is Field => {\r\n                return prop.type === \"field\" && prop.fieldType === enumName;\r\n            });\r\n            return {\r\n                model,\r\n                field: field!\r\n            }\r\n        });\r\n    }\r\n\r\n    getRelations(): Field[] {\r\n        return this.getModels()\r\n            .flatMap((model) => model.properties)\r\n            .filter((prop): prop is Field => prop.type === \"field\" && prop.fieldType === \"relation\");\r\n    }\r\n\r\n    getGenerators(): Block[] {\r\n        return this.parsedSchema.list\r\n            .filter((item): item is Block => item.type === \"generator\");\r\n    }\r\n\r\n    getModelRelations(modelName: string): Field[] {\r\n        const model = this.getModelByName(modelName);\r\n        if (!model) return [];\r\n        return model.properties.filter(\r\n            (prop): prop is Field => prop.type === \"field\" && prop.fieldType === \"relation\"\r\n        );\r\n    }\r\n}\r\n\r\nexport const useHelper = (schema: Schema | PrismaQlSchemaData) => {\r\n    return new PrismaQlSchemaHelper(\"type\" in schema ? schema : schema.ast);\r\n}","import { PrismaQLDSLCommand, PrismaQlDSLQueryAction } from \"../dsl.js\";\r\nimport { PrismaQlHandler, PrismaQlHandlerRegistry } from \"./handler-registry.js\";\r\n\r\nexport class PrismaQlQueryHandlerRegistry extends PrismaQlHandlerRegistry<PrismaQlDSLQueryAction, PrismaQLDSLCommand, 'query'> {\r\n    constructor(\r\n        initialHandlers?: Record<string, PrismaQlHandler<PrismaQlDSLQueryAction, PrismaQLDSLCommand, 'query'>>,\r\n    ) {\r\n        super(initialHandlers);\r\n    }\r\n}","import { PrismaQLDSLCommand, PrismaQlDSLMutationAction } from \"../dsl.js\";\r\nimport { PrismaQlHandler, PrismaQlHandlerRegistry } from \"./handler-registry.js\";\r\n\r\n\r\nexport class PrismaQlMutationHandlerRegistry extends PrismaQlHandlerRegistry<PrismaQlDSLMutationAction, PrismaQLDSLCommand, 'mutation'> {\r\n    constructor(\r\n        initialHandlers?: Record<string, PrismaQlHandler<PrismaQlDSLMutationAction, PrismaQLDSLCommand, 'mutation'>>,\r\n    ) {\r\n        super(initialHandlers);\r\n    }\r\n}","export * from \"./get-enum-relations.js\";\r\nexport * from \"./get-enums.js\";\r\nexport * from \"./get-fields.js\";\r\nexport * from \"./get-model-names.js\";\r\nexport * from \"./get-model.js\";\r\nexport * from \"./get-models.js\";\r\nexport * from \"./get-relations.js\";\r\n","import chalk from \"chalk\";\r\nimport { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport { useHelper } from \"../../utils/schema-helper.js\";\r\nimport boxen from \"boxen\";\r\nimport { formatColumns } from \"./get-model-names.js\";\r\n\r\n\r\nexport const getEnumRelations: PrismaQlHandler<\"GET\", \"ENUM_RELATIONS\", \"query\"> = (prismaState, data) => {\r\n    const response = handlerResponse(data);\r\n    const helper = useHelper(prismaState);\r\n    const { args } = data;\r\n\r\n    const enumName = args?.enums?.[0];\r\n    if (!enumName) {\r\n        return response.error(\"No enum name provided. Example usage: GET ENUM_RELATIONS -> [EnumName];\");\r\n    }\r\n\r\n    const _enum = helper.getEnumByName(enumName);\r\n    if (!_enum) {\r\n        return response.error(`Enum ${enumName} not found`);\r\n    }\r\n    const relations = helper.getEnumRelations(enumName);\r\n\r\n    const total = relations.length;\r\n    if (!total) {\r\n        return response.result(`Enum ${enumName} has no relations`);\r\n    }\r\n    const columns = relations.length > 6 ? 3 : 2;\r\n    const formattedModels = formatColumns(relations.map(rel => `${chalk.hex(\"#11FF00\")(\"â€¢\")} ${chalk.bold(rel.model.name)} -> ${chalk.bold(rel.field.name)}`), columns);\r\n    const stats = `${chalk.white(\"ðŸ“Š Total relations:\")} ${chalk.white.bold(total)}`;\r\n\r\n    return response.result(boxen(`${stats}\\n\\n${formattedModels}`, {\r\n        padding: 1,\r\n        margin: 1,\r\n        borderStyle: \"round\",\r\n        borderColor: \"green\",\r\n    }));\r\n\r\n}","import chalk from \"chalk\";\r\nimport { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport { useHelper } from \"../../utils/schema-helper.js\";\r\nimport boxen from \"boxen\";\r\n\r\n\r\n/**\r\n * Splits an array into columns\r\n */\r\nexport const formatColumns = (items: string[], columns = 2) => {\r\n    const columnWidth = Math.max(...items.map(name => name.length)) + 2; // Dynamic column width\r\n    const rows = Math.ceil(items.length / columns);\r\n    let output = \"\";\r\n\r\n    for (let i = 0; i < rows; i++) {\r\n        let rowItems = [];\r\n        for (let j = 0; j < columns; j++) {\r\n            const index = i + j * rows;\r\n            if (index < items.length) {\r\n                rowItems.push(items[index].padEnd(columnWidth)); // Align text\r\n            }\r\n        }\r\n        output += rowItems.join(\"  \") + \"\\n\"; // Separate columns with spaces\r\n    }\r\n    return output.trim();\r\n};\r\n\r\n/**\r\n * Registers a handler for the `GET_MODEL_NAMES` command with columns\r\n */\r\n\r\nexport const sortModelNames = (modelNames: string[]) => {\r\n    modelNames.sort((a, b) => a.localeCompare(b));\r\n}\r\n\r\nexport const getModelNames: PrismaQlHandler<\"GET\", \"MODELS_LIST\", \"query\"> = (prismaState, data) => {\r\n    const response = handlerResponse(data);\r\n\r\n    const models = useHelper(prismaState).getModels();\r\n    if (models.length === 0) {\r\n        return response.result(chalk.red.bold(\"âŒ No models in Prisma schema.\"));\r\n    }\r\n    const modelNames = models.map(model => model.name);\r\n    sortModelNames(modelNames);\r\n\r\n    // Determine the number of columns (if models > 6, make 3 columns)\r\n    const columns = modelNames.length > 6 ? 3 : 2;\r\n\r\n    // Statistics\r\n    const stats = `${chalk.white(\"ðŸ“Š Total models:\")} ${chalk.white.bold(modelNames.length)}`;\r\n\r\n    // Nicely format the list of models into columns\r\n    const formattedModels = formatColumns(modelNames.map(name => `${chalk.hex(\"#11FF00\")(\"â€¢\")} ${chalk.bold(name)}`), columns);\r\n\r\n    // Final output in a box\r\n    return response.result(boxen(`${stats}\\n\\n${formattedModels}`, {\r\n        padding: 1,\r\n        margin: 1,\r\n        borderStyle: \"round\",\r\n        borderColor: \"cyan\",\r\n        title: \"Prisma Models\",\r\n        titleAlignment: \"center\"\r\n    }));\r\n}\r\n","import { printSchema, Schema, Field, Enumerator } from \"@mrleebo/prisma-ast\";\r\nimport { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport { useHelper } from \"../../utils/schema-helper.js\";\r\nimport boxen from \"boxen\";\r\nimport { PrismaHighlighter } from \"prismalux\";\r\nimport chalk from \"chalk\";\r\n\r\nconst highlightPrismaSchema = new PrismaHighlighter();\r\n\r\nexport const getEnums: PrismaQlHandler<\"GET\", \"ENUMS\", \"query\"> = (prismaState, data) => {\r\n    const response = handlerResponse(data);\r\n    const options = data.options;\r\n    const helper = useHelper(prismaState);\r\n    let enums = helper.getEnums();\r\n    const onlyEnums = data.args?.enums || [];\r\n    if (onlyEnums.length && !onlyEnums.includes(\"*\")) {\r\n        enums = enums.filter(e => onlyEnums.includes(e.name));\r\n    }\r\n    if (!enums.length) {\r\n        return response.result(chalk.yellow(`âš  No enums found`));\r\n    }\r\n    const totalEnums = enums.length;\r\n    const statistic = `ðŸ“Œ Enums in schema: ${chalk.bold(totalEnums)}`;\r\n\r\n    if (options?.raw) {\r\n        const schema: Schema = {\r\n            type: 'schema',\r\n            list: enums\r\n        };\r\n        const parsed = printSchema(schema);\r\n        const rawOutput = highlightPrismaSchema.highlight(parsed);\r\n        return response.result(boxen(`${statistic}\\n${rawOutput}`, {\r\n            padding: 1,\r\n            width: 100,\r\n            borderColor: \"cyan\",\r\n            title: \"Prisma Enums\",\r\n            titleAlignment: \"center\"\r\n        }));\r\n    }\r\n\r\n    const list: {\r\n        name: string,\r\n        options: Array<string>\r\n    }[] = [];\r\n\r\n    enums.forEach(e => {\r\n        list.push({\r\n            name: chalk.white.bold(e.name),\r\n            options: e.enumerators?.filter(e => e.type == \"enumerator\").map((en: Enumerator) => chalk.green(en?.name)) || []\r\n        });\r\n    });\r\n\r\n    const renderedList = list.map(e => {\r\n        return `${e.name}\\n${e.options.join(\", \")}\\n`;\r\n    });\r\n\r\n    return response.result(boxen(`${statistic}\\n${renderedList.join('\\n')}`, {\r\n        padding: 1,\r\n        borderColor: \"cyan\",\r\n        title: \"Prisma Enums\",\r\n        titleAlignment: \"center\"\r\n    }));\r\n}\r\n","import { Field } from \"@mrleebo/prisma-ast\";\r\nimport { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport { useHelper } from \"../../utils/schema-helper.js\";\r\nimport boxen from \"boxen\";\r\nimport chalk from \"chalk\";\r\nimport Table from \"cli-table3\";\r\nexport const getFields: PrismaQlHandler<\"GET\", \"FIELDS\", \"query\"> = (prismaState, data) => {\r\n    const response = handlerResponse(data);\r\n    const { args } = data;\r\n\r\n    const helper = useHelper(prismaState);\r\n\r\n\r\n    const modelName = args?.models?.[0];\r\n    if (!modelName) {\r\n        return response.error(\"âŒ No models specified. Usage: GET FIELDS -> [ModelName]; or GET FIELDS [FieldName], [FieldName2] IN -> [ModelName];\");\r\n    }\r\n\r\n    const model = helper.getModelByName(modelName);\r\n    if (!model) {\r\n        return response.error(`âŒ Model ${modelName} not found`);\r\n    }\r\n\r\n    let fields = helper.getFields(modelName);\r\n\r\n    if (!fields.length) {\r\n        return response.result(chalk.yellow(`âš  No fields found in model ${modelName}`));\r\n    }\r\n\r\n    const onlyFilters = args?.fields || [];\r\n\r\n    if (onlyFilters.length && !onlyFilters.includes(\"*\")) {\r\n        fields = fields.filter(field => onlyFilters.includes(field.name));\r\n    }\r\n\r\n    if (!fields.length) {\r\n        return response.result(chalk.yellow(`âš  No fields found in model ${modelName} that match filters`));\r\n    }\r\n\r\n    const idField = fields.find(f => f.attributes?.some(attr => attr.name === \"id\"))?.name;\r\n\r\n    const table = new Table({\r\n        head: [\r\n            chalk.bold(\"Field Name\"),\r\n            chalk.bold(\"Type\"),\r\n            chalk.bold(\"Required\"),\r\n            chalk.bold(\"Array\"),\r\n            chalk.bold(\"Relation\"),\r\n            chalk.bold(\"Attributes\")\r\n        ],\r\n        colWidths: [20, 15, 10, 10, 25, 25],\r\n        style: { head: [\"cyan\"] }\r\n    });\r\n    const { relations } = prismaState;\r\n\r\n    let relationFields = 0;\r\n    fields.forEach((field: Field) => {\r\n        let name = chalk.greenBright(field.name);\r\n        const type = chalk.blueBright(field.fieldType);\r\n        const required = field.optional ? chalk.redBright(\"No\") : chalk.greenBright(\"Yes\");\r\n        const array = field.array ? chalk.yellowBright(\"Yes\") : chalk.gray(\"No\");\r\n        let hasRelation = field.attributes?.some(attr => attr.name === \"relation\");\r\n        let relation = hasRelation\r\n            ? chalk.magentaBright(\"Yes\")\r\n            : chalk.gray(\"No\");\r\n\r\n        const attrs = ['unique', 'id', 'default'];\r\n        const attributes = field.attributes?.filter(\r\n            attr => attrs.includes(attr.name)\r\n        ).map(attr => {\r\n            if (attrs.includes(attr.name) && Array.isArray((attr as any).args)) {\r\n                const arg = (attr as any).args[0] as any;\r\n                if (\"string\" == typeof arg.value) {\r\n                    return `@${attr.name}(${arg.value})`;\r\n                }\r\n                if (\"object\" == typeof arg.value) {\r\n                    return `@${attr.name}(${arg.value.name}())`\r\n                }\r\n            }\r\n            return `@${attr.name}`;\r\n        }).join(\", \") || chalk.gray(\"None\");\r\n\r\n\r\n        for (const rel of relations) {\r\n            if (rel.modelName === model.name) {\r\n                if (rel.fieldName === field.name) {\r\n                    relation = chalk.magentaBright(rel.relationName);\r\n                    hasRelation = true;\r\n                }\r\n                if (rel.foreignKey === field.name) {\r\n                    relation = chalk.magenta(`${rel.relationName} (FK)`);\r\n                }\r\n            }\r\n        }\r\n        if (hasRelation) {\r\n            relationFields++;\r\n        }\r\n\r\n        if (field.name == idField) {\r\n            name = `${chalk.bgGreenBright.black(field.name)} (ID)`;\r\n        }\r\n        table.push([name, type, required, array, relation, attributes]);\r\n    });\r\n\r\n    const totalFoundFields = fields.length;\r\n\r\n\r\n    const statistic = `\r\n    ðŸ“ŒFields in model: ${chalk.bold(modelName)}\r\n    Total fields found: ${chalk.bold(totalFoundFields)}\r\n    Fields with relations: ${chalk.bold(relationFields)}\r\n    `\r\n\r\n    return response.result(boxen(`${statistic}\\n${table.toString()}`, {\r\n        padding: 1,\r\n        borderColor: \"cyan\",\r\n        title: \"Prisma Model Fields\",\r\n        titleAlignment: \"center\"\r\n    }));\r\n};\r\n","import chalk from \"chalk\";\r\nimport { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\"\r\nimport { printSchema, Schema } from \"@mrleebo/prisma-ast\";\r\nimport { useHelper } from \"../../utils/schema-helper.js\";\r\nimport { getRelationStatistics } from \"../../field-relation-logger.js\";\r\nimport { PrismaHighlighter } from \"prismalux\";\r\nimport { extractModelSummary } from \"../../utils/model-primary-fields.js\";\r\nimport boxen from \"boxen\";\r\nconst highlightPrismaSchema = new PrismaHighlighter();\r\n\r\nexport type FieldSummary = {\r\n    name: string;\r\n    type: string;\r\n    isId: boolean;\r\n    isUnique: boolean;\r\n    isRelation: boolean;\r\n};\r\n\r\n\r\nexport const getModel: PrismaQlHandler<\"GET\", \"MODEL\", \"query\"> = (prismaState, data) => {\r\n    const { args } = data;\r\n    const response = handlerResponse(data);\r\n\r\n    const modelName = args?.models?.[0];\r\n    if (!modelName) {\r\n        return response.error(\"No model specified. Example usage: GET MODEL ->[ModelName];\");\r\n    }\r\n\r\n\r\n    const model = useHelper(prismaState).getModelByName(modelName);\r\n    if (!model) {\r\n        return response.error(`Model ${modelName} not found`)\r\n    }\r\n\r\n    const fields: FieldSummary[] = extractModelSummary(model, prismaState.relations);\r\n    const { totalRelations } = getRelationStatistics(prismaState.relations, model.name);\r\n\r\n    const schema: Schema = {\r\n        type: \"schema\",\r\n        list: [model],\r\n    };\r\n    const hSchema = highlightPrismaSchema.highlight(printSchema(schema));\r\n\r\n    // Model Title\r\n    let output = `${chalk.bold.whiteBright(\"Model:\")} ${chalk.greenBright(model.name)}\\n`;\r\n    output += `${chalk.whiteBright(\"Relations:\")} ${totalRelations > 0\r\n        ? `${chalk.greenBright(totalRelations)} relations`\r\n        : chalk.redBright(\"No relations\")\r\n        }\\n\\n`;\r\n\r\n    // Fields Table\r\n    const maxFieldLength = Math.max(...fields.map((f) => f.name.length), 5);\r\n    const maxTypeLength = Math.max(...fields.map((f) => f.type.length), 4);\r\n\r\n    output += chalk.underline(\"Unique Fields:\\n\");\r\n    output += fields\r\n        .map((field) => {\r\n            const fieldName = field.isId\r\n                ? chalk.bold.red(field.name)\r\n                : field.isUnique\r\n                    ? chalk.bold.yellow(field.name)\r\n                    : chalk.white(field.name);\r\n\r\n            const fieldType = field.isRelation ? chalk.cyan(field.type) : chalk.blueBright(field.type);\r\n\r\n            return `${fieldName.padEnd(maxFieldLength + 2)} ${fieldType.padEnd(\r\n                maxTypeLength + 2\r\n            )}`;\r\n        })\r\n        .join(\"\\n\");\r\n\r\n    output += \"\\n\\n\";\r\n\r\n    // Prisma Schema Source\r\n    output += chalk.underline(\"Schema:\") + hSchema;\r\n\r\n    // Boxen output\r\n    return response.result(boxen(output, {\r\n        padding: 1,\r\n        borderColor: \"cyan\",\r\n        borderStyle: \"round\",\r\n    }));\r\n}","import { printSchema, Schema } from \"@mrleebo/prisma-ast\";\r\nimport { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\"\r\nimport { useHelper } from \"../../utils/schema-helper.js\";\r\nimport boxen from \"boxen\";\r\nimport { PrismaHighlighter } from \"prismalux\";\r\nimport chalk from \"chalk\";\r\nconst highlightPrismaSchema = new PrismaHighlighter();\r\nexport const getModels: PrismaQlHandler<\"GET\", \"MODELS\", 'query'> = (prismaState, data) => {\r\n    const response = handlerResponse(data);\r\n    const { args } = data;\r\n    const models = useHelper(prismaState).getModels(args?.models);\r\n\r\n    const schema: Schema = {\r\n        type: \"schema\",\r\n        list: models,\r\n    }\r\n\r\n    const modelCount = models.length;\r\n    const title =\r\n        modelCount > 0\r\n            ? `ðŸ“Š Query Result: ${chalk.bold(modelCount)} model${modelCount > 1 ? \"s\" : \"\"} found:`\r\n            : `âŒ No models found`;\r\n\r\n    const highlightedSchema = highlightPrismaSchema.highlight(printSchema(schema));\r\n\r\n    const output = models?.length ? `\r\n${title}\r\n\r\n${highlightedSchema} \r\n        ` : title;\r\n\r\n    const statsBox = boxen(output, {\r\n        padding: 1,\r\n        borderColor: modelCount > 0 ? \"green\" : \"red\",\r\n        borderStyle: \"round\",\r\n        align: \"left\"\r\n    });\r\n\r\n    return response.result(statsBox)\r\n}","import { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport { PrismaQlFieldRelationLogger } from \"../../field-relation-logger.js\";\r\nimport { useHelper } from \"../../utils/schema-helper.js\";\r\n\r\n\r\nexport const getRelations: PrismaQlHandler<\"GET\", \"RELATIONS\", 'query'> = (prismaState, data) => {\r\n    const response = handlerResponse(data);\r\n    const helper = useHelper(prismaState);\r\n    const { options, args } = data;\r\n\r\n    const modelnames = args?.models || [];\r\n    if (!modelnames.length) {\r\n        return response.error(\"You must provide at least one model name. Example: GET RELATIONS [ModelNameA], [ModelNameB]\");\r\n    }\r\n    const models = helper.getModels();\r\n    const selectedModels = models.filter(m => modelnames.includes(m.name));\r\n    if (!selectedModels.length) {\r\n        return response.result(\"No models found\");\r\n    }\r\n    const results = [];\r\n    const logger = new PrismaQlFieldRelationLogger(prismaState.relations);\r\n    for (const model of selectedModels) {\r\n        const log = logger.generateRelationTreeLog(model.name, options?.depth || 1);\r\n        results.push(log);\r\n    }\r\n\r\n\r\n    return response.result(results.join(\"\\n\"));\r\n}","export * from \"./get-enum-relations.js\";\r\nexport * from \"./get-enums.js\";\r\nexport * from \"./get-fields.js\";\r\nexport * from \"./get-model-names.js\";\r\nexport * from \"./get-model.js\";\r\nexport * from \"./get-models.js\";\r\nexport * from \"./get-relations.js\";\r\n","import { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport { useHelper } from \"../../utils/schema-helper.js\";\r\n\r\n\r\nexport const getJsonEnumRelations: PrismaQlHandler<\"GET\", \"ENUM_RELATIONS\", \"query\"> = (prismaState, data) => {\r\n    const response = handlerResponse(data);\r\n    const helper = useHelper(prismaState);\r\n    const { args } = data;\r\n\r\n    const enumName = args?.enums?.[0];\r\n    if (!enumName) {\r\n        return response.error(\"No enum name provided. Example usage: GET ENUM_RELATIONS -> [EnumName];\");\r\n    }\r\n\r\n    const _enum = helper.getEnumByName(enumName);\r\n    if (!_enum) {\r\n        return response.error(`Enum ${enumName} not found`);\r\n    }\r\n    const relations = helper.getEnumRelations(enumName);\r\n\r\n    const total = relations.length;\r\n    if (!total) {\r\n        return response.result({\r\n            total: 0,\r\n            relations: [],\r\n        });\r\n    }\r\n    return response.result({\r\n        total,\r\n        relations,\r\n    });\r\n}","import { Enumerator } from \"@mrleebo/prisma-ast\";\r\nimport { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport { useHelper } from \"../../utils/schema-helper.js\";\r\n\r\nexport const getJsonEnums: PrismaQlHandler<\"GET\", \"ENUMS\", \"query\"> = (prismaState, data) => {\r\n    const response = handlerResponse(data);\r\n    const helper = useHelper(prismaState);\r\n    let enums = helper.getEnums();\r\n    const onlyEnums = data.args?.enums || [];\r\n    if (onlyEnums.length && !onlyEnums.includes(\"*\")) {\r\n        enums = enums.filter(e => onlyEnums.includes(e.name));\r\n    }\r\n    if (!enums.length) {\r\n        return response.result({\r\n            total: 0,\r\n            enums: [],\r\n        });\r\n    }\r\n    const totalEnums = enums.length;\r\n\r\n\r\n    const list: {\r\n        name: string,\r\n        options: Array<string>\r\n    }[] = [];\r\n\r\n    enums.forEach(e => {\r\n        list.push({\r\n            name: e.name,\r\n            options: e.enumerators?.filter(e => e.type == \"enumerator\").map((en: Enumerator) => en.name) || []\r\n        });\r\n    });\r\n\r\n    return response.result({\r\n        total: totalEnums,\r\n        enums: list,\r\n    });\r\n}\r\n","import { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport { useHelper } from \"../../utils/schema-helper.js\";\r\nexport const getJsonFields: PrismaQlHandler<\"GET\", \"FIELDS\", \"query\"> = (prismaState, data) => {\r\n    const response = handlerResponse(data);\r\n    const { args } = data;\r\n\r\n    const helper = useHelper(prismaState);\r\n\r\n\r\n    const modelName = args?.models?.[0];\r\n    if (!modelName) {\r\n        return response.error(\"âŒ No models specified. Usage: GET FIELDS -> [ModelName]; or GET FIELDS [FieldName], [FieldName2] IN -> [ModelName];\");\r\n    }\r\n\r\n    const model = helper.getModelByName(modelName);\r\n    if (!model) {\r\n        return response.error(`âŒ Model ${modelName} not found`);\r\n    }\r\n\r\n    let fields = helper.getFields(modelName);\r\n    if (!fields.length) {\r\n        return response.result({\r\n            fields: [],\r\n            total: 0,\r\n        });\r\n    }\r\n\r\n    const onlyFilters = args?.fields || [];\r\n\r\n    if (onlyFilters.length && !onlyFilters.includes(\"*\")) {\r\n        fields = fields.filter(field => onlyFilters.includes(field.name));\r\n    }\r\n\r\n    if (!fields.length) {\r\n        return response.result({\r\n            fields: [],\r\n            total: 0,\r\n        });\r\n    }\r\n    const relationFields = fields.filter(field => field.attributes?.some(attr => attr.name === \"relation\")).length;\r\n    return response.result({\r\n        fields: fields,\r\n        total: relationFields\r\n    });\r\n};\r\n","import { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport { useHelper } from \"../../utils/schema-helper.js\";\r\n\r\n\r\nexport const sortModelNames = (modelNames: string[]) => {\r\n    modelNames.sort((a, b) => a.localeCompare(b));\r\n}\r\n\r\nexport const getJsonModelNames: PrismaQlHandler<\"GET\", \"MODELS_LIST\", \"query\"> = (prismaState, data) => {\r\n    const response = handlerResponse(data);\r\n\r\n    const models = useHelper(prismaState).getModels();\r\n    if (models.length === 0) {\r\n        return response.result({\r\n            total: 0,\r\n            models: [],\r\n        });\r\n    }\r\n    const modelNames = models.map(model => model.name);\r\n    sortModelNames(modelNames);\r\n    \r\n    // Final output in a box\r\n    return response.result({\r\n        total: modelNames.length,\r\n        models: modelNames,\r\n    });\r\n}\r\n","import { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\"\r\nimport { printSchema, Schema } from \"@mrleebo/prisma-ast\";\r\nimport { useHelper } from \"../../utils/schema-helper.js\";\r\nimport { getRelationStatistics } from \"../../field-relation-logger.js\";\r\nimport { extractModelSummary } from \"../../utils/model-primary-fields.js\";\r\n\r\nexport type FieldSummary = {\r\n    name: string;\r\n    type: string;\r\n    isId: boolean;\r\n    isUnique: boolean;\r\n    isRelation: boolean;\r\n};\r\n\r\nexport const getJsonModel: PrismaQlHandler<\"GET\", \"MODEL\", \"query\"> = (prismaState, data) => {\r\n    const { args } = data;\r\n    const response = handlerResponse(data);\r\n\r\n    const modelName = args?.models?.[0];\r\n    if (!modelName) {\r\n        return response.error(\"No model specified. Example usage: GET MODEL ->[ModelName];\");\r\n    }\r\n\r\n    const model = useHelper(prismaState).getModelByName(modelName);\r\n    if (!model) {\r\n        return response.error(`Model ${modelName} not found`)\r\n    }\r\n\r\n    const fields: FieldSummary[] = extractModelSummary(model, prismaState.relations);\r\n    const { totalRelations } = getRelationStatistics(prismaState.relations, model.name);\r\n\r\n    const schema: Schema = {\r\n        type: \"schema\",\r\n        list: [model],\r\n    };\r\n\r\n    return response.result({\r\n        model: model,\r\n        schema: printSchema(schema),\r\n        requiredFields: fields,\r\n        totalRelations: totalRelations\r\n    });\r\n}","import { printSchema, Schema } from \"@mrleebo/prisma-ast\";\r\nimport { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\"\r\nimport { useHelper } from \"../../utils/schema-helper.js\";\r\nexport const getJsonModels: PrismaQlHandler<\"GET\", \"MODELS\", 'query'> = (prismaState, data) => {\r\n    const response = handlerResponse(data);\r\n    const { args } = data;\r\n    const models = useHelper(prismaState).getModels(args?.models);\r\n\r\n    const schema: Schema = {\r\n        type: \"schema\",\r\n        list: models,\r\n    }\r\n\r\n    const modelCount = models.length;\r\n    return response.result({\r\n        total: modelCount,\r\n        models: models,\r\n        schema: printSchema(schema),\r\n    })\r\n}","import { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport { PrismaQlFieldRelationLogger, PrismaQlJsonRelationTree } from \"../../field-relation-logger.js\";\r\nimport { useHelper } from \"../../utils/schema-helper.js\";\r\n\r\n\r\nexport const getJsonRelations: PrismaQlHandler<\"GET\", \"RELATIONS\", 'query'> = (prismaState, data) => {\r\n    const response = handlerResponse(data);\r\n    const helper = useHelper(prismaState);\r\n    const { options, args } = data;\r\n\r\n    const modelnames = args?.models || [];\r\n    if (!modelnames.length) {\r\n        return response.error(\"You must provide at least one model name. Example: GET RELATIONS [ModelNameA], [ModelNameB]\");\r\n    }\r\n    const models = helper.getModels();\r\n    const selectedModels = models.filter(m => modelnames.includes(m.name));\r\n    if (!selectedModels.length) {\r\n        return response.result({\r\n            total: 0,\r\n            results: []\r\n        });\r\n    }\r\n    const results: Array<PrismaQlJsonRelationTree> = [];\r\n    const logger = new PrismaQlFieldRelationLogger(prismaState.relations);\r\n    for (const model of selectedModels) {\r\n        const log = logger.buildJsonModelTrees(model.name, prismaState.relations, options?.depth || 1);\r\n        results.push(log);\r\n    }\r\n    return response.result({\r\n        results,\r\n        total: results.length\r\n    });\r\n}","export * from \"./add-enum.js\";\r\nexport * from \"./add-field.js\";\r\nexport * from \"./add-model.js\";\r\nexport * from \"./add-relation.js\";\r\nexport * from \"./delete-enum.js\";\r\nexport * from \"./delete-field.js\";\r\nexport * from \"./delete-model.js\";\r\nexport * from \"./delete-relations.js\";\r\nexport * from \"./update-enum.js\";\r\nexport * from \"./update-field.js\";\r\n","import { constantCase } from \"change-case\";\r\nimport { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\n\r\nexport const addEnum: PrismaQlHandler<\"ADD\", \"ENUM\", \"mutation\"> = (prismaState, data) => {\r\n    const { args } = data;\r\n    const response = handlerResponse(data);\r\n\r\n    const enumName = (args?.enums || [])[0];\r\n    if (!enumName.length) {\r\n        return response.error(\"No enum name provided. Example: 'ADD ENUM ->[EnumName] ({A|B|C});'\");\r\n    }\r\n    if (!data.prismaBlock) {\r\n        return response.error(\"No enum block provided. Example: 'ADD ENUM EnumName ->[({A|B|C})];'\");\r\n    }\r\n    let keys: string[] = [];\r\n    if (data.prismaBlock) {\r\n        keys = data.prismaBlock.split(/\\s+/).map((key) => constantCase(key));\r\n    }\r\n    if (!keys.length) {\r\n        return response.error(\"No enum options provided. Example: 'ADD ENUM EnumName ({ ->[A|B|C] });'\");\r\n    }\r\n    try {\r\n        const builder = prismaState.builder;\r\n\r\n        const prevEnum = builder.findByType(\"enum\", { name: enumName });\r\n        if (prevEnum) {\r\n            return response.error(`Enum ${enumName} already exists`);\r\n        }\r\n\r\n        builder.enum(enumName, keys);\r\n\r\n        return response.result(`Enum ${enumName} added successfully!`);\r\n    } catch (error) {\r\n        return response.error(`Error adding enum: ${error.message}`);\r\n    }\r\n};","import { Field, getSchema, Model, Property } from \"@mrleebo/prisma-ast\";\r\nimport { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport { parseFieldForBuilder } from \"../../utils/schema-helper.js\";\r\n\r\nexport const addField: PrismaQlHandler<\"ADD\", \"FIELD\", \"mutation\"> = (prismaState, data) => {\r\n    const response = handlerResponse(data);\r\n    const { args } = data;\r\n\r\n    if (!args?.fields || !args.fields.length) {\r\n        return response.error(\"No fields provided. Example: 'ADD FIELD -> [FieldName] TO [ModelName] ({String @default('123')})'\");\r\n    }\r\n    if (!args?.models || !args.models.length) {\r\n        return response.error(\"No model name provided. Example: 'ADD FIELD [FieldName] TO -> [ModelName] ({String @default('123')})'\");\r\n    }\r\n    const modelName = args.models[0];\r\n\r\n    const model = prismaState.builder.findByType(\"model\", { name: modelName });\r\n    if (!model) {\r\n        return response.error(`Model ${modelName} not found. Please ensure the model name is correct.`);\r\n    }\r\n\r\n    const fieldName = args.fields[0];\r\n    if (!data.prismaBlock) {\r\n        return response.error(\"No field type provided. Example: 'ADD FIELD [FieldName] TO [ModelName] -> ({String @default('123')})'\");\r\n    }\r\n\r\n    const prevField = model.properties.find((prop) => prop.type === \"field\" && prop.name === fieldName);\r\n    if (prevField) {\r\n        return response.error(`Field ${fieldName} already exists in model ${modelName}`);\r\n    }\r\n    const sourceField = `model Test {\r\n        ${fieldName}  ${data.prismaBlock}\r\n    }`;\r\n\r\n    let parsed: ReturnType<typeof getSchema>;\r\n    try {\r\n        parsed = getSchema(sourceField);\r\n    } catch (error) {\r\n        return response.error(`Error parsing field: ${error.message}`);\r\n    }\r\n\r\n    if (!parsed.list.length) {\r\n        return response.error(\"No models found in the schema. Ensure the field block is correct and includes Prisma field attributes, including the type, but without the field name. Example: 'ADD FIELD [FieldName] TO [ModelName] -> ({String @default('123')})'\");\r\n    }\r\n\r\n    const testModel = parsed.list[0] as Model;\r\n    const field = testModel.properties.find((prop) => prop.type === \"field\" && prop.name === fieldName) as Field;\r\n    if (!field) {\r\n        return response.error(\"Invalid field. Please refer to the documentation and ensure the field block is correct. Example: 'ADD FIELD [FieldName] TO [ModelName] -> ({String?});'\");\r\n    }\r\n    const fieldData = parseFieldForBuilder(field as Property);\r\n    if (!fieldData) {\r\n        return response.error(\"Invalid field. Please refer to the documentation and ensure the field block is correct. Example: 'ADD FIELD [FieldName] TO [ModelName] -> ({String?});'\");\r\n    }\r\n    const modelBuilder = prismaState.builder.model(model.name);\r\n    if (fieldData) {\r\n        const fieldBuilder = modelBuilder.field(fieldData.name, fieldData.fieldType);\r\n\r\n        for (const attr of fieldData.attributes) {\r\n            fieldBuilder.attribute(attr.name, attr.args);\r\n        }\r\n    }\r\n\r\n    return response.result(`Field ${fieldName} added to model ${modelName}`);\r\n}","import { getSchema, Property } from \"@mrleebo/prisma-ast\";\r\nimport { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport { parseFieldForBuilder, useHelper } from \"../../utils/schema-helper.js\";\r\n\r\nexport const addModel: PrismaQlHandler<\"ADD\", \"MODEL\", \"mutation\"> = (prismaState, data) => {\r\n    const { args, prismaBlock, options } = data;\r\n    const response = handlerResponse(data);\r\n\r\n    const modelName = (args?.models || [])[0];\r\n    if (!modelName) {\r\n        return response.error(\"Model name is required. Example: ADD MODEL -> [ModelName] ({id String @id})\");\r\n    }\r\n    try {\r\n        const builder = prismaState.builder;\r\n\r\n        const prevModel = builder.findByType(\"model\", { name: modelName });\r\n        if (prevModel) {\r\n            return response.error(`Model ${modelName} already exists`);\r\n        }\r\n\r\n        if (!prismaBlock) {\r\n            return response.error(\"No fields provided. Please provide a valid block in ({...}) containing a valid Prisma field description.\");\r\n        }\r\n        let parsed: ReturnType<typeof getSchema>;\r\n\r\n        const defaultFields = options?.empty ? \"\" : \"createdAt DateTime @default(now())\\nupdatedAt DateTime @updatedAt()\\n deletedAt DateTime?\";\r\n        const sourceModel = `model ${modelName} {\r\n        ${defaultFields}\r\n        ${prismaBlock || \"id Int @id\"}\r\n        }`;\r\n\r\n        try {\r\n            parsed = getSchema(sourceModel);\r\n        } catch (error) {\r\n            return response.error(`Invalid block provided. Error parsing model: ${error.message}`);\r\n        }\r\n        const model = useHelper(parsed).getModelByName(modelName);\r\n\r\n        if (!model) {\r\n            return response.error(`Model ${modelName} already exists`);\r\n        }\r\n\r\n        const modelBuilder = builder.model(modelName);\r\n        const idField = model.properties.find((prop: Property) => prop.type === \"field\" && prop?.attributes?.some(attr => attr.name === \"id\"));\r\n        if (!idField) {\r\n            modelBuilder.field(\"id\", \"Int\").attribute(\"id\");\r\n        }\r\n\r\n        const addedFieldNames = new Set<string>();\r\n        for (const prop of model.properties) {\r\n            if (prop.type !== \"field\") {\r\n                continue;\r\n            }\r\n            const field = prop as Property;\r\n\r\n            const fieldData = parseFieldForBuilder(prop as Property);\r\n            if (!fieldData) {\r\n                continue;\r\n            }\r\n            if (fieldData) {\r\n                let fieldBuilder = modelBuilder.field(field.name, fieldData.fieldType);\r\n                addedFieldNames.add(field.name);\r\n                for (const attr of fieldData.attributes) {\r\n                    fieldBuilder = fieldBuilder.attribute(attr.name, attr.args);\r\n                }\r\n            }\r\n        }\r\n        const filterFieldsFor = ['unique', 'index', 'id'] as Array<string>;\r\n        const filterFields = (fields: Array<string>, prop: string) => {\r\n            if (!filterFieldsFor.includes(prop)) {\r\n                return fields;\r\n            }\r\n            return fields.filter((field) => {\r\n                return addedFieldNames.has(field);\r\n            });\r\n        }\r\n        function fixUniqueKeyValues(keyValues: Record<string, any>, prop: string): any {\r\n            if (!keyValues) return null;\r\n            if (!keyValues.fields) return keyValues;\r\n            const fields = filterFields(keyValues.fields?.args || [], prop);\r\n            if (fields.length) {\r\n                return {\r\n                    ...keyValues,\r\n                    fields: { type: \"array\", args: fields }\r\n                };\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        const blockAttributesMap = new Map<string, { args?: string[], keyValues?: Record<string, string> }>();\r\n\r\n        for (const prop of model.properties) {\r\n            if (prop.type === \"attribute\" && prop.args) {\r\n                let arrayArgs: string[] = [];\r\n                let keyValueArgs: Record<string, string> = {};\r\n                for (const arg of prop.args) {\r\n                    const { value, type } = arg as any;\r\n                    if (type == \"attributeArgument\") {\r\n                        if (\"string\" == typeof value) {\r\n                            modelBuilder.blockAttribute(prop.name, value);\r\n                        } else if (\"object\" == typeof value) {\r\n                            const val = value as any;\r\n                            if (val.type === \"array\") {\r\n                                const result = filterFields(val.args, prop.name);\r\n                                if (result.length) {\r\n                                    modelBuilder.blockAttribute(prop.name, result);\r\n                                }\r\n                            } else if (val.type === \"keyValue\") {\r\n                                keyValueArgs[val.key] = val.value;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n                if (arrayArgs.length || Object.keys(keyValueArgs).length) {\r\n                    if (blockAttributesMap.has(prop.name)) {\r\n                        const existing = blockAttributesMap.get(prop.name)!;\r\n                        existing.args = [...new Set([...(existing.args || []), ...arrayArgs])];\r\n                        existing.keyValues = { ...existing.keyValues, ...keyValueArgs };\r\n                    } else {\r\n                        blockAttributesMap.set(prop.name, { args: arrayArgs, keyValues: keyValueArgs });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (const [name, { keyValues, args }] of blockAttributesMap.entries()) {\r\n            if (keyValues && args?.length && Object.keys(keyValues).length) {\r\n                const fields = filterFields(args, name);\r\n                if (fields.length) {\r\n                    modelBuilder.blockAttribute(name, {\r\n                        ...keyValues,\r\n                        fields: { type: \"array\", args }\r\n                    });\r\n                } else {\r\n                    modelBuilder.blockAttribute(name, keyValues);\r\n                }\r\n            } else if (args?.length) {\r\n                modelBuilder.blockAttribute(name, args);\r\n            } else if (keyValues && Object.keys(keyValues).length) {\r\n                const output = fixUniqueKeyValues(keyValues, name);\r\n                if (output) {\r\n                    modelBuilder.blockAttribute(name, output);\r\n                }\r\n            }\r\n        }\r\n        return response.result(`Model ${modelName} added successfully`);\r\n    } catch (error) {\r\n        return response.error(`Error adding model: ${error.message}`);\r\n    }\r\n}","import { getManyToManyModelName, getManyToManyTableName } from \"../../field-relation-collector.js\";\r\nimport { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport pluralize from \"pluralize\";\r\nimport { camelCase, pascalCase } from \"change-case\";\r\nimport { useHelper } from \"../../utils/schema-helper.js\";\r\n\r\nexport const addRelation: PrismaQlHandler<\"ADD\", \"RELATION\", \"mutation\"> = (prismaState, data) => {\r\n    const { args, options } = data;\r\n    const response = handlerResponse(data);\r\n    const type = options?.type;\r\n\r\n    const models = args?.models;\r\n    if (!models || models.length !== 2) {\r\n        return response.error(\"Two models are required for relation. Example: ADD RELATION ->[ModelA] AND ->[ModelB] (type=1:1)\");\r\n    }\r\n\r\n    if (!type) {\r\n        return response.error(\"Relation type is required. Valid types are: '1:1', '1:M', 'M:N'. Example: ADD RELATION ModelA AND ModelB (type=1:1)\");\r\n    }\r\n\r\n    const [modelA, modelB] = models;\r\n    const { builder } = prismaState;\r\n    const modelARef = builder.findByType(\"model\", { name: modelA });\r\n    const modelBRef = builder.findByType(\"model\", { name: modelB });\r\n    if (!modelARef) {\r\n        return response.error(`Model ${modelA} not found, please add it first`);\r\n    }\r\n    if (!modelBRef) {\r\n        return response.error(`Model ${modelB} not found, please add it first`);\r\n    }\r\n    const optional = options?.required === false || options?.required === undefined;\r\n    const pivotTable = (options?.pivotTable && options?.pivotTable === true) ? getManyToManyModelName(modelA, modelB) : (options?.pivotTable || null) as string | null;\r\n    const sourceRelationName = options?.relationName || getManyToManyTableName(modelA, modelB);\r\n    const relationName = `\"${sourceRelationName}\"`;\r\n    const pivotModelName = pivotTable ? pascalCase(pivotTable) : null;\r\n    const isSelfRelation = modelA === modelB;\r\n    const fk = (modelName: string,): string => {\r\n        return camelCase(`${modelName}Id`);\r\n    }\r\n    const selfPrefix = (modelName: string, asFk = false): string => {\r\n        return isSelfRelation ? camelCase(((modelName + 'By') + (asFk ? \"Id\" : \"\"))) : camelCase(modelName + (asFk ? \"Id\" : \"\"));\r\n    }\r\n\r\n    if (options?.fkHolder && options?.fkHolder !== modelA && options?.fkHolder !== modelB) {\r\n        return response.error(`Model ${options.fkHolder} not found, please add it first`);\r\n    }\r\n    const makeOptional = (str: string) => {\r\n        return str + \"?\";\r\n    }\r\n    const isOptional = (str: string) => {\r\n        return str + (optional ? \"?\" : \"\");\r\n    }\r\n\r\n    const helper = useHelper(prismaState);\r\n    // ÐÑƒÐ¶Ð½Ð¾ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ‚Ð¸Ð¿ Ð¿Ð¾Ð»Ñ Ð˜Ð” ÐºÐ°Ð¶Ð´Ð¾Ð¹ Ð¼Ð¾Ð´ÐµÐ»Ð¸\r\n\r\n    if (type == '1:1') {\r\n        if (!pivotTable) {\r\n            const aModelName = options?.fkHolder || modelBRef.name;\r\n            const bModelName = aModelName === modelA ? modelB : modelA;\r\n            const idFieldModelB = (helper.getIdFieldTypeModel(bModelName) || 'String') as string;\r\n\r\n            const fkKey = fk(bModelName);\r\n            const refModelKey = selfPrefix(bModelName);\r\n            builder.model(aModelName)\r\n                .field(fkKey, isOptional(idFieldModelB)).attribute(\"unique\")\r\n                .field(refModelKey, isOptional(bModelName))\r\n                .attribute(\"relation\", [relationName, `fields: [${fkKey}]`, `references: [id]`]);\r\n\r\n            builder.model(bModelName)\r\n                .field(camelCase(aModelName), makeOptional(aModelName))\r\n                .attribute(\"relation\", [relationName]);\r\n\r\n            return response.result(`One-to-One relation added between ${modelA} and ${modelB}`);\r\n        } else {\r\n            const fkA = selfPrefix(modelA, true);\r\n            const fkB = fk(modelB);\r\n            const pivotOnly = options?.pivotOnly;\r\n\r\n            const idFieldModelA = (helper.getIdFieldTypeModel(modelA) || 'String') as string;\r\n            const idFieldModelB = (helper.getIdFieldTypeModel(modelB) || 'String') as string;\r\n            if (!pivotOnly) {\r\n                builder.model(pivotModelName!)\r\n                    .field(\"createdAt\", \"DateTime\").attribute(\"default\", [\"now()\"])\r\n                    .field(fkA, idFieldModelA).attribute(\"unique\")\r\n                    .field(fkB, idFieldModelB).attribute(\"unique\")\r\n                    .blockAttribute(\"id\", [fkA, fkB])\r\n                    .field(modelA.toLowerCase(), modelA).attribute(\"relation\", [\r\n                        relationName,\r\n                        `fields: [${fkA}]`,\r\n                        `references: [id]`\r\n                    ]);\r\n\r\n                builder.model(modelA)\r\n                    .field(camelCase(modelB), `${pivotModelName}?`)\r\n                    .attribute(\"relation\", [relationName]);\r\n            } else {\r\n                builder.model(pivotModelName!)\r\n                    .field(fkA, idFieldModelA).attribute(\"unique\")\r\n                    .field(fkB, idFieldModelB).attribute(\"unique\")\r\n                    .field(\"createdAt\", \"DateTime\").attribute(\"default\", [\"now()\"])\r\n                    .blockAttribute(\"id\", [fkA, fkB]);\r\n\r\n            }\r\n\r\n            return response.result(`One-to-One relation (with pivot table) added between ${modelA} and ${modelB}`);\r\n\r\n        }\r\n    } else if (type == \"1:M\") {\r\n        if (!pivotTable) {\r\n            const aModelName = options?.fkHolder || modelA;\r\n            const bModelName = aModelName === modelA ? modelB : modelA;\r\n\r\n            const idFieldModelB = (helper.getIdFieldTypeModel(bModelName) || 'String') as string;\r\n            const fkKey = fk(bModelName);\r\n            const refModelKey = selfPrefix(bModelName);\r\n            builder.model(aModelName)\r\n                .field(fkKey, isOptional(idFieldModelB)) //.attribute(\"unique\")\r\n\r\n                .field(refModelKey, isOptional(bModelName))\r\n                .attribute(\"relation\", [relationName, `fields: [${fkKey}]`, `references: [id]`]);\r\n\r\n            builder.model(bModelName)\r\n                .field(pluralize.plural(camelCase(aModelName)), aModelName + \"[]\")\r\n                .attribute(\"relation\", [relationName]);\r\n\r\n            return response.result(`One-to-Many relation added between ${modelA} and ${modelB}`);\r\n        } else {\r\n            const fkA = selfPrefix(modelA, true);\r\n            const fkB = selfPrefix(modelB, true);\r\n\r\n            const idFieldModelA = (helper.getIdFieldTypeModel(modelA) || 'String') as string;\r\n            const idFieldModelB = (helper.getIdFieldTypeModel(modelB) || 'String') as string;\r\n            builder.model(pivotModelName!)\r\n                .field(\"createdAt\", \"DateTime\").attribute(\"default\", [\"now()\"])\r\n                .field(fkA, idFieldModelA).attribute(\"unique\")\r\n                .field(fkB, idFieldModelB).attribute(\"unique\")\r\n                .blockAttribute(\"id\", [fkA, fkB])\r\n                .field(modelA.toLowerCase(), modelA).attribute(\"relation\", [\r\n                    relationName,\r\n                    `fields: [${fkA}]`,\r\n                    `references: [id]`\r\n                ]);\r\n\r\n            builder.model(modelA)\r\n                .field(pluralize.plural(camelCase(modelB)), `${pivotModelName}[]`)\r\n                .attribute(\"relation\", [relationName]);\r\n\r\n            return response.result(`One-to-Many relation (with pivot table) added between ${modelA} and ${modelB}`);\r\n        }\r\n    } if (type == \"M:N\") {\r\n        if (!pivotTable) {\r\n            const toKey = pluralize.plural(camelCase(modelB));\r\n            const fromKey = pluralize.plural(selfPrefix(modelA));\r\n\r\n            builder.model(modelA)\r\n                .field(toKey, `${modelB}[]`)\r\n                .attribute(\"relation\", [relationName]);\r\n\r\n            builder.model(modelB)\r\n                .field(fromKey, `${modelA}[]`)\r\n                .attribute(\"relation\", [relationName]);\r\n            return response.result(`Many-to-Many relation (without pivot table) added between ${modelA} and ${modelB}`);\r\n        } else {\r\n            const customSelfPrefix = (str: string) => {\r\n                return isSelfRelation ? (str + 'By') : str;\r\n            }\r\n            const toPluralKey = pluralize.plural(camelCase(modelB));\r\n            const fromPluralKey = pluralize.plural(selfPrefix(modelA));\r\n\r\n            const aModelBuilder = builder.model(modelA)\r\n                .field(toPluralKey, `${pivotModelName}[]`)\r\n                .attribute(\"relation\", [relationName]);\r\n\r\n            const bModelBuilder = isSelfRelation ? aModelBuilder : builder.model(modelB);\r\n            bModelBuilder.field(fromPluralKey, `${pivotModelName}[]`)\r\n                .attribute(\"relation\", [`\"${customSelfPrefix(sourceRelationName)}\"`]);\r\n\r\n\r\n            const fkA = selfPrefix(modelA, true);\r\n            const fkB = fk(modelB);\r\n\r\n            const toKey = camelCase(modelB);\r\n            const fromKey = selfPrefix(modelA);\r\n\r\n            const idFieldModelA = (helper.getIdFieldTypeModel(modelA) || 'String') as string;\r\n            const idFieldModelB = (helper.getIdFieldTypeModel(modelB) || 'String') as string;\r\n            builder.model(pivotModelName!)\r\n                .field(fkA, idFieldModelA)\r\n                .field(fkB, idFieldModelB)\r\n                .field(\"createdAt\", \"DateTime\").attribute(\"default\", [\"now()\"])\r\n\r\n                .field(fromKey, modelA).attribute(\"relation\", [\r\n                    `\"${(customSelfPrefix(sourceRelationName))}\"`,\r\n                    `fields: [${fkA}]`,\r\n                    `references: [id]`,\r\n                    `onDelete: Cascade`,\r\n                ])\r\n                .field(toKey, modelB).attribute(\"relation\", [\r\n                    relationName,\r\n                    `fields: [${fkB}]`,\r\n                    `references: [id]`,\r\n                    `onDelete: Cascade`,\r\n                ])\r\n                .blockAttribute(\"id\", [fkA, fkB]);\r\n        }\r\n\r\n\r\n        return response.result(`Many-to-Many relation (with pivot table) added for ${modelA} and ${modelB}`);\r\n    }\r\n\r\n    return response.error(\"Not implemented\");\r\n}\r\n\r\n","import { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\n\r\nexport const deleteEnum: PrismaQlHandler<\"DELETE\", \"ENUM\", \"mutation\"> = (prismaState, data) => {\r\n    const { args } = data;\r\n    const response = handlerResponse(data);\r\n\r\n    const enumName = args?.enums?.[0];\r\n    if (!enumName) {\r\n        return response.error(\"No enum name provided. Usage: DELETE ENUM ->[EnumName];\");\r\n    }\r\n\r\n    try {\r\n        const builder = prismaState.builder;\r\n        const prevEnum = builder.findByType(\"enum\", { name: enumName });\r\n        if (!prevEnum) {\r\n            return response.error(`Enum ${enumName} does not exist`);\r\n        }\r\n        builder.drop(enumName);\r\n\r\n        return response.result(`Enum ${enumName} deleted successfully`);\r\n    } catch (error) {\r\n        return response.error(`Error deleting enum: ${error.message}`);\r\n    }\r\n};\r\n","import { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\n\r\nexport const deleteField: PrismaQlHandler<\"DELETE\", \"FIELD\", \"mutation\"> = (prismaState, data) => {\r\n    const { args } = data;\r\n    const response = handlerResponse(data);\r\n\r\n    if (!args?.fields || !args.fields.length) {\r\n        return response.error(\"No field name provided. Example: DELETE FIELD ->[FieldName] IN ->[ModelName]\");\r\n    }\r\n\r\n    const modelName = args?.models?.[0];\r\n    if (!modelName) {\r\n        return response.error(\"No model name provided. Example: DELETE FIELD FieldName IN ->[ModelName]\");\r\n    }\r\n\r\n\r\n    const fieldName = args.fields[0];\r\n    try {\r\n\r\n        const builder = prismaState.builder;\r\n\r\n        const prevModel = builder.findByType(\"model\", { name: modelName });\r\n        if (!prevModel) {\r\n            return response.error(`Model ${modelName} does not exist`);\r\n        }\r\n\r\n        if (!prevModel.properties.find((prop) => prop.type === \"field\" && prop.name === fieldName)) {\r\n            return response.error(`Field ${fieldName} does not exist in model ${modelName}`);\r\n        }\r\n        const model = builder.model(modelName);\r\n        model.removeField(fieldName);\r\n        return response.result(`Field ${modelName} deleted successfully`);\r\n    } catch (error) {\r\n        return response.error(`Error deleting field: ${error.message}`);\r\n    }\r\n};\r\n","import { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\n\r\nexport const deleteModel: PrismaQlHandler<\"DELETE\", \"MODEL\", \"mutation\"> = (prismaState, data) => {\r\n    const { args } = data;\r\n    const response = handlerResponse(data);\r\n\r\n    const modelName = args?.models?.[0];\r\n\r\n    if (!modelName) {\r\n        return response.error(\"No model name provided. Usage: DELETE MODEL ->[ModelName];\");\r\n    }\r\n\r\n    try {\r\n        const builder = prismaState.builder;\r\n\r\n        const prevModel = builder.findByType(\"model\", { name: modelName });\r\n        if (!prevModel) {\r\n            return response.error(`Model ${modelName} does not exist`);\r\n        }\r\n\r\n        builder.drop(modelName);\r\n\r\n        return response.result(`Model ${modelName} deleted successfully`);\r\n    } catch (error) {\r\n        return response.error(`Error deleting model: ${error.message}`);\r\n    }\r\n};\r\n","import chalk from \"chalk\";\r\nimport { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport { Field } from \"@mrleebo/prisma-ast\";\r\n\r\nexport const deleteRelation: PrismaQlHandler<\"DELETE\", \"RELATION\", \"mutation\"> = (prismaState, data) => {\r\n    const { args, options } = data;\r\n    const response = handlerResponse(data);\r\n\r\n    const models = args?.models;\r\n    if (!models || models.length !== 2) {\r\n        return response.error(\"Two models are required to remove a relation. Example: DELETE RELATION -> [ModelA], [ModelB]\");\r\n    }\r\n    const [modelA, modelB] = models;\r\n\r\n    const { builder } = prismaState;\r\n    const modelARef = builder.findByType(\"model\", { name: modelA });\r\n    const modelBRef = builder.findByType(\"model\", { name: modelB });\r\n\r\n    if (!modelARef) {\r\n        return response.error(`Model ${modelA} not found`);\r\n    }\r\n    if (!modelBRef) {\r\n        return response.error(`Model ${modelB} not found`);\r\n    }\r\n    const fieldA = options?.fieldA;\r\n    const fieldB = options?.fieldB;\r\n\r\n    if (fieldA && !fieldB) {\r\n        return response.error(`Field ${fieldA} specified for ${modelA} but no field specified for ${modelB}`);\r\n    }\r\n\r\n    if (options?.relationName) {\r\n        console.log(chalk.yellow(`Relation name is specified. Attempting to remove relation by name`));\r\n        const fieldsA = modelARef.properties.filter(\r\n            (prop) => prop.type === \"field\" && (prop.fieldType === modelB || prop.fieldType === modelA)\r\n        ) as Field[];\r\n        const fieldsAByRelation = fieldsA.filter(\r\n            (field) => field?.attributes?.find(\r\n                (attr) => attr.type === \"attribute\" && attr.name === \"relation\" && attr.args?.some(\r\n                    (arg) => arg.type === \"attributeArgument\" && arg.value === `\"${options.relationName}\"`)\r\n            )\r\n        );\r\n        if (fieldsAByRelation.length === 0) {\r\n            return response.error(`Relation ${options.relationName} not found between ${modelA} and ${modelB}`);\r\n        }\r\n        for (const field of fieldsAByRelation) {\r\n            builder.model(modelA).removeField(field.name);\r\n        }\r\n\r\n        const fieldsB = modelBRef.properties.filter(\r\n            (prop) => prop.type === \"field\" && (prop.fieldType === modelB || prop.fieldType === modelA)\r\n        ) as Field[];\r\n        const fieldsBByRelation = fieldsB.filter(\r\n            (field) => field?.attributes?.find(\r\n                (attr) => attr.type === \"attribute\" && attr.name === \"relation\" && attr.args?.some(\r\n                    (arg) => arg.type === \"attributeArgument\" && arg.value === `\"${options.relationName}\"`)\r\n            )\r\n        );\r\n        for (const field of fieldsBByRelation) {\r\n            builder.model(modelB).removeField(field.name);\r\n        }\r\n        if (fieldsAByRelation.length === 0 && fieldsBByRelation.length === 0) {\r\n            return response.error(`Relation ${options.relationName} not found between ${modelA} and ${modelB}`);\r\n        }\r\n        return response.result(`Relation ${options.relationName} removed between ${modelA} and ${modelB}`);\r\n    }\r\n\r\n    if (!fieldA && !fieldB) {\r\n        console.log(chalk.yellow(`No fields specified. Attempting to remove all relations between ${modelA} and ${modelB}`));\r\n        const fieldsToRemoveA = modelARef.properties.filter(\r\n            (prop) => prop.type === \"field\" && prop.fieldType === modelB\r\n        ) as Field[]\r\n        const fieldsToRemoveB = modelBRef.properties.filter(\r\n            (prop) => prop.type === \"field\" && prop.fieldType === modelA\r\n        ) as Field[]\r\n\r\n        for (const field of fieldsToRemoveA) {\r\n            builder.model(modelA).removeField(field.name);\r\n        }\r\n\r\n        for (const field of fieldsToRemoveB) {\r\n            builder.model(modelB).removeField(field.name);\r\n        }\r\n        if (fieldsToRemoveA.length === 0 && fieldsToRemoveB.length === 0) {\r\n            return response.error(`Relations not found between ${modelA} and ${modelB}`);\r\n        }\r\n        return response.result(`All relations between ${modelA} and ${modelB} removed`);\r\n    }\r\n\r\n    const modelABuilder = builder.model(modelA);\r\n\r\n    const fieldInA = modelARef.properties.find(\r\n        (prop) => (prop.type === \"field\" && prop.name == fieldA) && (prop.fieldType === modelB || prop.fieldType === modelA\r\n        )\r\n    ) as Field;\r\n    if (fieldInA) {\r\n        modelABuilder.removeField(fieldInA.name);\r\n    }\r\n\r\n    const modelBBuilder = builder.model(modelB);\r\n    const fieldInB = modelBRef.properties.find(\r\n        (prop) => (prop.type === \"field\" && prop.name == fieldB) && (prop.fieldType === modelB || prop.fieldType === modelA)\r\n    ) as Field;\r\n    if (fieldInB) {\r\n        modelBBuilder.removeField(fieldInB.name);\r\n    }\r\n\r\n    if (fieldInA || fieldInB) {\r\n        return response.result(`Relation ${fieldInA?.name || fieldInB?.name} removed between ${modelA} and ${modelB}`);\r\n    }\r\n\r\n    return response.error(`Relation not found between ${modelA} and ${modelB}`);\r\n}","import { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport { constantCase } from \"change-case\";\r\n\r\nexport const updateEnum: PrismaQlHandler<\"UPDATE\", \"ENUM\", \"mutation\"> = (prismaState, data) => {\r\n    const { args, options } = data;\r\n    const response = handlerResponse(data);\r\n\r\n    const enumName = args?.enums?.[0];\r\n    if (!enumName) {\r\n        return response.error(\"No enum name provided. Example: UPDATE ENUM ->[EnumName] ({A|B|C})\");\r\n    }\r\n    if (!data.prismaBlock) {\r\n        return response.error(\"No enum block provided. Example: 'UPDATE ENUM EnumName ->[({A|B|C})];'\");\r\n    }\r\n    let keys: string[] = [];\r\n    if (data.prismaBlock) {\r\n        keys = data.prismaBlock.split(/\\s+/);\r\n    }\r\n    if (!keys.length) {\r\n        return response.error(\"No enum options provided. Example: 'UPDATE ENUM EnumName ({ ->[A|B|C] });'\");\r\n    }\r\n    try {\r\n        const enumOptions = keys?.map(key => constantCase(key));\r\n        const builder = prismaState.builder;\r\n        const prevEnum = builder.findByType(\"enum\", { name: enumName });\r\n        if (!prevEnum) {\r\n            builder.enum(enumName, enumOptions);\r\n            return response.result(`Enum ${enumName} added successfully`);\r\n        }\r\n        const oldValues = prevEnum.enumerators.filter(el => el.type == \"enumerator\").map(e => e.name);\r\n\r\n        const doExtend = !options?.replace;\r\n\r\n        let finalValues: string[];\r\n        if (doExtend) {\r\n            finalValues = Array.from(new Set([...oldValues, ...enumOptions]));\r\n        } else {\r\n            finalValues = enumOptions;\r\n        }\r\n\r\n        builder.drop(enumName);\r\n        builder.enum(enumName, finalValues);\r\n\r\n        return response.result(`Enum ${enumName} added successfully`);\r\n    } catch (error) {\r\n        return response.error(`Error adding enum: ${error.message}`);\r\n    }\r\n};","import { Field, getSchema, Model, Property } from \"@mrleebo/prisma-ast\";\r\nimport { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport { parseFieldForBuilder } from \"../../utils/schema-helper.js\";\r\n\r\nexport const updateField: PrismaQlHandler<\"UPDATE\", \"FIELD\", \"mutation\"> = (prismaState, data) => {\r\n    const response = handlerResponse(data);\r\n    const { args } = data;\r\n    const fieldName = args?.fields?.[0];\r\n    if (!fieldName) {\r\n        return response.error(\"No field name provided. Usage: UPDATE FIELD ->[FieldName] IN [ModelName] ({String @default('test')})\");\r\n    }\r\n    const modelName = args?.models?.[0];\r\n\r\n    if (!modelName) {\r\n        return response.error(\"No model name provided. Usage: UPDATE FIELD [FieldName] IN -> [ModelName] ({String @default('test')})\");\r\n    }\r\n\r\n    const model = prismaState.builder.findByType(\"model\", { name: modelName });\r\n    if (!model) {\r\n        return response.error(`Model ${modelName} not found`);\r\n    }\r\n\r\n    if (!data.prismaBlock) {\r\n        return response.error(\"No field block provided. Example: 'UPDATE FIELD FieldName IN ModelName ->[({String @default('test')})];'\");\r\n    }\r\n\r\n    const prevField = model.properties.find((prop) => prop.type === \"field\" && prop.name === fieldName) as Field;\r\n    if (!prevField) {\r\n        return response.error(`Field ${fieldName} does not exist in model ${modelName}`);\r\n    }\r\n    let parsed: ReturnType<typeof getSchema>;\r\n    const sourceField = `model Test {\r\n        ${fieldName} ${data.prismaBlock}\r\n    }`;\r\n\r\n    try {\r\n        parsed = getSchema(sourceField);\r\n    } catch (error) {\r\n        return response.error(\"There is likely an issue with the block. The block should contain Prisma field attributes including the type, but without the field name. Example: 'String @default('test')'\");\r\n    }\r\n\r\n    const testModel = parsed.list[0] as Model;\r\n    const newField = testModel.properties.find((prop) => prop.type === \"field\" && prop.name === fieldName);\r\n    if (!newField) {\r\n        return response.error(\"Invalid field. Please refer to the documentation and ensure the field block is correct. Example: 'UPDATE FIELD [FieldName] IN [ModelName] -> ({String?});'\");\r\n    }\r\n    const fieldData = parseFieldForBuilder(newField as Property);\r\n    if (!fieldData) {\r\n        return response.error(\"Invalid field. Please refer to the documentation and ensure the field block is correct. Example: 'UPDATE FIELD [FieldName] IN [ModelName] -> ({String?});'\");\r\n    }\r\n    const modelBuilder = prismaState.builder.model(model.name);\r\n    if (fieldData) {\r\n        modelBuilder.removeField(fieldName);\r\n        const fieldBuilder = modelBuilder.field(fieldData.name, fieldData.fieldType);\r\n\r\n        for (const attr of fieldData.attributes) {\r\n            fieldBuilder.attribute(attr.name, attr.args);\r\n        }\r\n    }\r\n\r\n    return response.result(`Field ${fieldName} added to model ${modelName}`);\r\n}\r\n","import { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport { getSchema } from \"@mrleebo/prisma-ast\";\r\n\r\nexport const addGenerator: PrismaQlHandler<\"ADD\", \"GENERATOR\", \"mutation\"> = (prismaState, data) => {\r\n    const { args } = data;\r\n    const response = handlerResponse(data);\r\n    const builder = prismaState.builder;\r\n\r\n    const generatorName = args?.generators?.[0];\r\n    if (!generatorName) {\r\n        return response.error(\"No generator name provided. Example: 'ADD GENERATOR ->[GeneratorName] ({key: value});'\");\r\n    }\r\n\r\n    const prismaBlock = data.prismaBlock;\r\n    if (!prismaBlock) {\r\n        return response.error(\"No generator block provided. Example: 'ADD GENERATOR GeneratorName ->[({key: value})];'\");\r\n    }\r\n\r\n    const prevGenerator = builder.findByType(\"generator\", { name: generatorName });\r\n    if (prevGenerator) {\r\n        return response.error(`Generator ${generatorName} already exists`);\r\n    }\r\n\r\n    let parsed: ReturnType<typeof getSchema>;\r\n\r\n    const sourceModel = `generator ${generatorName} {\r\n        ${prismaBlock}\r\n    }`;\r\n    try {\r\n        parsed = getSchema(sourceModel);\r\n    } catch (error) {\r\n        return response.error(`Invalid block provided. Error parsing model: ${error.message}`);\r\n    }\r\n\r\n    const schema = prismaState.builder.getSchema();\r\n    const newGenerator = parsed.list[0];\r\n    schema.list.push(newGenerator);\r\n\r\n    return response.result(`Generator ${generatorName} added successfully!`);\r\n};\r\n","import chalk from \"chalk\";\r\nimport { PrismaQlHandler, handlerResponse } from \"../../handler-registries/handler-registry.js\";\r\nimport { getSchema } from \"@mrleebo/prisma-ast\";\r\n\r\nexport function normalizeQuotes(input: string): string {\r\n    return input\r\n        .replace(/^[\\'\"]+/, '')\r\n        .replace(/[\\'\"]+$/, '');\r\n}\r\nexport const updateGenerator: PrismaQlHandler<\"UPDATE\", \"GENERATOR\", \"mutation\"> = (prismaState, data) => {\r\n    const { args, options } = data;\r\n    const response = handlerResponse(data);\r\n    const builder = prismaState.builder;\r\n\r\n    const generatorName = args?.generators?.[0];\r\n    if (!generatorName) {\r\n        return response.error(\"No generator name provided. Example: 'ADD GENERATOR ->[GeneratorName] ({key: value});'\");\r\n    }\r\n\r\n    const prevGenerator = builder.findByType(\"generator\", { name: generatorName });\r\n    if (!prevGenerator) {\r\n        return response.error(`Generator ${generatorName} does not exist`);\r\n    }\r\n\r\n    let parsed: ReturnType<typeof getSchema>;\r\n\r\n\r\n    const prismaBlock = data.prismaBlock;\r\n    if (prismaBlock) {\r\n        if (!prismaBlock) {\r\n            return response.error(\"No generator block provided. Example: 'ADD GENERATOR GeneratorName ->[({key: value})];'\");\r\n        }\r\n        console.log(chalk.yellow(`Warning: generator block provided. Generator ${generatorName} will be replaced`));\r\n        builder.drop(prevGenerator.name);\r\n\r\n        const sourceModel = `generator ${generatorName} {\r\n        ${prismaBlock}\r\n    }`;\r\n        try {\r\n            parsed = getSchema(sourceModel);\r\n        } catch (error) {\r\n            return response.error(`Invalid block provided. Error parsing model: ${error.message}`);\r\n        }\r\n\r\n\r\n        const schema = prismaState.builder.getSchema();\r\n        const newGenerator = parsed.list[0];\r\n        schema.list.push(newGenerator);\r\n    } else if (options && Object.keys(options).length) {\r\n        const generator = builder.generator(generatorName);\r\n        const otherOptions = Object.keys(options).filter(key => key !== 'output' && key !== 'provider');\r\n        if (otherOptions.length) {\r\n            console.log(chalk.yellow(`Warning: unknown options ${otherOptions.join(', ')} will be skipped`));\r\n            const validOptions = ['output', 'provider'];\r\n            console.log(chalk.yellow(`Valid options are: ${validOptions.join(', ')}`));\r\n        }\r\n        if (options?.output) {\r\n            generator.assignment('output', normalizeQuotes(options.output));\r\n        }\r\n        if (options?.provider) {\r\n            generator.assignment('provider', normalizeQuotes(options.provider));\r\n        }\r\n    }\r\n\r\n    return response.result(`Generator ${generatorName} added successfully!`);\r\n};\r\n","import { handlerResponse, PrismaQlHandler } from \"src/modules/handler-registries/handler-registry.js\";\r\n\r\nexport function normalizeQuotes(input: string): string {\r\n    return input\r\n        .replace(/^[\\'\"]+/, '')\r\n        .replace(/[\\'\"]+$/, '');\r\n}\r\nexport const updateDB: PrismaQlHandler<\"UPDATE\", \"DB\", \"mutation\"> = (prismaState, data) => {\r\n    const { options } = data;\r\n    const response = handlerResponse(data);\r\n\r\n    if (!options?.provider && !options?.url) {\r\n        return response.error(\"No provider or url provided. Example: 'UPDATE DB (->[url='sqlite://prisma.db' provider='sqlite']);'\");\r\n    }\r\n\r\n    const builder = prismaState.builder;\r\n\r\n    const prev = builder.findByType(\"datasource\", {\r\n        name: \"db\"\r\n    });\r\n    if (!prev) {\r\n        return response.error(\"No datasource found\");\r\n    }\r\n\r\n    const provider = (options.provider ? `\"${options.provider}\"` : null) || (prev as any)?.assignments?.find((a: any) => a.key == \"provider\")?.value;\r\n    let prevUrl = options.url?.toString() || (prev as any)?.assignments?.find((a: any) => a.key == \"url\")?.value as any;\r\n\r\n    if (typeof prevUrl == \"object\" && prevUrl.name == 'env') {\r\n        prevUrl = {\r\n            env: normalizeQuotes(prevUrl.params[0])\r\n        }\r\n    }\r\n\r\n    builder.datasource(provider, prevUrl || {\r\n        env: \"DATABASE_URL\"\r\n    });\r\n\r\n    return response.result(`DB updated successfully`);\r\n}","import { addEnum } from \"../prehandlers/mutation-handlers/add-enum.js\";\r\nimport { addField } from \"../prehandlers/mutation-handlers/add-field.js\";\r\nimport { addModel } from \"../prehandlers/mutation-handlers/add-model.js\";\r\nimport { addRelation } from \"../prehandlers/mutation-handlers/add-relation.js\";\r\nimport { deleteEnum } from \"../prehandlers/mutation-handlers/delete-enum.js\";\r\nimport { deleteField } from \"../prehandlers/mutation-handlers/delete-field.js\";\r\nimport { deleteModel } from \"../prehandlers/mutation-handlers/delete-model.js\";\r\nimport { deleteRelation } from \"../prehandlers/mutation-handlers/delete-relations.js\";\r\nimport { updateEnum } from \"../prehandlers/mutation-handlers/update-enum.js\";\r\nimport { updateField } from \"../prehandlers/mutation-handlers/update-field.js\";\r\nimport { PrismaQlMutationHandlerRegistry } from \"../handler-registries/mutation-handler-registry.js\";\r\nimport { addGenerator } from \"../prehandlers/mutation-handlers/add-generator.js\";\r\nimport { updateGenerator } from \"../prehandlers/mutation-handlers/update-generator.js\";\r\nimport { updateDB } from \"../prehandlers/mutation-handlers/update-db.js\";\r\n\r\nexport const mutationsHandler = new PrismaQlMutationHandlerRegistry();\r\n\r\nmutationsHandler.register(\"ADD\", \"MODEL\", addModel);\r\nmutationsHandler.register(\"ADD\", \"FIELD\", addField);\r\nmutationsHandler.register(\"ADD\", \"ENUM\", addEnum);\r\nmutationsHandler.register(\"ADD\", \"RELATION\", addRelation);\r\nmutationsHandler.register(\"ADD\", \"GENERATOR\", addGenerator);\r\n\r\nmutationsHandler.register(\"DELETE\", \"ENUM\", deleteEnum);\r\nmutationsHandler.register(\"DELETE\", \"MODEL\", deleteModel);\r\nmutationsHandler.register(\"DELETE\", \"FIELD\", deleteField);\r\nmutationsHandler.register(\"DELETE\", \"RELATION\", deleteRelation);\r\nmutationsHandler.register(\"DELETE\", \"GENERATOR\", deleteRelation);\r\n\r\nmutationsHandler.register(\"UPDATE\", \"FIELD\", updateField);\r\nmutationsHandler.register(\"UPDATE\", \"ENUM\", updateEnum);\r\nmutationsHandler.register(\"UPDATE\", \"GENERATOR\", updateGenerator);\r\nmutationsHandler.register(\"UPDATE\", \"DB\", updateDB);\r\n","import { handlerResponse, PrismaQlHandler } from \"src/modules/handler-registries/handler-registry.js\";\r\nimport { useHelper } from \"src/modules/utils/schema-helper.js\";\r\nimport Table from \"cli-table3\";\r\nimport boxen from \"boxen\";\r\nimport chalk from \"chalk\";\r\n\r\nexport const getGenerators: PrismaQlHandler<\"GET\", \"GENERATORS\", 'query'> = (prismaState, data) => {\r\n    const response = handlerResponse(data);\r\n    const helper = useHelper(prismaState);\r\n    const generators = helper.getGenerators();\r\n    if (!generators) return response.result(\"No generators found.\");\r\n\r\n    const sections: Array<{\r\n        name: string,\r\n        table: string\r\n    }> = [];\r\n\r\n    generators.forEach((generator: any) => {\r\n\r\n        const table = new Table({\r\n            head: ['Property', 'Value'],\r\n            colWidths: [20, 50]\r\n        });\r\n\r\n\r\n        generator?.assignments?.forEach((assignment: Record<string, any>) => {\r\n            if (!assignment) return;\r\n            table.push([assignment?.key, assignment?.value]);\r\n        });\r\n\r\n        sections.push({\r\n            name: generator.name,\r\n            table: table.toString()\r\n        });\r\n    });\r\n    const result = sections.map(section => {\r\n        return boxen(chalk.bold(section.name) + \"\\n\" + section.table, { padding: 1, borderStyle: 'bold' });\r\n    }).join(\"\\n\");\r\n\r\n    return response.result(`\r\nGenerators found: ${generators.length}\r\n${result}\r\n`\r\n    );\r\n}","import boxen from \"boxen\";\r\nimport chalk from \"chalk\";\r\nimport { handlerResponse, PrismaQlHandler } from \"src/modules/handler-registries/handler-registry.js\";\r\n\r\nexport function normalizeQuotes(input: string): string {\r\n    return input\r\n        .replace(/^[\\'\"]+/, '')\r\n        .replace(/[\\'\"]+$/, '');\r\n}\r\nexport const getDB: PrismaQlHandler<\"GET\", \"DB\", \"query\"> = (prismaState, data) => {\r\n    const response = handlerResponse(data);\r\n\r\n    const builder = prismaState.builder;\r\n\r\n    const prev = builder.findByType(\"datasource\", {\r\n        name: \"db\"\r\n    });\r\n    if (!prev) {\r\n        return response.error(\"No datasource found\");\r\n    }\r\n\r\n    const provider = (prev as any)?.assignments?.find((a: any) => a.key == \"provider\")?.value;\r\n    let prevUrl = (prev as any)?.assignments?.find((a: any) => a.key == \"url\")?.value as any;\r\n    if (typeof prevUrl == \"object\" && prevUrl.name == 'env') {\r\n        prevUrl = \"env(\" + normalizeQuotes(prevUrl.params[0]) + \")\";\r\n    }\r\n    return response.result(boxen(`${chalk.gray('Provider')}: ${provider}\\n${chalk.gray('URL')}: ${prevUrl}`, { padding: 1, textAlignment: 'left',  margin: 1, borderStyle: 'double' }));\r\n}","import { getEnumRelations } from \"../prehandlers/render-handlers/get-enum-relations.js\";\r\nimport { getEnums } from \"../prehandlers/render-handlers/get-enums.js\";\r\nimport { getFields } from \"../prehandlers/render-handlers/get-fields.js\";\r\nimport { getModelNames } from \"../prehandlers/render-handlers/get-model-names.js\";\r\nimport { getModel } from \"../prehandlers/render-handlers/get-model.js\";\r\nimport { getModels } from \"../prehandlers/render-handlers/get-models.js\";\r\nimport { getRelations } from \"../prehandlers/render-handlers/get-relations.js\";\r\nimport { PrismaQlQueryHandlerRegistry } from \"../handler-registries/query-handler-registry.js\";\r\nimport { getGenerators } from \"../prehandlers/render-handlers/get-generators.js\";\r\nimport { getDB } from \"../prehandlers/render-handlers/get-db.js\";\r\nexport const queryRendersHandler = new PrismaQlQueryHandlerRegistry();\r\n\r\nqueryRendersHandler.register(\"GET\", \"MODEL\", getModel);\r\nqueryRendersHandler.register(\"GET\", \"MODELS\", getModels);\r\nqueryRendersHandler.register(\"GET\", \"FIELDS\", getFields);\r\nqueryRendersHandler.register(\"GET\", \"ENUMS\", getEnums);\r\nqueryRendersHandler.register(\"GET\", \"MODELS_LIST\", getModelNames);\r\nqueryRendersHandler.register(\"GET\", \"RELATIONS\", getRelations);\r\nqueryRendersHandler.register(\"GET\", \"ENUM_RELATIONS\", getEnumRelations);\r\nqueryRendersHandler.register(\"GET\", \"GENERATORS\", getGenerators);\r\nqueryRendersHandler.register(\"GET\", \"DB\", getDB);","import { handlerResponse, PrismaQlHandler } from \"src/modules/handler-registries/handler-registry.js\";\r\nimport { useHelper } from \"src/modules/utils/schema-helper.js\";\r\n\r\nexport const getJsonGenerators: PrismaQlHandler<\"GET\", \"GENERATORS\", 'query'> = (prismaState, data) => {\r\n    const response = handlerResponse(data);\r\n    const helper = useHelper(prismaState);\r\n    const generators = helper.getGenerators();\r\n    if (!generators) return response.result({\r\n        total: 0,\r\n        generators: []\r\n    });\r\n\r\n    const sections: Array<{\r\n        name: string,\r\n        properties: Array<{\r\n            key: string,\r\n            value: string\r\n        }>\r\n    }> = [];\r\n\r\n    generators.forEach((generator: any) => {\r\n\r\n        const props: Array<{\r\n            key: string,\r\n            value: string\r\n        }> = [];\r\n\r\n        generator?.assignments?.forEach((assignment: Record<string, any>) => {\r\n            if (!assignment) return;\r\n            props.push({\r\n                key: assignment?.key,\r\n                value: assignment?.value\r\n            });\r\n        });\r\n        sections.push({\r\n            name: generator.name,\r\n            properties: props\r\n        });\r\n    });\r\n\r\n    return response.result({\r\n        total: generators.length,\r\n        generators: sections\r\n    });\r\n}","import { getJsonEnums } from \"../prehandlers/json-handlers/get-enums.js\";\r\nimport { getJsonFields } from \"../prehandlers/json-handlers/get-fields.js\";\r\nimport { getJsonModelNames } from \"../prehandlers/json-handlers/get-model-names.js\";\r\nimport { getJsonModel } from \"../prehandlers/json-handlers/get-model.js\";\r\nimport { getJsonModels } from \"../prehandlers/json-handlers/get-models.js\";\r\nimport { getJsonRelations } from \"../prehandlers/json-handlers/get-relations.js\";\r\nimport { getEnumRelations } from \"../prehandlers/render-handlers/get-enum-relations.js\";\r\nimport { PrismaQlQueryHandlerRegistry } from \"../handler-registries/query-handler-registry.js\";\r\nimport { getJsonGenerators } from \"../prehandlers/json-handlers/get-generators.js\";\r\n\r\nexport const queryJSONHandler = new PrismaQlQueryHandlerRegistry();\r\n\r\nqueryJSONHandler.register(\"GET\", \"MODEL\", getJsonModel);\r\nqueryJSONHandler.register(\"GET\", \"MODELS\", getJsonModels);\r\nqueryJSONHandler.register(\"GET\", \"FIELDS\", getJsonFields);\r\nqueryJSONHandler.register(\"GET\", \"ENUMS\", getJsonEnums);\r\nqueryJSONHandler.register(\"GET\", \"MODELS_LIST\", getJsonModelNames);\r\nqueryJSONHandler.register(\"GET\", \"RELATIONS\", getJsonRelations);\r\nqueryJSONHandler.register(\"GET\", \"ENUM_RELATIONS\", getEnumRelations);\r\nqueryJSONHandler.register(\"GET\", \"GENERATORS\", getJsonGenerators);\r\n"],"mappings":";;;;;;;AA0GA,IAAM,cAAc;AAEpB,IAAM,qBAAsE;AAAA,EACxE,KAAK,CAAC,UAAU,MAAM,cAAc,SAAS,kBAAkB,UAAU,aAAa,SAAS,aAAa;AAAA,EAC5G,KAAK,CAAC,SAAS,aAAa,SAAS,YAAY,MAAM;AAAA,EACvD,QAAQ,CAAC,SAAS,SAAS,YAAY,QAAQ,WAAW;AAAA,EAC1D,QAAQ,CAAC,SAAS,QAAQ,aAAa,IAAI;AAAA,EAC3C,OAAO,CAAC;AAAA,EACR,UAAU,CAAC;AACf;AAEO,IAAM,oBAAN,MAGL;AAAA,EAUE,YACW,gBAIT;AAJS;AAAA,EAKX;AAAA,EAfQ,iBAAiC,CAAC;AAAA,EAClC,gBAA4D;AAAA,IAChE,KAAK;AAAA,IACL,KAAK;AAAA,IACL,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,UAAU;AAAA,EACd;AAAA,EAQO,gBAAgB,QAAW,SAAY,MAAuB;AACjE,QAAI,CAAC,KAAK,eAAe,MAAM,GAAG;AAC9B,WAAK,eAAe,MAAM,IAAI,CAAC;AAAA,IACnC;AACA,SAAK,eAAe,MAAM,EAAE,KAAK,OAAO;AACxC,IAAC,KAAK,cAAkD,MAAM,IAAI;AAAA,EACtE;AAAA,EACO,cAA8B;AACjC,WAAO;AAAA,MACH,GAAG;AAAA,MACH,GAAG,KAAK;AAAA,IACZ;AAAA,EACJ;AAAA,EAEA,aAAwG,OAA2C;AAC/I,UAAM,UAAU,MAAM,KAAK;AAC3B,QAAI,CAAC,QAAQ,SAAS,GAAG,GAAG;AACxB,YAAM,IAAI,MAAM,wCAAwC;AAAA,IAC5D;AACA,UAAM,MAAM,QAAQ,MAAM,GAAG,EAAE,EAAE,KAAK;AAEtC,UAAM,QAAQ,IAAI,MAAM,WAAW;AACnC,QAAI,CAAC,OAAO;AACR,YAAM,IAAI,MAAM,8BAA8B,GAAG,GAAG;AAAA,IACxD;AAEA,UAAM,YAAY,MAAM,CAAC,EAAE,YAAY;AACvC,UAAM,aAAa,MAAM,CAAC,GAAG,YAAY;AACzC,UAAM,UAAU,MAAM,CAAC,GAAG,KAAK,KAAK;AACpC,QAAI,iBAAiB,MAAM,CAAC,GAAG,KAAK,KAAK;AACzC,QAAI,gBAAgB;AAChB,uBAAiB,eAAe,QAAQ,MAAM,GAAG;AACjD,uBAAiB,eAAe,QAAQ,QAAQ,IAAI;AACpD,uBAAiB,eAAe,QAAQ,OAAO,IAAI;AAAA,IACvD;AACA,QAAI,aAAa,MAAM,CAAC,GAAG,KAAK,KAAK;AACrC,QAAI,YAAY;AACZ,mBAAa,WAAW,QAAQ,MAAM,GAAG;AACzC,mBAAa,WAAW,QAAQ,QAAQ,IAAI;AAC5C,mBAAa,WAAW,QAAQ,OAAO,IAAI;AAAA,IAC/C;AAEA,QAAI,EAAE,aAAa,uBAAuB,EAAE,aAAa,KAAK,iBAAiB;AAC3E,YAAM,IAAI,MAAM,uBAAuB,SAAS,yBAAyB,OAAO,KAAK,kBAAkB,EAAE,KAAK,IAAI,CAAC,EAAE;AAAA,IACzH;AAEA,QAAI;AACJ,UAAM,YAAY;AAClB,UAAM,WAAW,KAAK,YAAY;AAClC,UAAM,oBAAoB,SAAS,SAAS,KAAK,CAAC;AAElD,QAAI,YAAY;AACZ,UAAI,CAAC,kBAAkB,SAAS,UAAU,GAAG;AACzC,cAAM,IAAI,MAAM,oBAAoB,UAAU,iBAAiB,SAAS,iBAAiB,kBAAkB,KAAK,IAAI,CAAC,EAAE;AAAA,MAC3H;AACA,qBAAe;AAAA,IACnB;AAEA,UAAM,gBAAgB,aAAa,KAAK,YAAY,UAAU,IAAI;AAClE,UAAM,WAAW,KAAK,UAAgB,OAAO;AAC7C,UAAM,gBAAgB,KAAK,eAAe,SAAS,EAAE,gBAAgB,SAAS;AAC9E,UAAM,YAAY,gBAAgB,cAAc,UAAU,OAAO,IAAI;AAErE,WAAO;AAAA,MACH,QAAQ;AAAA,MACR,SAAS;AAAA,MACT,MAAM;AAAA,MACN,SAAS;AAAA,MACT,aAAa;AAAA,MACb,KAAK;AAAA,MACL,MAAM,KAAK,cAAc,SAAS;AAAA,IACtC;AAAA,EACJ;AAAA,EACA,YAAY,OAA6C;AACrD,UAAM,SAAuC,CAAC;AAC9C,UAAM,SAAS,MAAM,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,EAAE,OAAO,OAAO;AACjE,eAAW,SAAS,QAAQ;AACxB,YAAM,UAAU,MAAM,QAAQ,GAAG;AACjC,UAAI,UAAU,GAAG;AACb,cAAM,MAAM,MAAM,MAAM,GAAG,OAAO,EAAE,KAAK;AACzC,YAAI,WAAW,MAAM,MAAM,UAAU,CAAC,EAAE,KAAK;AAC7C,YAAI,QAAQ,KAAK,QAAQ,GAAG;AACxB,iBAAO,GAAG,IAAI,SAAS,UAAU,EAAE;AAAA,QACvC;AAAE,YAAI,aAAa,QAAQ;AACvB,iBAAO,GAAG,IAAI;AAAA,QAClB,WACS,aAAa,SAAS;AAC3B,iBAAO,GAAG,IAAI;AAAA,QAClB,OACK;AACD,iBAAO,GAAG,IAAI;AAAA,QAClB;AACA,YAAI,SAAS,SAAS,GAAG,GAAG;AACxB,iBAAO,GAAG,IAAI,SAAS,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC;AAAA,QACvD,OAAO;AACH,cAAI;AACA,mBAAO,GAAG,IAAI,KAAK,MAAM,QAAQ;AAAA,UACrC,SAAS,GAAG;AACR,mBAAO,GAAG,IAAI;AAAA,UAClB;AAAA,QACJ;AAAA,MACJ,OAAO;AACH,cAAM,OAAO,MAAM,KAAK;AACxB,eAAO,IAAI,IAAI;AAAA,MACnB;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,UAAiF,SAAoD;AACjI,UAAM,OAA8B,CAAC;AACrC,QAAI,CAAC,QAAS,QAAO;AAErB,UAAM,SAAS,QAAQ,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,EAAE,OAAO,OAAO;AACnE,eAAW,SAAS,QAAQ;AACxB,WAAK,SAAS,KAAK,UAAU,CAAC;AAC9B,WAAK,OAAO,KAAK,KAAK;AAAA,IAC1B;AACA,WAAO;AAAA,EACX;AAAA,EACA,iBAAiB,QAAwC;AACrD,UAAM,qBAAqB;AAC3B,UAAM,QAAQ,OAAO,MAAM,kBAAkB;AAC7C,QAAI,CAAC,MAAO,QAAO;AACnB,UAAM,YAAY,MAAM,CAAC,EAAE,YAAY;AACvC,WAAO,KAAK,cAAc,SAAS,KAAK;AAAA,EAC5C;AAAA,EACA,QAAQ,QAAiC;AACrC,QAAI;AACA,WAAK,aAAa,MAAM;AACxB,aAAO;AAAA,IACX,SAAS,GAAG;AACR,aAAO;AAAA,IACX;AAAA,EACJ;AACJ;AAEO,IAAM,2BAGT;AAAA,EACA,KAAK;AAAA,IACD,SAAS,CAAC,eAAe;AAAA,IACzB,OAAO,CAAC,YAAY,YAAY;AAC5B,UAAI,SAAS,SAAS,IAAI,GAAG;AACzB,eAAO,EAAE,QAAQ,CAAC,QAAQ,MAAM,IAAI,EAAE,CAAC,EAAE,KAAK,CAAC,EAAE;AAAA,MACrD;AACA,aAAO;AAAA,IACX;AAAA,IACA,QAAQ,CAAC,GAAG,YAAY;AACpB,aAAO,EAAE,QAAQ,UAAU,QAAQ,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE;AAAA,IAC1E;AAAA,IACA,WAAW,CAAC,GAAG,YAAY;AACvB,aAAO,EAAE,QAAQ,UAAU,QAAQ,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE;AAAA,IAC1E;AAAA,IACA,QAAQ,CAAC,YAAY,YAAY;AAC7B,YAAM,CAAC,WAAW,SAAS,IAAI,SAAS,MAAM,IAAI,KAAK,CAAC;AACxD,UAAI,CAAC,aAAa,CAAC,UAAW,QAAO;AACrC,aAAO,EAAE,QAAQ,CAAC,UAAU,KAAK,CAAC,GAAG,QAAQ,UAAU,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,EAAE;AAAA,IACzF;AAAA,IACA,OAAO,CAAC,GAAG,YAAY;AACnB,aAAO,EAAE,OAAO,UAAU,QAAQ,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE;AAAA,IACzE;AAAA,IACA,gBAAgB,CAAC,GAAG,YAAY;AAC5B,aAAO,EAAE,OAAO,UAAU,QAAQ,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE;AAAA,IACzE;AAAA,EACJ;AAAA,EACA,KAAK;AAAA,IACD,SAAS,CAAC,eAAe;AAAA,IACzB,OAAO,CAAC,GAAG,YAAY;AACnB,aAAO,EAAE,QAAQ,UAAU,QAAQ,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE;AAAA,IAC1E;AAAA,IACA,WAAW,CAAC,YAAY,YAAY;AAChC,aAAO,EAAE,YAAY,UAAU,QAAQ,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE;AAAA,IAC9E;AAAA,IACA,MAAM,CAAC,GAAG,YAAY;AAClB,aAAO,EAAE,OAAO,UAAU,QAAQ,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE;AAAA,IACzE;AAAA,IACA,OAAO,CAAC,YAAY,YAAY;AAC5B,YAAM,CAAC,WAAW,SAAS,IAAI,SAAS,MAAM,IAAI,KAAK,CAAC;AACxD,UAAI,CAAC,aAAa,CAAC,UAAW,QAAO;AACrC,aAAO,EAAE,QAAQ,CAAC,UAAU,KAAK,CAAC,GAAG,QAAQ,CAAC,UAAU,KAAK,CAAC,EAAE;AAAA,IACpE;AAAA,IACA,UAAU,CAAC,YAAY,YAAY;AAC/B,YAAM,CAAC,WAAW,OAAO,IAAI,SAAS,MAAM,KAAK,KAAK,CAAC;AACvD,UAAI,CAAC,aAAa,CAAC,QAAS,QAAO;AACnC,aAAO,EAAE,QAAQ,CAAC,UAAU,KAAK,GAAG,QAAQ,KAAK,CAAC,EAAE;AAAA,IACxD;AAAA,EACJ;AAAA,EACA,QAAQ;AAAA,IACJ,SAAS,CAAC,eAAe;AAAA,IACzB,OAAO,CAAC,GAAG,YAAY;AACnB,aAAO,EAAE,QAAQ,UAAU,QAAQ,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE;AAAA,IAC1E;AAAA,IACA,MAAM,CAAC,GAAG,YAAY;AAClB,aAAO,EAAE,OAAO,UAAU,QAAQ,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE;AAAA,IACzE;AAAA,IACA,OAAO,CAAC,YAAY,YAAY;AAC5B,YAAM,CAAC,WAAW,SAAS,IAAI,SAAS,MAAM,IAAI,KAAK,CAAC;AACxD,UAAI,CAAC,aAAa,CAAC,UAAW,QAAO;AACrC,aAAO,EAAE,QAAQ,CAAC,UAAU,KAAK,CAAC,GAAG,QAAQ,CAAC,UAAU,KAAK,CAAC,EAAE;AAAA,IACpE;AAAA,IACA,UAAU,CAAC,GAAG,YAAY;AACtB,aAAO,EAAE,QAAQ,UAAU,QAAQ,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE;AAAA,IAC1E;AAAA,IACA,WAAW,CAAC,GAAG,YAAY;AACvB,aAAO,EAAE,YAAY,UAAU,QAAQ,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE;AAAA,IAC9E;AAAA,EACJ;AAAA,EACA,QAAQ;AAAA,IACJ,SAAS,CAAC,eAAe;AAAA,IACzB,OAAO,CAAC,YAAY,YAAY;AAC5B,YAAM,CAAC,WAAW,WAAW,WAAW,IAAI,SAAS,MAAM,IAAI,KAAK,CAAC;AACrE,UAAI,CAAC,aAAa,CAAC,UAAW,QAAO;AACrC,aAAO;AAAA,QACH,QAAQ,CAAC,UAAU,KAAK,CAAC;AAAA,QAAG,QAAQ,CAAC,UAChC,KAAK,CAAC;AAAA,QAAG,aAAa,aAAa,KAAK;AAAA,MACjD;AAAA,IACJ;AAAA,IACA,MAAM,CAAC,GAAG,YAAY;AAClB,aAAO,EAAE,OAAO,UAAU,QAAQ,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE;AAAA,IACzE;AAAA,IACA,WAAW,CAAC,YAAY,YAAY;AAChC,aAAO,EAAE,YAAY,UAAU,QAAQ,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE;AAAA,IAC9E;AAAA,EACJ;AAAA,EACA,OAAO;AAAA,IACH,SAAS,CAAC,eAAe;AAAA,EAC7B;AAAA,EACA,UAAU;AAAA,IACN,SAAS,CAAC,eAAe;AAAA,EAC7B;AACJ;AAEO,IAAM,iBAAiB,IAAI,kBAAkB,wBAAwB;;;AClX5E,OAAOA,SAAQ;AACf,OAAO,SAAS;AAChB,OAAOC,WAAU;AACjB,SAAS,WAAW,iCAAiC;;;ACHrD,OAAO,SAAS;AAChB,IAAM,EAAE,QAAQ,IAAI;AAMpB,eAAsB,qBAAqB,QAAuC;AAC9E,MAAI;AACA,UAAM,QAAQ,EAAE,WAAW,OAAO,CAAC;AACnC,WAAO;AAAA,EACX,SAAS,OAAO;AACZ,WAAO;AAAA,EACX;AACJ;;;ACdA,OAAO,QAAQ;AACf,OAAO,UAAU;AAEV,IAAM,mBAAmB,OAAO,cAAkE;AACrG,QAAM,MAAM,QAAQ,IAAI;AACxB,MAAI,aAA4B;AAGhC,MAAI,WAAW;AAEX,UAAM,eAAe,KAAK,WAAW,SAAS,IAAI,YAAY,KAAK,QAAQ,KAAK,SAAS;AAEzF,QAAI,GAAG,WAAW,YAAY,GAAG;AAC7B,YAAM,OAAO,GAAG,SAAS,YAAY;AAErC,UAAI,KAAK,YAAY,GAAG;AAEpB,cAAM,sBAAsB;AAAA,UACxB,KAAK,KAAK,cAAc,UAAU,eAAe;AAAA,UACjD,KAAK,KAAK,cAAc,eAAe;AAAA,QAC3C;AAEA,qBAAa,oBAAoB,KAAK,GAAG,UAAU,KAAK;AAAA,MAC5D,WAAW,KAAK,OAAO,GAAG;AAEtB,qBAAa;AAAA,MACjB;AAAA,IACJ;AAEA,QAAI,CAAC,YAAY;AACb,YAAM,IAAI,MAAM,gBAAW,SAAS,8DAA8D;AAAA,IACtG;AAAA,EACJ,OAAO;AAEH,UAAM,sBAAsB;AAAA,MACxB,KAAK,KAAK,KAAK,UAAU,eAAe;AAAA,MACxC,KAAK,KAAK,KAAK,eAAe;AAAA,IAClC;AACA,iBAAa,oBAAoB,KAAK,GAAG,UAAU,KAAK;AAAA,EAC5D;AAGA,MAAI,CAAC,YAAY;AACb,UAAM,IAAI,MAAM,0IAAqI;AAAA,EACzJ;AAGA,QAAM,gBAAgB,MAAM,GAAG,SAAS,SAAS,YAAY,OAAO;AAGpE,MAAI,CAAC,uCAAuC,KAAK,aAAa,GAAG;AAC7D,UAAM,IAAI,MAAM,uBAAkB,UAAU,gDAAgD;AAAA,EAChG;AAEA,SAAO,EAAE,QAAQ,eAAe,MAAM,WAAW;AACrD;;;AFjDA,OAAOC,UAAS;AAIhB,SAAS,yBAAyB;AAClC,OAAO,WAAW;AAJlB,IAAM,EAAE,SAAAC,SAAQ,IAAID;AAKpB,IAAM,wBAAwB,IAAI,kBAAkB;AAa7C,IAAM,uBAAN,MAA2B;AAAA,EAI9B,YACW,mBACA,UAAuC,CAAC,GACjD;AAFS;AACA;AAEP,QAAI,QAAQ,YAAY;AACpB,WAAK,aAAa,QAAQ;AAAA,IAC9B;AAAA,EACJ;AAAA,EAVQ,sBAAqC;AAAA,EAC5B,cAAyC;AAAA,EAClD,aAA4B;AAAA,EASpC,MAAM,SAAS;AACX,UAAM,SAAS,KAAK,aAAa,QAAQ,MAAM,EAAE,MAAM,KAAK,CAAC;AAC7D,UAAM,eAAe,UAAU,MAAO;AACtC,UAAM,UAAU,0BAA0B,MAAM;AAChD,SAAK,eAAe,EAAE,YAAY,KAAK,aAAa,YAAY,QAAiB,KAAK,cAAc,SAAS,WAAW,KAAK,kBAAkB,aAAa,EAAE,CAAC;AAC/J,UAAM,KAAK,iBAAiB;AAAA,EAChC;AAAA,EACA,gBAAgB;AACZ,WAAO,KAAK,aAAa;AAAA,EAC7B;AAAA,EACQ,eAAe,UAA8B;AACjD,IAAC,KAAK,cAAqC;AAAA,EAC/C;AAAA,EACA,MAAM,aAAa,UAAmB,cAAc,OAAO;AACvD,QAAI,KAAK,eAAe,CAAC,aAAa;AAClC,aAAO,KAAK;AAAA,IAChB;AACA,UAAM,EAAE,QAAQ,MAAAE,MAAK,IAAI,MAAM,iBAAiB,QAAQ;AACxD,WAAO,KAAK,cAAc,QAAQA,KAAI;AAAA,EAC1C;AAAA,EACA,MAAM,mBAAmB;AACrB,UAAM,eAAe,KAAK,aAAa,UAAU;AACjD,UAAM,OAAO,MAAMD,SAAQ,EAAE,WAAW,aAAa,CAAC;AACtD,UAAM,SAAS,KAAK,UAAU;AAC9B,WAAO,KAAK,kBAAkB,UAAU,MAAM;AAAA,EAClD;AAAA,EACA,MAAc,cAAc,oBAA4B,YAAqB;AACzE,UAAM,UAAU,MAAM,KAAK,QAAQ,kBAAkB;AACrD,QAAI,mBAAmB,OAAO;AAC1B,YAAM;AAAA,IACV;AACA,UAAM,eAAe,UAAU,kBAAkB;AACjD,UAAM,UAAU,0BAA0B,kBAAkB;AAC5D,SAAK,eAAe,EAAE,YAAY,cAAc,IAAI,QAAQ,oBAAoB,KAAK,cAAc,SAAS,WAAW,KAAK,kBAAkB,aAAa,EAAE,CAAC;AAC9J,UAAM,KAAK,iBAAiB;AAC5B,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,aAAa,oBAA4B;AACrC,WAAO,KAAK,cAAc,kBAAkB;AAAA,EAChD;AAAA,EACA,MAAM,WAAwC;AAC1C,QAAI,CAAC,KAAK,aAAa;AACnB,YAAM,KAAK,aAAa;AAAA,IAC5B;AACA,UAAM,YAAY,KAAK,kBAAkB,aAAa;AACtD,WAAO;AAAA,MACH,GAAG,KAAK,eAAgB,CAAC;AAAA,MACzB;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,mBAAuC;AACnC,QAAI,CAAC,KAAK,aAAa;AACnB,YAAM,IAAI,MAAM,mBAAmB;AAAA,IACvC;AACA,UAAM,EAAE,QAAQ,oBAAoB,WAAW,IAAI,KAAK;AACxD,UAAM,eAAe,0BAA0B,kBAAkB;AACjE,UAAM,eAAe,UAAU,kBAAkB;AACjD,WAAO,EAAE,YAAY,QAAQ,oBAAoB,KAAK,cAAc,SAAS,cAAc,WAAW,KAAK,kBAAkB,aAAa,EAAE;AAAA,EAChJ;AAAA,EACA,MAAM,KAAK,SAAiC,YAAqB;AAC7D,QAAI,CAAC,KAAK,aAAa;AACnB,YAAM,IAAI,MAAM,uDAAuD;AAAA,IAC3E;AAEA,UAAM,WAAW,MAAM,QAAQ,OAAO,IAAI,UAAU,CAAC,OAAO;AAC5D,YAAQ,IAAI,gCAAyB,SAAS,MAAM,aAAa;AAEjE,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,YAAM,UAAU,SAAS,CAAC;AAC1B,YAAM,eAAe,IAAI;AACzB,cAAQ,IAAI,MAAM,KAAK,UAAU,YAAY,GAAG,GAAG,MAAM,WAAW,OAAO,CAAC;AAAA,IAChF;AAEA,QAAI,aAAa;AACjB,QAAI,cAAc,CAACC,MAAK,WAAW,UAAU,GAAG;AAC5C,mBAAaA,MAAK,KAAK,QAAQ,IAAI,GAAG,UAAU;AAAA,IACpD;AAEA,QAAI,CAAC,KAAK,aAAa,cAAc,CAAC,YAAY;AAC9C,YAAM,IAAI,MAAM,2DAA2D;AAAA,IAC/E;AAEA,QAAI;AACA,WAAK,MAAM;AAAA,IACf,SAAS,GAAG;AACR,YAAM,IAAI,MAAM,kEAAkE;AAAA,IACtF;AAEA,UAAM,YAAY,cAAc,KAAK,YAAY;AAEjD,QAAI,CAAC,WAAW;AACZ,YAAM,IAAI,MAAM,2DAA2D;AAAA,IAC/E;AAEA,QAAIC,IAAG,WAAW,SAAS,GAAG;AAC1B,YAAM,YAAY,KAAK,aAAa,KAAK,aAAaD,MAAK,KAAKA,MAAK,QAAQ,SAAS,GAAG,WAAW,SAAS;AAC7G,UAAI,cAAc,SAAS;AAC3B,YAAM,aAAaA,MAAK,KAAK,WAAW,GAAGA,MAAK,SAAS,SAAS,CAAC,KAAI,oBAAI,KAAK,GAAE,YAAY,EAAE,QAAQ,SAAS,GAAG,CAAC,aAAa;AAClI,UAAI,aAAa,WAAW,UAAU;AAAA,IAC1C;AAGA,UAAM,4BAA4B,KAAK,YAAY,QAAQ,MAAM,EAAE,MAAM,KAAK,CAAC;AAG/E,IAAAC,IAAG,cAAc,WAAW,2BAA2B,OAAO;AAE9D,YAAQ,IAAI,MAAM,YAAY,uCAAkC,SAAS,EAAE,CAAC;AAC5E,YAAQ,IAAI,MAAM,KAAK,yBAAiB,oBAAI,KAAK,GAAE,eAAe,CAAC,EAAE,CAAC;AAAA,EAC1E;AAAA,EACA,QAAQ;AACJ,QAAI,CAAC,KAAK,aAAa;AACnB,aAAO;AAAA,IACX;AACA,WAAO,sBAAsB,UAAU,KAAK,YAAY,QAAQ,MAAM,EAAE,MAAM,KAAK,CAAC,CAAC;AAAA,EACzF;AAAA,EACA,MAAM,QAAQ,cAA8C;AACxD,QAAI,CAAC,gBAAgB,CAAC,KAAK,aAAa;AACpC,YAAM,IAAI,MAAM,mBAAmB;AAAA,IACvC;AACA,UAAM,qBAAqB,gBAAgB,KAAK,aAAa,QAAQ,MAAM,EAAE,MAAM,KAAK,CAAC;AACzF,QAAI,CAAC,oBAAoB;AACrB,aAAO,IAAI,MAAM,6BAA6B;AAAA,IAClD;AACA,QAAI,KAAK,wBAAwB,oBAAoB;AACjD,aAAO;AAAA,IACX;AACA,UAAM,aAAa,MAAM,qBAAqB,kBAAkB;AAChE,QAAI,eAAe,MAAM;AACrB,WAAK,sBAAsB;AAAA,IAC/B,OAAO;AACH,WAAK,sBAAsB;AAAA,IAC/B;AACA,WAAO;AAAA,EACX;AAAA,EACA,QAAQ;AACJ,QAAI,CAAC,KAAK,aAAa;AACnB,YAAM,IAAI,MAAM,mBAAmB;AAAA,IACvC;AACA,SAAK,QAAQ;AAAA,EACjB;AACJ;;;AGlLA,OAAOC,UAAS;AAGhB,OAAO,eAAe;AACtB,SAAS,kBAAkB;AAH3B,IAAM,EAAE,SAAAC,SAAQ,IAAID;AAuBb,IAAM,4BAAN,MAAgC;AAAA,EAWnC,YAAoB,SAAkB,CAAC,GAAG;AAAtB;AAAA,EAAwB;AAAA,EAVpC,YAAgC,CAAC;AAAA,EACzC,eAAmC;AAC/B,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,MAAM,UAAU,QAAiB;AAC7B,SAAK,YAAY,CAAC;AAClB,SAAK,SAAS;AACd,UAAM,KAAK,kBAAkB;AAC7B,WAAO,KAAK;AAAA,EAChB;AAAA,EAGA,YAAY,WAAmB,WAA4C;AACvE,WAAO,KAAK,UAAU,KAAK,OAAK,EAAE,cAAc,aAAa,EAAE,cAAc,SAAS,KAAK;AAAA,EAC/F;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,wBAAwB,QAAqC;AACzD,UAAM,YAAgC,CAAC;AAGvC,UAAM,aAAa,OAAO,OAAO,WAAS;AACtC,YAAM,iBAAiB,MAAM,OAAO,OAAO,OAAK,EAAE,SAAS,YAAY,CAAC,EAAE,MAAM;AAChF,YAAM,eAAe,MAAM,OAAO,OAAO,OAAK,EAAE,SAAS,QAAQ;AAGjE,UAAI,eAAe,WAAW,EAAG,QAAO;AAGxC,aAAO,MAAM,YAAY,QAAQ;AAAA,QAAM,OACnC,aAAa,KAAK,QAAM,GAAG,SAAS,CAAC;AAAA,MACzC;AAAA,IACJ,CAAC,EAAE,IAAI,OAAK,EAAE,IAAI;AAElB,eAAW,SAAS,QAAQ;AAExB,UAAI,WAAW,SAAS,MAAM,IAAI,EAAG;AAErC,iBAAW,SAAS,MAAM,QAAQ;AAC9B,YAAI,MAAM,SAAS,YAAY,MAAM,QAAQ;AACzC;AAAA,QACJ;AAEA,YAAI,CAAC,MAAM,sBAAsB,MAAM,mBAAmB,WAAW,GAAG;AACpE;AAAA,QACJ;AAGA,YAAI,mBAAmB;AACvB,YAAI,cAAwB,CAAC;AAC7B,cAAM,qBAAqB,MAAM;AAEjC,YAAI,mBAAmB,WAAW,GAAG;AACjC,gBAAM,UAAU,MAAM,OAAO,KAAK,OAAK,EAAE,SAAS,mBAAmB,CAAC,CAAC;AACvE,cAAI,SAAS,YAAY,MAAM,YAAY,OAAO,SAAS,SAAS,IAAK,GAAG;AACxE,+BAAmB;AACnB,wBAAY,KAAK,SAAS,IAAK;AAAA,UACnC;AAAA,QACJ,OAAO;AACH,gBAAM,wBAAwB,MAAM,YAAY,OAAO,MAAM,OAAK,mBAAmB,SAAS,CAAC,CAAC;AAChG,gBAAM,oBAAoB,MAAM,eAAe;AAAA,YAAK,SAChD,IAAI,OAAO,WAAW,mBAAmB,UACzC,IAAI,OAAO,MAAM,OAAK,mBAAmB,SAAS,CAAC,CAAC;AAAA,UACxD;AAEA,cAAI,yBAAyB,mBAAmB;AAC5C,+BAAmB;AACnB,0BAAc,CAAC,GAAG,kBAAkB;AAAA,UACxC;AAAA,QACJ;AAEA,YAAI,CAAC,kBAAkB;AACnB;AAAA,QACJ;AAGA,cAAM,eAAe,OAAO,KAAK,OAAK,EAAE,SAAS,MAAM,IAAI;AAC3D,YAAI,CAAC,cAAc;AACf;AAAA,QACJ;AAGA,cAAM,eAAe,aAAa,OAAO;AAAA,UAAK,OAC1C,EAAE,iBAAiB,MAAM,gBAAgB,EAAE,SAAS,MAAM;AAAA,QAC9D;AAGA,cAAM,gBAAgB,MAAM,oBAAoB,CAAC;AAGjD,cAAM,mBAAmB,UAAU;AAAA,UAAK,OACpC,EAAE,cAAc,MAAM,QACtB,EAAE,iBAAiB,aAAa,QAChC,EAAE,cAAc,MAAM;AAAA,QAC1B;AACA,YAAI,kBAAkB;AAClB;AAAA,QACJ;AAGA,kBAAU,KAAK;AAAA,UACX,MAAM;AAAA,UACN,WAAW,MAAM;AAAA,UACjB,WAAW,MAAM;AAAA,UACjB,cAAc,aAAa;AAAA,UAC3B,cAAc,MAAM;AAAA,UACpB,YAAY,YAAY,KAAK,IAAI;AAAA,UACjC,cAAc,cAAc,KAAK,IAAI;AAAA,UACrC,cAAc,cAAc;AAAA,UAC5B,mBAAmB;AAAA,UACnB,aAAa,CAAC,GAAG,WAAW;AAAA,QAChC,CAAC;AAGD,YAAI,cAAc;AACd,oBAAU,KAAK;AAAA,YACX,MAAM;AAAA,YACN,WAAW,aAAa;AAAA,YACxB,WAAW,aAAa;AAAA,YACxB,cAAc,MAAM;AAAA,YACpB,cAAc,MAAM;AAAA,YACpB,YAAY;AAAA,YACZ,cAAc;AAAA,YACd,cAAc,MAAM;AAAA,YACpB,mBAAmB;AAAA,YACnB,aAAa,CAAC,GAAG,aAAa;AAAA,UAClC,CAAC;AAAA,QACL;AAAA,MAEJ;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA,EACA,yBAAyB,QAAqC;AAC1D,UAAM,YAAgC,CAAC;AAEvC,eAAW,SAAS,QAAQ;AACxB,iBAAW,SAAS,MAAM,QAAQ;AAC9B,YAAI,MAAM,SAAS,YAAY,CAAC,MAAM,QAAQ;AAC1C;AAAA,QACJ;AAGA,cAAM,eAAe,OAAO,KAAK,OAAK,EAAE,SAAS,MAAM,IAAI;AAC3D,YAAI,CAAC,aAAc;AAGnB,cAAM,eAAe,aAAa,OAAO;AAAA,UAAK,OAC1C,EAAE,iBAAiB,MAAM,gBAAgB,CAAC,EAAE;AAAA,QAChD;AACA,YAAI,CAAC,aAAc;AAGnB,YAAI,CAAC,aAAa,sBAAsB,aAAa,mBAAmB,WAAW,GAAG;AAClF;AAAA,QACJ;AAGA,cAAM,KAAK,aAAa,mBAAmB,KAAK,IAAI;AACpD,cAAM,KACF,aAAa,oBAAoB,aAAa,iBAAiB,SAAS,IAClE,aAAa,iBAAiB,KAAK,IAAI,IACvC;AAGV,cAAM,mBAAmB,UAAU;AAAA,UAAK,OACpC,EAAE,cAAc,MAAM,QACtB,EAAE,iBAAiB,aAAa,QAChC,EAAE,cAAc,MAAM,QACtB,EAAE,iBAAiB,MAAM;AAAA,QAC7B;AACA,YAAI,kBAAkB;AAClB;AAAA,QACJ;AAGA,kBAAU,KAAK;AAAA,UACX,MAAM;AAAA,UACN,WAAW,aAAa;AAAA;AAAA,UACxB,WAAW,aAAa;AAAA,UACxB,cAAc,MAAM;AAAA,UACpB,cAAc,MAAM;AAAA;AAAA,UACpB,YAAY;AAAA,UACZ,cAAc;AAAA,UACd,cAAc,MAAM;AAAA,UACpB,mBAAmB;AAAA,UACnB,aAAa,CAAC,GAAG,aAAa,kBAAkB;AAAA,QACpD,CAAC;AAGD,kBAAU,KAAK;AAAA,UACX,MAAM;AAAA,UACN,WAAW,MAAM;AAAA,UACjB,WAAW,MAAM;AAAA,UACjB,cAAc,aAAa;AAAA,UAC3B,cAAc,MAAM;AAAA;AAAA,UACpB,YAAY;AAAA,UACZ,cAAc;AAAA,UACd,cAAc,aAAa;AAAA,UAC3B,mBAAmB;AAAA,UACnB,aAAa,CAAC,GAAG,aAAa,kBAAkB;AAAA,QACpD,CAAC;AAAA,MACL;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACQ,uBAAuB,QAAgB,QAAgB,cAA+B;AAC1F,WAAO,uBAAuB,QAAQ,QAAQ,YAAY;AAAA,EAC9D;AAAA,EACA,0BAA0B,QAAqC;AAC3D,UAAM,YAAgC,CAAC;AACvC,UAAM,gBAAgB,oBAAI,IAAY;AAEtC,eAAW,SAAS,QAAQ;AACxB,iBAAW,SAAS,MAAM,QAAQ;AAE9B,YAAI,MAAM,SAAS,YAAY,CAAC,MAAM,QAAQ;AAC1C;AAAA,QACJ;AAGA,cAAM,eAAe,OAAO,KAAK,OAAK,EAAE,SAAS,MAAM,IAAI;AAC3D,YAAI,CAAC,aAAc;AAGnB,cAAM,gBAAgB,aAAa,OAAO;AAAA,UAAO,OAC7C,EAAE,iBAAiB,MAAM,gBAAgB,EAAE;AAAA,QAC/C;AAEA,YAAI,cAAc,WAAW,EAAG;AAGhC,cAAM,wBAAwB,OAAO;AAAA,UAAK,OACtC,EAAE,OAAO;AAAA,YAAK,OACV,EAAE,iBAAiB,MAAM,iBAAiB,EAAE,sBAAsB,CAAC,GAAG,SAAS;AAAA,UACnF;AAAA,QACJ;AACA,YAAI,uBAAuB;AACvB;AAAA,QACJ;AAEA,mBAAW,gBAAgB,eAAe;AAEtC,cAAI,MAAM,SAAS,aAAa,MAAM;AAClC;AAAA,UACJ;AAGA,gBAAM,cAAc,CAAC,MAAM,MAAM,aAAa,MAAM,MAAM,YAAY,EACjE,KAAK,EACL,KAAK,GAAG;AAEb,cAAI,cAAc,IAAI,WAAW,GAAG;AAChC;AAAA,UACJ;AAEA,wBAAc,IAAI,WAAW;AAE7B,gBAAM,aAAa,OAAO;AAAA,YAAK,OAC3B,EAAE,OAAO,KAAK,OAAK,EAAE,iBAAiB,MAAM,iBAAiB,EAAE,sBAAsB,CAAC,GAAG,SAAS,CAAC;AAAA,UACvG;AACA,gBAAM,YAAY,KAAK,uBAAuB,MAAM,MAAM,aAAa,MAAM,aAAa,MAAM,eAAe,MAAS;AAGxH,oBAAU,KAAK;AAAA,YACX,MAAM;AAAA,YACN,WAAW,MAAM;AAAA,YACjB,WAAW,MAAM;AAAA,YACjB,cAAc,aAAa;AAAA,YAC3B,cAAc,MAAM;AAAA,YACpB,YAAY;AAAA,YACZ,cAAc;AAAA,YACd,cAAc,aAAa;AAAA,YAC3B,mBAAmB;AAAA,YACnB,eAAe;AAAA;AAAA,YACf,aAAa,CAAC;AAAA,UAClB,CAAC;AAED,cAAI,aAAa,MAAM;AAEnB,sBAAU,KAAK;AAAA,cACX,MAAM;AAAA,cACN,WAAW,aAAa;AAAA,cACxB,WAAW,aAAa;AAAA,cACxB,cAAc,MAAM;AAAA,cACpB,cAAc,MAAM;AAAA,cACpB,YAAY;AAAA,cACZ,cAAc;AAAA,cACd,cAAc,MAAM;AAAA,cACpB,mBAAmB;AAAA,cACnB,eAAe;AAAA;AAAA,cACf,aAAa,CAAC;AAAA,YAClB,CAAC;AAAA,UACL;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA,EACA,kCAAkC,QAAqC;AACnE,UAAM,YAAgC,CAAC;AAEvC,eAAW,SAAS,QAAQ;AAExB,YAAM,iBAAiB,MAAM,OAAO,OAAO,OAAK,EAAE,SAAS,YAAY,CAAC,EAAE,MAAM;AAChF,YAAM,eAAe,MAAM,OAAO,OAAO,OAAK,EAAE,SAAS,QAAQ;AAGjE,UAAI,eAAe,WAAW,GAAG;AAC7B;AAAA,MACJ;AAGA,YAAM,CAAC,WAAW,SAAS,IAAI;AAC/B,UACI,CAAC,UAAU,oBAAoB,UAC/B,CAAC,UAAU,oBAAoB,QACjC;AACE;AAAA,MACJ;AAGA,YAAM,SAAS,OAAO,KAAK,OAAK,EAAE,SAAS,UAAU,IAAI;AACzD,YAAM,SAAS,OAAO,KAAK,OAAK,EAAE,SAAS,UAAU,IAAI;AACzD,UAAI,CAAC,UAAU,CAAC,QAAQ;AACpB;AAAA,MACJ;AAGA,YAAM,cAAc,MAAM,YAAY,QAAQ;AAAA,QAAM,OAChD,aAAa,KAAK,QAAM,GAAG,SAAS,CAAC;AAAA,MACzC;AAEA,UAAI,CAAC,aAAa;AACd;AAAA,MACJ;AAGA,gBAAU,KAAK;AAAA,QACX,MAAM;AAAA,QACN,WAAW,UAAU,OAAO,IAAI;AAAA;AAAA,QAChC,WAAW,OAAO;AAAA,QAClB,cAAc,OAAO;AAAA,QACrB,cAAc,UAAU;AAAA,QACxB,YAAY,UAAU,mBAAmB,KAAK,IAAI;AAAA,QAClD,cAAc,UAAU,kBAAkB,KAAK,IAAI;AAAA,QACnD,cAAc,UAAU,OAAO,KAAK,YAAY,CAAC;AAAA;AAAA,QACjD,mBAAmB;AAAA,QACnB,eAAe,MAAM;AAAA;AAAA,QACrB,aAAa,CAAC,GAAG,UAAU,oBAAoB,GAAG,UAAU,kBAAkB;AAAA,MAClF,CAAC;AAED,gBAAU,KAAK;AAAA,QACX,MAAM;AAAA,QACN,WAAW,UAAU,OAAO,IAAI;AAAA,QAChC,WAAW,OAAO;AAAA,QAClB,cAAc,OAAO;AAAA,QACrB,cAAc,UAAU;AAAA,QACxB,YAAY,UAAU,mBAAmB,KAAK,IAAI;AAAA,QAClD,cAAc,UAAU,kBAAkB,KAAK,IAAI;AAAA,QACnD,cAAc,UAAU,OAAO,KAAK,YAAY,CAAC;AAAA,QACjD,mBAAmB;AAAA,QACnB,eAAe,MAAM;AAAA;AAAA,QACrB,aAAa,CAAC,GAAG,UAAU,oBAAoB,GAAG,UAAU,kBAAkB;AAAA,MAClF,CAAC;AAGD,gBAAU,KAAK;AAAA,QACX,MAAM;AAAA,QACN,WAAW;AAAA,QACX,WAAW,MAAM;AAAA,QACjB,cAAc,GAAG,OAAO,IAAI,KAAK,OAAO,IAAI;AAAA,QAC5C,cAAc,GAAG,UAAU,YAAY,KAAK,UAAU,YAAY;AAAA,QAClE,YAAY,GAAG,UAAU,mBAAmB,KAAK,IAAI,CAAC,KAAK,UAAU,mBAAmB,KAAK,IAAI,CAAC;AAAA,QAClG,cAAc,GAAG,UAAU,kBAAkB,KAAK,IAAI,CAAC,KAAK,UAAU,kBAAkB,KAAK,IAAI,CAAC;AAAA,QAClG,cAAc,GAAG,UAAU,OAAO,IAAI,CAAC,KAAK,UAAU,OAAO,IAAI,CAAC;AAAA,QAClE,mBAAmB;AAAA,QACnB,eAAe,MAAM;AAAA,QACrB,aAAa,CAAC,GAAG,UAAU,oBAAoB,GAAG,UAAU,kBAAkB;AAAA,MAClF,CAAC;AAAA,IAEL;AAEA,WAAO;AAAA,EACX;AAAA,EACQ,qBAAqB,WAAmD;AAC5E,UAAM,OAAO,oBAAI,IAAY;AAC7B,UAAM,SAA6B,CAAC;AAEpC,eAAW,KAAK,WAAW;AACvB,YAAM,MAAM;AAAA,QACR,EAAE;AAAA,QACF,EAAE;AAAA,QACF,EAAE;AAAA,QACF,EAAE;AAAA,QACF,EAAE;AAAA,QACF,EAAE,cAAc;AAAA,QAChB,EAAE,gBAAgB;AAAA,QAClB,EAAE,gBAAgB;AAAA,QAClB,EAAE,iBAAiB;AAAA,QACnB,EAAE,qBAAqB;AAAA,SACtB,EAAE,eAAe,CAAC,GAAG,KAAK,GAAG;AAAA,MAClC,EAAE,KAAK,GAAG;AAEV,UAAI,CAAC,KAAK,IAAI,GAAG,GAAG;AAChB,aAAK,IAAI,GAAG;AACZ,eAAO,KAAK,CAAC;AAAA,MACjB;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA,EACA,MAAM,iBAAiB,QAA8C;AAEjE,UAAM,uBAAuB,KAAK,kCAAkC,MAAM;AAE1E,UAAM,yBAAyB,IAAI;AAAA,MAC/B,qBACK,OAAO,OAAK,EAAE,cAAc,EAAE,aAAa,EAC3C,IAAI,OAAK,EAAE,SAAS;AAAA,IAC7B;AAGA,UAAM,uBAAuB,KAAK,0BAA0B,MAAM;AAGlE,UAAM,gBAAgB,OAAO,OAAO,OAAK,CAAC,uBAAuB,IAAI,EAAE,IAAI,CAAC;AAG5E,UAAM,oBAAoB,KAAK,wBAAwB,aAAa;AACpE,UAAM,qBAAqB,KAAK,yBAAyB,aAAa;AAGtE,QAAI,YAAgC;AAAA,MAChC,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,IACP;AACA,gBAAY,KAAK,qBAAqB,SAAS;AAC/C,WAAO;AAAA,EACX;AAAA,EACA,MAAM,kBAAkB,QAAgC;AACpD,UAAM,OAAO,SAAS,MAAMC,SAAQ,EAAE,WAAW,OAAO,CAAC,IAAI;AAC7D,UAAM,SAAS,OAAO,KAAK,UAAU,SAAyB,KAAK;AACnE,UAAM,YAAY,KAAK,iBAAiB,MAAM;AAC9C,SAAK,YAAY,MAAM;AAAA,EAC3B;AACJ;AAEO,IAAM,yBAAyB,CAAC,QAAgB,QAAgB,iBAA0B;AAE7F,MAAI,aAAc,QAAO;AAGzB,QAAM,CAAC,OAAO,MAAM,IAAI,CAAC,QAAQ,MAAM,EAAE,KAAK;AAC9C,SAAO,IAAI,WAAW,KAAK,CAAC,KAAK,WAAW,MAAM,CAAC;AACvD;AACO,IAAM,yBAAyB,CAAC,QAAgB,QAAgB,iBAA0B;AAE7F,MAAI,aAAc,QAAO;AAGzB,QAAM,CAAC,OAAO,MAAM,IAAI,CAAC,QAAQ,MAAM,EAAE,KAAK;AAC9C,SAAO,GAAG,WAAW,KAAK,CAAC,KAAK,WAAW,MAAM,CAAC;AACtD;;;AC9eA,OAAO,aAAa;AACpB,OAAOC,YAAW;AAClB,OAAO,WAAW;AAElB,OAAOC,UAAS;AAGhB,OAAOC,SAAQ;AAFf,IAAM,EAAE,SAAAC,SAAQ,IAAIF;AAGpB,IAAM,YAAY,IAAI,0BAA0B;AA+BzC,IAAM,8BAAN,MAAkC;AAAA,EACrC;AAAA,EACA,aAAa,WAA+B;AACxC,SAAK,YAAY;AAAA,EACrB;AAAA,EACA,YAAY,WAAgC;AACxC,QAAI,WAAW;AACX,WAAK,aAAa,SAAS;AAAA,IAC/B;AAAA,EACJ;AAAA,EACA,oBACI,WACA,WACA,UACA,QAAQ,GACR,gBAAgB,oBAAI,IAAY,GACR;AACxB,QAAI,QAAQ,YAAY,cAAc,IAAI,SAAS,GAAG;AAClD,aAAO,EAAE,OAAO,CAAC,GAAG,QAAQ,oBAAI,IAAI,GAAG,WAAW,oBAAI,IAAI,EAAE;AAAA,IAChE;AACA,kBAAc,IAAI,SAAS;AAE3B,QAAI,QAA6B,CAAC;AAClC,QAAI,SAAS,oBAAI,IAAY;AAC7B,QAAI,eAAe,oBAAI,IAAY;AAEnC,UAAM,iBAAiB,UAAU,OAAO,SAAO,IAAI,cAAc,SAAS;AAE1E,QAAI,gBAAwC,CAAC;AAE7C,eAAW,YAAY,gBAAgB;AACnC,YAAM,iBAAiB,SAAS,cAAc,SAAS;AACvD,YAAM,UAAU,SAAS,SAAS,SAAS,SAAS,SAAS,UAAU,CAAC,SAAS;AAEjF,UAAI,eAAqC;AAAA,QACrC,cAAc,SAAS;AAAA,QACvB,OAAO,SAAS,aAAa,SAAS;AAAA,QACtC,MAAM,SAAS;AAAA,QACf,OAAO,SAAS,aAAa,SAAS;AAAA,QACtC,YAAY,SAAS;AAAA,QACrB,cAAc,SAAS;AAAA,QACvB,eAAe,SAAS;AAAA,QACxB,cAAc,SAAS;AAAA,QACvB,aAAa,SAAS,eAAe,CAAC;AAAA,QACtC;AAAA,QACA;AAAA,MACJ;AAEA,aAAO,IAAI,SAAS;AACpB,aAAO,IAAI,SAAS,YAAY;AAChC,mBAAa,IAAI,GAAG,SAAS,OAAO,SAAS,YAAY,EAAE;AAE3D,YAAM,UAAU,KAAK,oBAAoB,SAAS,cAAc,WAAW,UAAU,QAAQ,GAAG,aAAa;AAC7G,UAAI,QAAQ,MAAM,SAAS,GAAG;AAC1B,qBAAa,UAAU,QAAQ,MAAM,CAAC;AAAA,MAC1C;AAEA,oBAAc,KAAK,YAAY;AAAA,IACnC;AAEA,UAAM,KAAK,EAAE,OAAO,WAAW,WAAW,cAAc,CAAC;AAEzD,WAAO,EAAE,OAAO,QAAQ,WAAW,aAAa;AAAA,EACpD;AAAA,EAEA,gBACI,WACA,WACA,UACA,QAAQ,GACR,gBAAgB,oBAAI,IAAY,GAC6C;AAC7E,QAAI,QAAQ,YAAY,cAAc,IAAI,SAAS,EAAG,QAAO,EAAE,OAAO,CAAC,GAAG,QAAQ,oBAAI,IAAI,GAAG,WAAW,oBAAI,IAAI,EAAE;AAClH,kBAAc,IAAI,SAAS;AAE3B,QAAI,QAA+B,CAAC;AACpC,QAAI,SAAS,oBAAI,IAAY;AAC7B,QAAI,eAAe,oBAAI,IAAY;AAEnC,UAAM,iBAAiB,UAAU,OAAO,SAAO,IAAI,cAAc,SAAS;AAE1E,QAAI,QAA6B,CAAC;AAClC,eAAW,YAAY,gBAAgB;AACnC,YAAM,eAAe,SAAS;AAC9B,YAAM,OAAO,SAAS,aAAa,SAAS;AAC5C,YAAM,gBAAgB,OAAO,SAAS,aAAa,SAAS,YAAY;AAExE,YAAM,iBAAiB,SAAS,cAAc,SAAS;AACvD,YAAM,mBAAmB,iBAAiBG,OAAM,OAAO,WAAI,IAAI;AAE/D,UAAI,UAAUA,OAAM,KAAK,KAAK;AAC9B,UAAI,SAAS,YAAY;AACrB,cAAM,YAAY,SAAS,sBAAsB,aAAa,WAAM;AACpE,kBAAU,QAAQA,OAAM,KAAK,SAAS,UAAU,CAAC,IAAI,SAAS,IAAIA,OAAM,MAAM,SAAS,gBAAgB,IAAI,CAAC;AAAA,MAChH,WAAW,SAAS,eAAe;AAC/B,kBAAU,YAAYA,OAAM,OAAO,SAAS,aAAa,CAAC;AAAA,MAC9D;AACA,UAAI,SAAS,iBAAiB,SAAS,kBAAkB,SAAS,WAAW;AACzE,YAAI,CAAC,MAAM,SAAS,aAAa,GAAG;AAChC,gBAAM,SAAS,aAAa,IAAI,CAAC;AAAA,QACrC;AAGA,cAAM,SAAS,aAAa,EACxB,UAAKA,OAAM,OAAO,SAAS,SAAS,CAAC,IAAIA,OAAM,KAAK,SAAS,SAAS,CAAC,SAASA,OAAM,KAAK,SAAS,cAAc,GAAG,CAAC,WAAMA,OAAM,MAAM,SAAS,gBAAgB,GAAG,CAAC,GACzK,IAAI,CAAC;AAEL,cAAM,SAAS,aAAa,EACxB,UAAKA,OAAM,OAAO,SAAS,YAAY,CAAC,IAAIA,OAAM,KAAK,SAAS,YAAY,CAAC,SAASA,OAAM,KAAK,SAAS,cAAc,GAAG,CAAC,WAAMA,OAAM,MAAM,SAAS,gBAAgB,GAAG,CAAC,GAC/K,IAAI,CAAC;AAAA,MACT;AAEA,YAAM,cAAc,UAAU,aAAa,SACrC,gBAAgBA,OAAM,QAAQ,SAAS,YAAY,KAAK,IAAI,CAAC,CAAC,KAC9D;AAEN,YAAM,UAAU,iBAAiB,SAAS,iBAAiB,UAAU,CAAC,UAAU;AAEhF,UAAI,gBAAgB,UAAKA,OAAM,OAAO,SAAS,gBAAgB,SAAS,OAAO,GAAG,CAAC,IAAIA,OAAM,KAAK,IAAI,CAAC,IAAI,aAAa,IAAIA,OAAM,IAAI,YAAY,CAAC,IAAI,OAAO,IAAI,WAAW,IAAI,gBAAgB;AAEjM,UAAI,CAAC,MAAM,aAAa,GAAG;AACvB,cAAM,aAAa,IAAI,CAAC;AAAA,MAC5B;AAGA,aAAO,IAAI,SAAS;AACpB,aAAO,IAAI,SAAS,YAAY;AAChC,mBAAa,IAAI,GAAG,SAAS,OAAO,SAAS,YAAY,EAAE;AAAA,IAC/D;AAEA,UAAM,KAAK,EAAE,CAACA,OAAM,KAAK,SAAS,CAAC,GAAG,MAAM,CAAC;AAE7C,eAAW,YAAY,gBAAgB;AACnC,YAAM,UAAU,KAAK,gBAAgB,SAAS,cAAc,WAAW,UAAU,QAAQ,GAAG,aAAa;AACzG,cAAQ,MAAM,OAAO,QAAQ,KAAK;AAClC,cAAQ,OAAO,QAAQ,OAAK,OAAO,IAAI,CAAC,CAAC;AACzC,cAAQ,UAAU,QAAQ,OAAK,aAAa,IAAI,CAAC,CAAC;AAAA,IACtD;AAEA,WAAO,EAAE,OAAO,QAAQ,WAAW,aAAa;AAAA,EACpD;AAAA,EACA,sBAAsB,WAAmB,WAAmB,GAA+B;AACvF,QAAI,CAAC,KAAK,WAAW,QAAQ;AACzB,YAAM,IAAI,MAAM,+GAA+G;AAAA,IACnI;AAEA,QAAI,gBAAgB,oBAAI,IAAY;AACpC,QAAI,gBAAgB;AAGpB,UAAM,mBAAmB,CAAC,cAAsB,UAAkB;AAC9D,UAAI,QAAQ,YAAY,cAAc,IAAI,YAAY,EAAG;AAEzD,oBAAc,IAAI,YAAY;AAG9B,iBAAW,OAAO,KAAK,UAAU,OAAO,OAAK,EAAE,cAAc,YAAY,GAAG;AACxE;AACA,yBAAiB,IAAI,cAAc,QAAQ,CAAC;AAAA,MAChD;AAAA,IACJ;AAGA,qBAAiB,WAAW,CAAC;AAE7B,WAAO;AAAA,MACH,cAAc,cAAc;AAAA;AAAA,MAC5B,gBAAgB;AAAA;AAAA,MAChB;AAAA;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,0BAA0B,QAAqB,WAAwB,WAAmB,UAAkB;AACxG,UAAM,kBAAkB,YAAY,CAAC,GAAG,SAAS,EAAE,OAAO,OAAK,EAAE,WAAW,SAAS,CAAC,IAAI,CAAC,GAAG,SAAS;AACvG,WAAO;AAAA,MACH,cAAc,OAAO;AAAA,MACrB,gBAAgB,UAAU;AAAA,MAC1B,iBAAiB,gBAAgB;AAAA,MACjC;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,MAAc,2BAA2B,QAAgB;AACrD,UAAM,OAAO,MAAMD,SAAQ,EAAE,WAAW,OAAO,CAAC;AAChD,UAAM,SAAS,KAAK,UAAU;AAC9B,SAAK,aAAa,MAAM,UAAU,UAAU,MAAM,CAAC;AACnD,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,MAAM,4BAA4B,SAAuD;AACrF,UAAM,SAAS,QAAQ,MAAM,EAAE,MAAM,KAAK,CAAC;AAC3C,WAAO,KAAK,2BAA2B,MAAM;AAAA,EACjD;AAAA,EACA,MAAM,2BAA2B,QAAgB;AAC7C,WAAO,KAAK,2BAA2B,MAAM;AAAA,EACjD;AAAA,EACA,MAAM,4BAA4B,YAAoB;AAClD,UAAM,sBAAsBD,IAAG,aAAa,YAAY,OAAO;AAC/D,WAAO,KAAK,2BAA2B,mBAAmB;AAAA,EAC9D;AAAA,EACA,wBACI,WACA,WAAmB,GACnB,WACF;AACE,QAAI,WAAW,QAAQ;AACnB,WAAK,aAAa,SAAS;AAAA,IAC/B;AACA,QAAI,CAAC,KAAK,WAAW,QAAQ;AACzB,YAAM,IAAI,MAAM,qBAAqB;AAAA,IACzC;AAEA,UAAM,EAAE,QAAQ,WAAW,MAAM,MAAM,IAAI,KAAK,gBAAgB,WAAW,KAAK,WAAW,QAAQ;AAGnG,UAAM,QAAQ,KAAK,0BAA0B,QAAQ,MAAM,WAAW,QAAQ;AAE9E,QAAI,SAAS,GAAGE,OAAM,MAAM,KAAK,oCAA6B,CAAC;AAAA;AAC/D,cAAU,GAAGA,OAAM,OAAO,QAAQ,CAAC,IAAIA,OAAM,KAAK,SAAS,CAAC;AAAA;AAC5D,cAAU,GAAGA,OAAM,KAAK,YAAY,CAAC,IAAIA,OAAM,KAAK,QAAQ,CAAC;AAAA;AAC7D,cAAU,GAAGA,OAAM,KAAK,iBAAiB,CAAC,IAAIA,OAAM,KAAK,MAAM,YAAY,CAAC;AAAA;AAC5E,cAAU,GAAGA,OAAM,QAAQ,kBAAkB,CAAC,IAAIA,OAAM,KAAK,MAAM,cAAc,CAAC;AAAA;AAClF,cAAU,GAAGA,OAAM,UAAU,mBAAmB,CAAC,IAAIA,OAAM,KAAK,MAAM,eAAe,CAAC;AAAA;AAGtF,QAAI,aAAa;AACjB,eAAW,QAAQ,OAAO;AACtB,oBAAc,QAAQ,OAAO,MAAM,MAAM,IAAI,IAAI;AAAA,IACrD;AAEA,UAAM,UAAU,CAAC,GAAG,KAAK,OAAO,CAAC,EAAE,OAAO,QAAM;AAC5C,aAAO,GAAG,WAAW,SAAS,KAAK,GAAG,SAAS,SAAS;AAAA,IAC5D,CAAC,EAAE,IAAI,OAAKA,OAAM,KAAK,CAAC,CAAC,EAAE,KAAK,IAAI;AACpC,UAAM,WAAW,GAAGA,OAAM,MAAM,KAAK,4BAAqB,CAAC;AAAA,EAAK,OAAO;AAGvE,WAAO,MAAM,OAAO,KAAK,IAAI,OAAO,WAAW,KAAK,IAAI;AAAA;AAAA,EAAO,QAAQ,IAAI;AAAA,MACvE,SAAS;AAAA,MACT,aAAa;AAAA,MACb,aAAa;AAAA,IACjB,CAAC;AAAA,EACL;AACJ;AAGO,IAAM,wBAAwB,CAAC,WAA+B,WAAmB,WAAmB,MAAkC;AAEzI,MAAI,gBAAgB,oBAAI,IAAY;AACpC,MAAI,gBAAgB;AAGpB,QAAM,mBAAmB,CAAC,cAAsB,UAAkB;AAC9D,QAAI,QAAQ,YAAY,cAAc,IAAI,YAAY,EAAG;AAEzD,kBAAc,IAAI,YAAY;AAG9B,eAAW,OAAO,UAAU,OAAO,OAAK,EAAE,cAAc,YAAY,GAAG;AACnE;AACA,uBAAiB,IAAI,cAAc,QAAQ,CAAC;AAAA,IAChD;AAAA,EACJ;AAGA,mBAAiB,WAAW,CAAC;AAE7B,SAAO;AAAA,IACH,cAAc,cAAc;AAAA;AAAA,IAC5B,gBAAgB;AAAA;AAAA,IAChB;AAAA;AAAA,EACJ;AACJ;;;ACrTA,OAAOC,YAAW;;;ACoBX,IAAM,kBAAkB,CAAC,QAG3B;AACD,SAAO;AAAA,IACH,OAAO,CAAC,UAA0B;AAC9B,aAAO,EAAE,KAAK,MAAM;AAAA,IACxB;AAAA,IACA,QAAQ,CAAC,WAAgB;AACrB,aAAO;AAAA,QACH;AAAA,QAAK;AAAA,MACT;AAAA,IACJ;AAAA,EACJ;AACJ;AAEO,IAAM,0BAAN,MAAoH;AAAA,EAC7G,WAAqD,CAAC;AAAA,EAEhE,YACI,iBACF;AACE,QAAI,iBAAiB;AACjB,WAAK,WAAW,EAAE,GAAG,gBAAgB;AAAA,IACzC;AAAA,EACJ;AAAA,EAEA,SAAS,QAAW,SAAY,SAAmC;AAC/D,SAAK,SAAS,SAAS,MAAM,OAAiB,IAAI;AAAA,EACtD;AAAA,EAEA,QAAQ,QAAW,SAAY,aAAwC,KAAiC;AACpG,UAAM,UAAU,KAAK,SAAS,SAAS,MAAM,OAAiB;AAC9D,QAAI,CAAC,SAAS;AACV,YAAM,IAAI,MAAM,wBAAwB,OAAO,cAAc;AAAA,IACjE;AACA,WAAO,QAAQ,aAAc,GAAG;AAAA,EACpC;AACJ;;;ADnDA,SAAS,qBAAAC,0BAAyB;AAClC,IAAM,wBAAwB,IAAIA,mBAAkB;AAO7C,IAAM,mBAAN,MAAuB;AAAA,EAClB;AAAA,EACA;AAAA,EACA;AAAA,EACA,gBAAwF,CAAC;AAAA,EAEjG,YAAY,QAIT;AACC,SAAK,eAAe,OAAO;AAC3B,SAAK,kBAAkB,OAAO;AAC9B,SAAK,SAAS,OAAO;AAAA,EACzB;AAAA,EAEA,MAAM,WAAW,UAA6B,UAAmC,CAAC,GAAuC;AACrH,UAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,WAAW,SAAS,MAAM,GAAG,EAAE,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE,OAAO,CAAC,MAAM,EAAE,SAAS,CAAC,EAAE,IAAI,CAAC,MAAM,IAAI,GAAG;AAClJ,UAAM,YAGD,CAAC;AAEN,eAAW,WAAW,eAAe;AACjC,UAAI;AACA,cAAM,SAAS,MAAM,KAAK,MAAM,OAAO;AACvC,YAAI,QAAQ,UAAU,OAAO;AACzB,gBAAM,IAAI,MAAM,aAAa,OAAO,OAAO,SAAS,QAAQ,OAAO,SAAS,QAAQ,wBAAwB;AAAA,QAChH;AACA,kBAAU,KAAK,MAAM;AAAA,MACzB,SAAS,GAAG;AACR,gBAAQ,IAAIC,OAAM,IAAI,6BAA6B,EAAE,OAAO,EAAE,CAAC;AAC/D,cAAM;AAAA,MACV;AAAA,IACJ;AACA,UAAM,eAAe,UAAU,KAAK,CAAC,MAAM,EAAE,cAAc,SAAS,UAAU;AAC9E,QAAI,QAAQ,WAAW,QAAQ,QAAQ,gBAAgB,CAAC,QAAQ,QAAQ;AACpE,YAAM,YAAY,MAAM,QAAQ,QAAQ,sBAAsB,UAAU,KAAK,OAAO,MAAM,CAAC,CAAC;AAC5F,UAAI,WAAW;AACX,cAAM,KAAK,KAAK;AAAA,MACpB;AAAA,IACJ;AACA,WAAO,UAAU,IAAI,CAAC,MAAM,EAAE,QAAQ;AAAA,EAC1C;AAAA,EAEA,MAAM,MAAiE,OAAgG,SAGpK;AACC,UAAM,gBAAgB,aAAa,OAAO,QAAQ,KAAK,aAAyC,KAAK,IAAI;AACzG,QAAI,cAAc,SAAS,SAAS;AAChC,aAAO;AAAA,QACH;AAAA,QACA,UAAU,MAAM,KAAK,MAAM,aAAuF;AAAA,MACtH;AAAA,IACJ;AACA,QAAI,cAAc,SAAS,YAAY;AACnC,aAAO;AAAA,QACH;AAAA,QACA,UAAU,MAAM,KAAK,SAAS,eAA+F,OAAO;AAAA,MACxI;AAAA,IACJ;AACA,UAAM,IAAI,MAAM,8DAA8D,cAAc,IAAI,GAAG;AAAA,EACvG;AAAA,EAEA,MAAM,MAAsE,OAA0H;AAClM,UAAM,gBAAgB,aAAa,OAAO,QAAQ,KAAK,aAA4B,KAAK,IAAI;AAC5F,QAAI,cAAc,SAAS,SAAS;AAChC,YAAM,IAAI,MAAM,gDAAgD,cAAc,IAAI,GAAG;AAAA,IACzF;AACA,QAAI,CAAC,cAAc,SAAS;AACxB,YAAM,UAAU,cAAc,WAAW;AACzC,YAAM,aAAa,cAAc,WAAW;AAC5C,UAAI,CAAC,WAAW,CAAC,YAAY;AACzB,cAAM,IAAI,MAAM,sCAAsC;AAAA,MAC1D;AACA,UAAI,SAAS;AACT,eAAO,gBAAgB,aAAa,EAAE,OAAO,KAAK,OAAO,MAAM,CAAC;AAAA,MACpE;AACA,UAAI,YAAY;AACZ,eAAO,gBAAgB,aAAa,EAAE,OAAO,MAAM,KAAK,OAAO,QAAQ,CAAC;AAAA,MAC5E;AAAA,IACJ;AACA,WAAO,KAAK,aAAa,QAAQ,cAAc,QAAQ,cAAc,SAAU,KAAK,OAAO,iBAAiB,GAAG,aAAa;AAAA,EAChI;AAAA,EAEA,MAAM,YAA+E,OAA+G;AAChM,UAAM,gBAAgB,YAAY,OAAO,QAAQ,KAAK,aAA+B,KAAK,IAAI;AAC9F,QAAI,cAAc,SAAS,YAAY;AACnC,YAAM,IAAI,MAAM,mDAAmD,cAAc,IAAI,GAAG;AAAA,IAC5F;AACA,UAAM,QAAQ,KAAK,OAAO,iBAAiB;AAE3C,UAAM,iBAAiB,GAAG,cAAc,MAAM,IAAI,cAAc,OAAO;AACvE,QAAI;AACA,YAAM,SAAS,MAAM,KAAK,gBAAgB,QAAQ,cAAc,QAAQ,cAAc,SAAU,OAAO,aAAa;AACpH,UAAI,QAAQ,OAAO;AACf,YAAI,aAAa,OAAO,OAAO,OAAO;AAClC,gBAAM,IAAI,MAAM,OAAO,KAAK;AAAA,QAChC,OAAO;AACH,gBAAM,OAAO;AAAA,QACjB;AAAA,MACJ;AACA,cAAQ,IAAI,UAAKA,OAAM,KAAK,cAAc,GAAGA,OAAM,MAAM,kBAAkB,CAAC;AAAA,IAChF,SAAS,GAAG;AACR,YAAM,IAAI,MAAM,wBAAwB,EAAE,OAAO,EAAE;AAAA,IACvD;AAGA,UAAM,gBAAgB,MAAM,QAAQ,MAAM,EAAE,MAAM,KAAK,CAAC;AACxD,UAAM,aAAa,MAAM,qBAAqB,aAAa;AAC3D,QAAI,sBAAsB,OAAO;AAC7B,YAAM,IAAI,MAAM,wBAAwB,WAAW,OAAO,EAAE;AAAA,IAChE;AACA,YAAQ,IAAI,UAAKA,OAAM,KAAK,cAAc,GAAGA,OAAM,MAAM,qBAAqB,CAAC;AAC/E,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,SAA4E,OAA8F,UAAmC,CAAC,GAAqC;AACrP,UAAM,gBAAgB,aAAa,OAAO,QAAQ,KAAK,aAA+B,KAAK,IAAI;AAC/F,QAAI,cAAc,SAAS,YAAY;AACnC,YAAM,IAAI,MAAM,mDAAmD,cAAc,IAAI,GAAG;AAAA,IAC5F;AAEA,UAAM,gBAAgB,MAAM,KAAK,YAAkB,KAAK;AACxD,QAAI,CAAC,eAAe;AAChB,aAAO,gBAAgB,aAAa,EAAE,MAAM,gBAAgB;AAAA,IAChE;AAEA,QAAI,QAAQ,QAAQ;AAChB,aAAO,gBAAgB,aAAa,EAAE,OAAO,sBAAsB,UAAU,aAAa,CAAC;AAAA,IAC/F;AACA,QAAI,QAAQ,SAAS;AACjB,YAAM,UAAU,GAAG,sBAAsB,UAAU,aAAa,CAAC;AACjE,YAAM,YAAY,MAAM,QAAQ,QAAQ,OAAO;AAC/C,UAAI,CAAC,WAAW;AACZ,eAAO,gBAAgB,aAAa,EAAE,MAAM,wBAAwB;AAAA,MACxE;AAAA,IACJ;AAEA,QAAI;AACA,YAAM,QAAQ,MAAM,KAAK,OAAO,SAAS;AACzC,WAAK,gBAAgB,QAAQ,cAAc,QAAQ,cAAc,SAAU,OAAO,aAAa;AAE/F,WAAK,cAAc,KAAK,aAAa;AAErC,YAAM,iBAAiB,GAAG,cAAc,MAAM,IAAI,cAAc,OAAO;AACvE,cAAQ,IAAI,UAAKA,OAAM,MAAM,cAAc,GAAGA,OAAM,MAAM,kBAAkB,CAAC;AAAA,IACjF,SAAS,GAAG;AACR,YAAM,IAAI,MAAM,wBAAwB,EAAE,OAAO,EAAE;AAAA,IACvD;AAEA,QAAI,QAAQ,MAAM;AACd,YAAM,KAAK,KAAK;AAAA,IACpB;AACA,UAAM,KAAK,OAAO,OAAO;AACzB,WAAO,gBAAgB,aAAa,EAAE,OAAO,sBAAsB,UAAU,aAAa,CAAC;AAAA,EAC/F;AAAA,EAEA,MAAM,OAAsB;AACxB,QAAI,KAAK,cAAc,WAAW,GAAG;AACjC;AAAA,IACJ;AACA,UAAM,WAAW,KAAK,cAAc,IAAI,CAAC,aAAa,SAAS,GAAG;AAClE,SAAK,OAAO,KAAK,QAAQ;AACzB,SAAK,gBAAgB,CAAC;AAAA,EAC1B;AAAA,EAEQ,aAAwG,OAA2C;AACvJ,WAAO,eAAe,aAAa,KAAK;AAAA,EAC5C;AACJ;;;AErLO,SAAS,oBAAoB,OAAc,WAA+C;AAC7F,QAAM,SAAS,OAAO,YAAY;AAAA,IAC9B,CAAC,SAA2B,KAAK,SAAS,YAEpC,MAAM,YAAY,KAAK,UAAQ,KAAK,SAAS,QAAQ,MAAM,QAAU,MAAM,YAAY,KAAK,UAAQ,KAAK,SAAS,IAAI,MAAM;AAAA,EAEtI,KAAK,CAAC;AAEN,SAAO,OAAO,IAAI,CAAC,UAAe;AAC9B,UAAM,OAAO,OAAO,YAAY,KAAK,CAAC,SAAc,KAAK,SAAS,IAAI,KAAK;AAC3E,UAAM,WAAW,OAAO,YAAY,KAAK,CAAC,SAAc,KAAK,SAAS,QAAQ,KAAK;AACnF,QAAI;AACJ,QAAI,YAAY,MAAM;AAEtB,cAAU,KAAK,CAAC,QAAQ;AACpB,UAAI,IAAI,cAAc,MAAM,MAAM;AAC9B,YAAI,IAAI,cAAc,MAAM,QAAQ,IAAI,eAAe,MAAM,MAAM;AAC/D,qBAAW;AACX,sBAAY,GAAG,IAAI,YAAY;AAAA,QACnC;AAAA,MACJ;AAAA,IACJ,CAAC;AACD,QAAI,MAAM;AACN,YAAM,UAAU,OAAO,YAAY,KAAK,CAAC,SAAc,KAAK,SAAS,SAAS,GAAG,KAAK,CAAC,GAAG;AAC1F,UAAI,SAAS,SAAS,YAAY;AAC9B,oBAAY,QAAQ;AAAA,MACxB;AAAA,IACJ;AACA,WAAO;AAAA,MACH,MAAM,MAAM;AAAA,MACZ,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,YAAY,CAAC,CAAC;AAAA,IAClB;AAAA,EACJ,CAAC;AACL;;;AChCO,SAAS,qBAAqB,MAAgB;AACjD,MAAI,KAAK,SAAS,QAAS,QAAO;AAElC,QAAM,EAAE,MAAM,WAAW,OAAO,UAAU,WAAW,IAAI;AAEzD,MAAI,OAAO,SAAS,YAAY,OAAO,cAAc,SAAU,QAAO;AAGtE,MAAI,YAAY,KAAK,UAAQ,KAAK,SAAS,UAAU,EAAG,QAAO;AAG/D,MAAI,kBAAkB;AACtB,MAAI,SAAU,oBAAmB;AACjC,MAAI,MAAO,oBAAmB;AAG9B,QAAM,mBAAoD,CAAC;AAC3D,aAAW,QAAQ,cAAc,CAAC,GAAG;AACjC,QAAI,WAAW,KAAK,MAAM,IAAI,SAAO,IAAI,KAAK,KAAK,CAAC;AACpD,qBAAiB,KAAK,EAAE,MAAM,KAAK,MAAM,MAAM,SAAS,CAAC;AAAA,EAC7D;AAGA,SAAO;AAAA,IACH;AAAA,IACA,WAAW;AAAA,IACX,YAAY;AAAA,IACZ,YAAY;AAAA,EAChB;AACJ;AAEO,IAAM,uBAAN,MAA2B;AAAA,EACtB;AAAA,EAER,YAAY,cAAsB;AAC9B,SAAK,eAAe;AAAA,EACxB;AAAA,EACA,UAAU,OAAgC;AACtC,UAAM,SAAS,KAAK,aAAa,KAC5B,OAAO,CAAC,SAAwB,KAAK,SAAS,OAAO;AAC1D,QAAI,OAAO,QAAQ;AACf,aAAO,OAAO,OAAO,CAAC,UAAU,MAAM,SAAS,MAAM,IAAI,CAAC;AAAA,IAC9D;AACA,WAAO;AAAA,EACX;AAAA,EAEA,eAAe,MAAiC;AAC5C,WAAO,KAAK,UAAU,EAAE,KAAK,CAAC,UAAU,MAAM,SAAS,IAAI;AAAA,EAC/D;AAAA,EAEA,eAAe,WAAmB,WAAsC;AACpE,UAAM,QAAQ,KAAK,eAAe,SAAS;AAC3C,QAAI,CAAC,MAAO,QAAO;AACnB,WAAO,MAAM,WAAW,KAAK,CAAC,SAAwB,KAAK,SAAS,WAAW,KAAK,SAAS,SAAS;AAAA,EAC1G;AAAA,EACA,UAAU,WAA4B;AAClC,UAAM,QAAQ,KAAK,eAAe,SAAS;AAC3C,QAAI,CAAC,MAAO,QAAO,CAAC;AACpB,WAAO,MAAM,WAAW,OAAO,CAAC,SAAwB,KAAK,SAAS,OAAO;AAAA,EACjF;AAAA,EAEA,oBAAoB,WAAuC;AACvD,UAAM,QAAQ,KAAK,eAAe,SAAS;AAC3C,QAAI,CAAC,MAAO,QAAO;AACnB,UAAM,UAAU,MAAM,WAAW,KAAK,CAAC,SAAwB,KAAK,SAAS,WAAY,MAAgB,YAAY,KAAK,UAAQ,KAAK,SAAS,IAAI,CAAE;AACtJ,WAAO,SAAS;AAAA,EACpB;AAAA,EAEA,WAAmB;AACf,WAAO,KAAK,aAAa,KACpB,OAAO,CAAC,SAAuB,KAAK,SAAS,MAAM;AAAA,EAC5D;AAAA,EAEA,cAAc,MAAgC;AAC1C,WAAO,KAAK,SAAS,EAAE,KAAK,CAAC,aAAa,SAAS,SAAS,IAAI;AAAA,EACpE;AAAA,EAEA,iBAAiB,UAGd;AACC,UAAM,SAAS,KAAK,UAAU;AAC9B,WAAO,OAAO,OAAO,CAAC,UAAU;AAC5B,aAAO,MAAM,WAAW,KAAK,CAAC,SAAwB;AAClD,eAAO,KAAK,SAAS,WAAW,KAAK,cAAc;AAAA,MACvD,CAAC;AAAA,IACL,CAAC,EAAE,IAAI,CAAC,UAAU;AACd,YAAM,QAAQ,MAAM,WAAW,KAAK,CAAC,SAAwB;AACzD,eAAO,KAAK,SAAS,WAAW,KAAK,cAAc;AAAA,MACvD,CAAC;AACD,aAAO;AAAA,QACH;AAAA,QACA;AAAA,MACJ;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EAEA,eAAwB;AACpB,WAAO,KAAK,UAAU,EACjB,QAAQ,CAAC,UAAU,MAAM,UAAU,EACnC,OAAO,CAAC,SAAwB,KAAK,SAAS,WAAW,KAAK,cAAc,UAAU;AAAA,EAC/F;AAAA,EAEA,gBAAyB;AACrB,WAAO,KAAK,aAAa,KACpB,OAAO,CAAC,SAAwB,KAAK,SAAS,WAAW;AAAA,EAClE;AAAA,EAEA,kBAAkB,WAA4B;AAC1C,UAAM,QAAQ,KAAK,eAAe,SAAS;AAC3C,QAAI,CAAC,MAAO,QAAO,CAAC;AACpB,WAAO,MAAM,WAAW;AAAA,MACpB,CAAC,SAAwB,KAAK,SAAS,WAAW,KAAK,cAAc;AAAA,IACzE;AAAA,EACJ;AACJ;AAEO,IAAM,YAAY,CAAC,WAAwC;AAC9D,SAAO,IAAI,qBAAqB,UAAU,SAAS,SAAS,OAAO,GAAG;AAC1E;;;AC7HO,IAAM,+BAAN,cAA2C,wBAA6E;AAAA,EAC3H,YACI,iBACF;AACE,UAAM,eAAe;AAAA,EACzB;AACJ;;;ACLO,IAAM,kCAAN,cAA8C,wBAAmF;AAAA,EACpI,YACI,iBACF;AACE,UAAM,eAAe;AAAA,EACzB;AACJ;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,OAAOC,YAAW;AAGlB,OAAOC,YAAW;;;ACHlB,OAAOC,YAAW;AAGlB,OAAOC,YAAW;AAMX,IAAM,gBAAgB,CAAC,OAAiB,UAAU,MAAM;AAC3D,QAAM,cAAc,KAAK,IAAI,GAAG,MAAM,IAAI,UAAQ,KAAK,MAAM,CAAC,IAAI;AAClE,QAAM,OAAO,KAAK,KAAK,MAAM,SAAS,OAAO;AAC7C,MAAI,SAAS;AAEb,WAAS,IAAI,GAAG,IAAI,MAAM,KAAK;AAC3B,QAAI,WAAW,CAAC;AAChB,aAAS,IAAI,GAAG,IAAI,SAAS,KAAK;AAC9B,YAAM,QAAQ,IAAI,IAAI;AACtB,UAAI,QAAQ,MAAM,QAAQ;AACtB,iBAAS,KAAK,MAAM,KAAK,EAAE,OAAO,WAAW,CAAC;AAAA,MAClD;AAAA,IACJ;AACA,cAAU,SAAS,KAAK,IAAI,IAAI;AAAA,EACpC;AACA,SAAO,OAAO,KAAK;AACvB;AAMO,IAAM,iBAAiB,CAAC,eAAyB;AACpD,aAAW,KAAK,CAAC,GAAG,MAAM,EAAE,cAAc,CAAC,CAAC;AAChD;AAEO,IAAM,gBAAgE,CAAC,aAAa,SAAS;AAChG,QAAM,WAAW,gBAAgB,IAAI;AAErC,QAAM,SAAS,UAAU,WAAW,EAAE,UAAU;AAChD,MAAI,OAAO,WAAW,GAAG;AACrB,WAAO,SAAS,OAAOC,OAAM,IAAI,KAAK,oCAA+B,CAAC;AAAA,EAC1E;AACA,QAAM,aAAa,OAAO,IAAI,WAAS,MAAM,IAAI;AACjD,iBAAe,UAAU;AAGzB,QAAM,UAAU,WAAW,SAAS,IAAI,IAAI;AAG5C,QAAM,QAAQ,GAAGA,OAAM,MAAM,yBAAkB,CAAC,IAAIA,OAAM,MAAM,KAAK,WAAW,MAAM,CAAC;AAGvF,QAAM,kBAAkB,cAAc,WAAW,IAAI,UAAQ,GAAGA,OAAM,IAAI,SAAS,EAAE,QAAG,CAAC,IAAIA,OAAM,KAAK,IAAI,CAAC,EAAE,GAAG,OAAO;AAGzH,SAAO,SAAS,OAAOD,OAAM,GAAG,KAAK;AAAA;AAAA,EAAO,eAAe,IAAI;AAAA,IAC3D,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,aAAa;AAAA,IACb,aAAa;AAAA,IACb,OAAO;AAAA,IACP,gBAAgB;AAAA,EACpB,CAAC,CAAC;AACN;;;ADxDO,IAAM,mBAAsE,CAAC,aAAa,SAAS;AACtG,QAAM,WAAW,gBAAgB,IAAI;AACrC,QAAM,SAAS,UAAU,WAAW;AACpC,QAAM,EAAE,KAAK,IAAI;AAEjB,QAAM,WAAW,MAAM,QAAQ,CAAC;AAChC,MAAI,CAAC,UAAU;AACX,WAAO,SAAS,MAAM,yEAAyE;AAAA,EACnG;AAEA,QAAM,QAAQ,OAAO,cAAc,QAAQ;AAC3C,MAAI,CAAC,OAAO;AACR,WAAO,SAAS,MAAM,QAAQ,QAAQ,YAAY;AAAA,EACtD;AACA,QAAM,YAAY,OAAO,iBAAiB,QAAQ;AAElD,QAAM,QAAQ,UAAU;AACxB,MAAI,CAAC,OAAO;AACR,WAAO,SAAS,OAAO,QAAQ,QAAQ,mBAAmB;AAAA,EAC9D;AACA,QAAM,UAAU,UAAU,SAAS,IAAI,IAAI;AAC3C,QAAM,kBAAkB,cAAc,UAAU,IAAI,SAAO,GAAGE,OAAM,IAAI,SAAS,EAAE,QAAG,CAAC,IAAIA,OAAM,KAAK,IAAI,MAAM,IAAI,CAAC,OAAOA,OAAM,KAAK,IAAI,MAAM,IAAI,CAAC,EAAE,GAAG,OAAO;AAClK,QAAM,QAAQ,GAAGA,OAAM,MAAM,4BAAqB,CAAC,IAAIA,OAAM,MAAM,KAAK,KAAK,CAAC;AAE9E,SAAO,SAAS,OAAOC,OAAM,GAAG,KAAK;AAAA;AAAA,EAAO,eAAe,IAAI;AAAA,IAC3D,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,aAAa;AAAA,IACb,aAAa;AAAA,EACjB,CAAC,CAAC;AAEN;;;AEtCA,SAAS,mBAA8C;AAGvD,OAAOC,YAAW;AAClB,SAAS,qBAAAC,0BAAyB;AAClC,OAAOC,YAAW;AAElB,IAAMC,yBAAwB,IAAIF,mBAAkB;AAE7C,IAAM,WAAqD,CAAC,aAAa,SAAS;AACrF,QAAM,WAAW,gBAAgB,IAAI;AACrC,QAAM,UAAU,KAAK;AACrB,QAAM,SAAS,UAAU,WAAW;AACpC,MAAI,QAAQ,OAAO,SAAS;AAC5B,QAAM,YAAY,KAAK,MAAM,SAAS,CAAC;AACvC,MAAI,UAAU,UAAU,CAAC,UAAU,SAAS,GAAG,GAAG;AAC9C,YAAQ,MAAM,OAAO,OAAK,UAAU,SAAS,EAAE,IAAI,CAAC;AAAA,EACxD;AACA,MAAI,CAAC,MAAM,QAAQ;AACf,WAAO,SAAS,OAAOC,OAAM,OAAO,uBAAkB,CAAC;AAAA,EAC3D;AACA,QAAM,aAAa,MAAM;AACzB,QAAM,YAAY,8BAAuBA,OAAM,KAAK,UAAU,CAAC;AAE/D,MAAI,SAAS,KAAK;AACd,UAAM,SAAiB;AAAA,MACnB,MAAM;AAAA,MACN,MAAM;AAAA,IACV;AACA,UAAM,SAAS,YAAY,MAAM;AACjC,UAAM,YAAYC,uBAAsB,UAAU,MAAM;AACxD,WAAO,SAAS,OAAOH,OAAM,GAAG,SAAS;AAAA,EAAK,SAAS,IAAI;AAAA,MACvD,SAAS;AAAA,MACT,OAAO;AAAA,MACP,aAAa;AAAA,MACb,OAAO;AAAA,MACP,gBAAgB;AAAA,IACpB,CAAC,CAAC;AAAA,EACN;AAEA,QAAM,OAGA,CAAC;AAEP,QAAM,QAAQ,OAAK;AACf,SAAK,KAAK;AAAA,MACN,MAAME,OAAM,MAAM,KAAK,EAAE,IAAI;AAAA,MAC7B,SAAS,EAAE,aAAa,OAAO,CAAAE,OAAKA,GAAE,QAAQ,YAAY,EAAE,IAAI,CAAC,OAAmBF,OAAM,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC;AAAA,IACnH,CAAC;AAAA,EACL,CAAC;AAED,QAAM,eAAe,KAAK,IAAI,OAAK;AAC/B,WAAO,GAAG,EAAE,IAAI;AAAA,EAAK,EAAE,QAAQ,KAAK,IAAI,CAAC;AAAA;AAAA,EAC7C,CAAC;AAED,SAAO,SAAS,OAAOF,OAAM,GAAG,SAAS;AAAA,EAAK,aAAa,KAAK,IAAI,CAAC,IAAI;AAAA,IACrE,SAAS;AAAA,IACT,aAAa;AAAA,IACb,OAAO;AAAA,IACP,gBAAgB;AAAA,EACpB,CAAC,CAAC;AACN;;;AC3DA,OAAOK,YAAW;AAClB,OAAOC,YAAW;AAClB,OAAO,WAAW;AACX,IAAM,YAAuD,CAAC,aAAa,SAAS;AACvF,QAAM,WAAW,gBAAgB,IAAI;AACrC,QAAM,EAAE,KAAK,IAAI;AAEjB,QAAM,SAAS,UAAU,WAAW;AAGpC,QAAM,YAAY,MAAM,SAAS,CAAC;AAClC,MAAI,CAAC,WAAW;AACZ,WAAO,SAAS,MAAM,0HAAqH;AAAA,EAC/I;AAEA,QAAM,QAAQ,OAAO,eAAe,SAAS;AAC7C,MAAI,CAAC,OAAO;AACR,WAAO,SAAS,MAAM,gBAAW,SAAS,YAAY;AAAA,EAC1D;AAEA,MAAI,SAAS,OAAO,UAAU,SAAS;AAEvC,MAAI,CAAC,OAAO,QAAQ;AAChB,WAAO,SAAS,OAAOA,OAAM,OAAO,mCAA8B,SAAS,EAAE,CAAC;AAAA,EAClF;AAEA,QAAM,cAAc,MAAM,UAAU,CAAC;AAErC,MAAI,YAAY,UAAU,CAAC,YAAY,SAAS,GAAG,GAAG;AAClD,aAAS,OAAO,OAAO,WAAS,YAAY,SAAS,MAAM,IAAI,CAAC;AAAA,EACpE;AAEA,MAAI,CAAC,OAAO,QAAQ;AAChB,WAAO,SAAS,OAAOA,OAAM,OAAO,mCAA8B,SAAS,qBAAqB,CAAC;AAAA,EACrG;AAEA,QAAM,UAAU,OAAO,KAAK,OAAK,EAAE,YAAY,KAAK,UAAQ,KAAK,SAAS,IAAI,CAAC,GAAG;AAElF,QAAM,QAAQ,IAAI,MAAM;AAAA,IACpB,MAAM;AAAA,MACFA,OAAM,KAAK,YAAY;AAAA,MACvBA,OAAM,KAAK,MAAM;AAAA,MACjBA,OAAM,KAAK,UAAU;AAAA,MACrBA,OAAM,KAAK,OAAO;AAAA,MAClBA,OAAM,KAAK,UAAU;AAAA,MACrBA,OAAM,KAAK,YAAY;AAAA,IAC3B;AAAA,IACA,WAAW,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE;AAAA,IAClC,OAAO,EAAE,MAAM,CAAC,MAAM,EAAE;AAAA,EAC5B,CAAC;AACD,QAAM,EAAE,UAAU,IAAI;AAEtB,MAAI,iBAAiB;AACrB,SAAO,QAAQ,CAAC,UAAiB;AAC7B,QAAI,OAAOA,OAAM,YAAY,MAAM,IAAI;AACvC,UAAM,OAAOA,OAAM,WAAW,MAAM,SAAS;AAC7C,UAAM,WAAW,MAAM,WAAWA,OAAM,UAAU,IAAI,IAAIA,OAAM,YAAY,KAAK;AACjF,UAAM,QAAQ,MAAM,QAAQA,OAAM,aAAa,KAAK,IAAIA,OAAM,KAAK,IAAI;AACvE,QAAI,cAAc,MAAM,YAAY,KAAK,UAAQ,KAAK,SAAS,UAAU;AACzE,QAAI,WAAW,cACTA,OAAM,cAAc,KAAK,IACzBA,OAAM,KAAK,IAAI;AAErB,UAAM,QAAQ,CAAC,UAAU,MAAM,SAAS;AACxC,UAAM,aAAa,MAAM,YAAY;AAAA,MACjC,UAAQ,MAAM,SAAS,KAAK,IAAI;AAAA,IACpC,EAAE,IAAI,UAAQ;AACV,UAAI,MAAM,SAAS,KAAK,IAAI,KAAK,MAAM,QAAS,KAAa,IAAI,GAAG;AAChE,cAAM,MAAO,KAAa,KAAK,CAAC;AAChC,YAAI,YAAY,OAAO,IAAI,OAAO;AAC9B,iBAAO,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK;AAAA,QACrC;AACA,YAAI,YAAY,OAAO,IAAI,OAAO;AAC9B,iBAAO,IAAI,KAAK,IAAI,IAAI,IAAI,MAAM,IAAI;AAAA,QAC1C;AAAA,MACJ;AACA,aAAO,IAAI,KAAK,IAAI;AAAA,IACxB,CAAC,EAAE,KAAK,IAAI,KAAKA,OAAM,KAAK,MAAM;AAGlC,eAAW,OAAO,WAAW;AACzB,UAAI,IAAI,cAAc,MAAM,MAAM;AAC9B,YAAI,IAAI,cAAc,MAAM,MAAM;AAC9B,qBAAWA,OAAM,cAAc,IAAI,YAAY;AAC/C,wBAAc;AAAA,QAClB;AACA,YAAI,IAAI,eAAe,MAAM,MAAM;AAC/B,qBAAWA,OAAM,QAAQ,GAAG,IAAI,YAAY,OAAO;AAAA,QACvD;AAAA,MACJ;AAAA,IACJ;AACA,QAAI,aAAa;AACb;AAAA,IACJ;AAEA,QAAI,MAAM,QAAQ,SAAS;AACvB,aAAO,GAAGA,OAAM,cAAc,MAAM,MAAM,IAAI,CAAC;AAAA,IACnD;AACA,UAAM,KAAK,CAAC,MAAM,MAAM,UAAU,OAAO,UAAU,UAAU,CAAC;AAAA,EAClE,CAAC;AAED,QAAM,mBAAmB,OAAO;AAGhC,QAAM,YAAY;AAAA,gCACGA,OAAM,KAAK,SAAS,CAAC;AAAA,0BACpBA,OAAM,KAAK,gBAAgB,CAAC;AAAA,6BACzBA,OAAM,KAAK,cAAc,CAAC;AAAA;AAGnD,SAAO,SAAS,OAAOD,OAAM,GAAG,SAAS;AAAA,EAAK,MAAM,SAAS,CAAC,IAAI;AAAA,IAC9D,SAAS;AAAA,IACT,aAAa;AAAA,IACb,OAAO;AAAA,IACP,gBAAgB;AAAA,EACpB,CAAC,CAAC;AACN;;;ACvHA,OAAOE,YAAW;AAElB,SAAS,eAAAC,oBAA2B;AAGpC,SAAS,qBAAAC,0BAAyB;AAElC,OAAOC,YAAW;AAClB,IAAMC,yBAAwB,IAAIC,mBAAkB;AAW7C,IAAM,WAAqD,CAAC,aAAa,SAAS;AACrF,QAAM,EAAE,KAAK,IAAI;AACjB,QAAM,WAAW,gBAAgB,IAAI;AAErC,QAAM,YAAY,MAAM,SAAS,CAAC;AAClC,MAAI,CAAC,WAAW;AACZ,WAAO,SAAS,MAAM,6DAA6D;AAAA,EACvF;AAGA,QAAM,QAAQ,UAAU,WAAW,EAAE,eAAe,SAAS;AAC7D,MAAI,CAAC,OAAO;AACR,WAAO,SAAS,MAAM,SAAS,SAAS,YAAY;AAAA,EACxD;AAEA,QAAM,SAAyB,oBAAoB,OAAO,YAAY,SAAS;AAC/E,QAAM,EAAE,eAAe,IAAI,sBAAsB,YAAY,WAAW,MAAM,IAAI;AAElF,QAAM,SAAiB;AAAA,IACnB,MAAM;AAAA,IACN,MAAM,CAAC,KAAK;AAAA,EAChB;AACA,QAAM,UAAUD,uBAAsB,UAAUE,aAAY,MAAM,CAAC;AAGnE,MAAI,SAAS,GAAGC,OAAM,KAAK,YAAY,QAAQ,CAAC,IAAIA,OAAM,YAAY,MAAM,IAAI,CAAC;AAAA;AACjF,YAAU,GAAGA,OAAM,YAAY,YAAY,CAAC,IAAI,iBAAiB,IAC3D,GAAGA,OAAM,YAAY,cAAc,CAAC,eACpCA,OAAM,UAAU,cAAc,CAChC;AAAA;AAAA;AAGJ,QAAM,iBAAiB,KAAK,IAAI,GAAG,OAAO,IAAI,CAAC,MAAM,EAAE,KAAK,MAAM,GAAG,CAAC;AACtE,QAAM,gBAAgB,KAAK,IAAI,GAAG,OAAO,IAAI,CAAC,MAAM,EAAE,KAAK,MAAM,GAAG,CAAC;AAErE,YAAUA,OAAM,UAAU,kBAAkB;AAC5C,YAAU,OACL,IAAI,CAAC,UAAU;AACZ,UAAM,YAAY,MAAM,OAClBA,OAAM,KAAK,IAAI,MAAM,IAAI,IACzB,MAAM,WACFA,OAAM,KAAK,OAAO,MAAM,IAAI,IAC5BA,OAAM,MAAM,MAAM,IAAI;AAEhC,UAAM,YAAY,MAAM,aAAaA,OAAM,KAAK,MAAM,IAAI,IAAIA,OAAM,WAAW,MAAM,IAAI;AAEzF,WAAO,GAAG,UAAU,OAAO,iBAAiB,CAAC,CAAC,IAAI,UAAU;AAAA,MACxD,gBAAgB;AAAA,IACpB,CAAC;AAAA,EACL,CAAC,EACA,KAAK,IAAI;AAEd,YAAU;AAGV,YAAUA,OAAM,UAAU,SAAS,IAAI;AAGvC,SAAO,SAAS,OAAOJ,OAAM,QAAQ;AAAA,IACjC,SAAS;AAAA,IACT,aAAa;AAAA,IACb,aAAa;AAAA,EACjB,CAAC,CAAC;AACN;;;AClFA,SAAS,eAAAK,oBAA2B;AAGpC,OAAOC,YAAW;AAClB,SAAS,qBAAAC,0BAAyB;AAClC,OAAOC,YAAW;AAClB,IAAMC,yBAAwB,IAAIF,mBAAkB;AAC7C,IAAM,YAAuD,CAAC,aAAa,SAAS;AACvF,QAAM,WAAW,gBAAgB,IAAI;AACrC,QAAM,EAAE,KAAK,IAAI;AACjB,QAAM,SAAS,UAAU,WAAW,EAAE,UAAU,MAAM,MAAM;AAE5D,QAAM,SAAiB;AAAA,IACnB,MAAM;AAAA,IACN,MAAM;AAAA,EACV;AAEA,QAAM,aAAa,OAAO;AAC1B,QAAM,QACF,aAAa,IACP,2BAAoBC,OAAM,KAAK,UAAU,CAAC,SAAS,aAAa,IAAI,MAAM,EAAE,YAC5E;AAEV,QAAM,oBAAoBC,uBAAsB,UAAUC,aAAY,MAAM,CAAC;AAE7E,QAAM,SAAS,QAAQ,SAAS;AAAA,EAClC,KAAK;AAAA;AAAA,EAEL,iBAAiB;AAAA,YACP;AAER,QAAM,WAAWJ,OAAM,QAAQ;AAAA,IAC3B,SAAS;AAAA,IACT,aAAa,aAAa,IAAI,UAAU;AAAA,IACxC,aAAa;AAAA,IACb,OAAO;AAAA,EACX,CAAC;AAED,SAAO,SAAS,OAAO,QAAQ;AACnC;;;AClCO,IAAM,eAA6D,CAAC,aAAa,SAAS;AAC7F,QAAM,WAAW,gBAAgB,IAAI;AACrC,QAAM,SAAS,UAAU,WAAW;AACpC,QAAM,EAAE,SAAS,KAAK,IAAI;AAE1B,QAAM,aAAa,MAAM,UAAU,CAAC;AACpC,MAAI,CAAC,WAAW,QAAQ;AACpB,WAAO,SAAS,MAAM,6FAA6F;AAAA,EACvH;AACA,QAAM,SAAS,OAAO,UAAU;AAChC,QAAM,iBAAiB,OAAO,OAAO,OAAK,WAAW,SAAS,EAAE,IAAI,CAAC;AACrE,MAAI,CAAC,eAAe,QAAQ;AACxB,WAAO,SAAS,OAAO,iBAAiB;AAAA,EAC5C;AACA,QAAM,UAAU,CAAC;AACjB,QAAM,SAAS,IAAI,4BAA4B,YAAY,SAAS;AACpE,aAAW,SAAS,gBAAgB;AAChC,UAAM,MAAM,OAAO,wBAAwB,MAAM,MAAM,SAAS,SAAS,CAAC;AAC1E,YAAQ,KAAK,GAAG;AAAA,EACpB;AAGA,SAAO,SAAS,OAAO,QAAQ,KAAK,IAAI,CAAC;AAC7C;;;AC5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAAK;AAAA;;;ACIO,IAAM,uBAA0E,CAAC,aAAa,SAAS;AAC1G,QAAM,WAAW,gBAAgB,IAAI;AACrC,QAAM,SAAS,UAAU,WAAW;AACpC,QAAM,EAAE,KAAK,IAAI;AAEjB,QAAM,WAAW,MAAM,QAAQ,CAAC;AAChC,MAAI,CAAC,UAAU;AACX,WAAO,SAAS,MAAM,yEAAyE;AAAA,EACnG;AAEA,QAAM,QAAQ,OAAO,cAAc,QAAQ;AAC3C,MAAI,CAAC,OAAO;AACR,WAAO,SAAS,MAAM,QAAQ,QAAQ,YAAY;AAAA,EACtD;AACA,QAAM,YAAY,OAAO,iBAAiB,QAAQ;AAElD,QAAM,QAAQ,UAAU;AACxB,MAAI,CAAC,OAAO;AACR,WAAO,SAAS,OAAO;AAAA,MACnB,OAAO;AAAA,MACP,WAAW,CAAC;AAAA,IAChB,CAAC;AAAA,EACL;AACA,SAAO,SAAS,OAAO;AAAA,IACnB;AAAA,IACA;AAAA,EACJ,CAAC;AACL;;;AC3BO,IAAM,eAAyD,CAAC,aAAa,SAAS;AACzF,QAAM,WAAW,gBAAgB,IAAI;AACrC,QAAM,SAAS,UAAU,WAAW;AACpC,MAAI,QAAQ,OAAO,SAAS;AAC5B,QAAM,YAAY,KAAK,MAAM,SAAS,CAAC;AACvC,MAAI,UAAU,UAAU,CAAC,UAAU,SAAS,GAAG,GAAG;AAC9C,YAAQ,MAAM,OAAO,OAAK,UAAU,SAAS,EAAE,IAAI,CAAC;AAAA,EACxD;AACA,MAAI,CAAC,MAAM,QAAQ;AACf,WAAO,SAAS,OAAO;AAAA,MACnB,OAAO;AAAA,MACP,OAAO,CAAC;AAAA,IACZ,CAAC;AAAA,EACL;AACA,QAAM,aAAa,MAAM;AAGzB,QAAM,OAGA,CAAC;AAEP,QAAM,QAAQ,OAAK;AACf,SAAK,KAAK;AAAA,MACN,MAAM,EAAE;AAAA,MACR,SAAS,EAAE,aAAa,OAAO,CAAAC,OAAKA,GAAE,QAAQ,YAAY,EAAE,IAAI,CAAC,OAAmB,GAAG,IAAI,KAAK,CAAC;AAAA,IACrG,CAAC;AAAA,EACL,CAAC;AAED,SAAO,SAAS,OAAO;AAAA,IACnB,OAAO;AAAA,IACP,OAAO;AAAA,EACX,CAAC;AACL;;;ACnCO,IAAM,gBAA2D,CAAC,aAAa,SAAS;AAC3F,QAAM,WAAW,gBAAgB,IAAI;AACrC,QAAM,EAAE,KAAK,IAAI;AAEjB,QAAM,SAAS,UAAU,WAAW;AAGpC,QAAM,YAAY,MAAM,SAAS,CAAC;AAClC,MAAI,CAAC,WAAW;AACZ,WAAO,SAAS,MAAM,0HAAqH;AAAA,EAC/I;AAEA,QAAM,QAAQ,OAAO,eAAe,SAAS;AAC7C,MAAI,CAAC,OAAO;AACR,WAAO,SAAS,MAAM,gBAAW,SAAS,YAAY;AAAA,EAC1D;AAEA,MAAI,SAAS,OAAO,UAAU,SAAS;AACvC,MAAI,CAAC,OAAO,QAAQ;AAChB,WAAO,SAAS,OAAO;AAAA,MACnB,QAAQ,CAAC;AAAA,MACT,OAAO;AAAA,IACX,CAAC;AAAA,EACL;AAEA,QAAM,cAAc,MAAM,UAAU,CAAC;AAErC,MAAI,YAAY,UAAU,CAAC,YAAY,SAAS,GAAG,GAAG;AAClD,aAAS,OAAO,OAAO,WAAS,YAAY,SAAS,MAAM,IAAI,CAAC;AAAA,EACpE;AAEA,MAAI,CAAC,OAAO,QAAQ;AAChB,WAAO,SAAS,OAAO;AAAA,MACnB,QAAQ,CAAC;AAAA,MACT,OAAO;AAAA,IACX,CAAC;AAAA,EACL;AACA,QAAM,iBAAiB,OAAO,OAAO,WAAS,MAAM,YAAY,KAAK,UAAQ,KAAK,SAAS,UAAU,CAAC,EAAE;AACxG,SAAO,SAAS,OAAO;AAAA,IACnB;AAAA,IACA,OAAO;AAAA,EACX,CAAC;AACL;;;ACxCO,IAAMC,kBAAiB,CAAC,eAAyB;AACpD,aAAW,KAAK,CAAC,GAAG,MAAM,EAAE,cAAc,CAAC,CAAC;AAChD;AAEO,IAAM,oBAAoE,CAAC,aAAa,SAAS;AACpG,QAAM,WAAW,gBAAgB,IAAI;AAErC,QAAM,SAAS,UAAU,WAAW,EAAE,UAAU;AAChD,MAAI,OAAO,WAAW,GAAG;AACrB,WAAO,SAAS,OAAO;AAAA,MACnB,OAAO;AAAA,MACP,QAAQ,CAAC;AAAA,IACb,CAAC;AAAA,EACL;AACA,QAAM,aAAa,OAAO,IAAI,WAAS,MAAM,IAAI;AACjD,EAAAA,gBAAe,UAAU;AAGzB,SAAO,SAAS,OAAO;AAAA,IACnB,OAAO,WAAW;AAAA,IAClB,QAAQ;AAAA,EACZ,CAAC;AACL;;;ACzBA,SAAS,eAAAC,oBAA2B;AAa7B,IAAM,eAAyD,CAAC,aAAa,SAAS;AACzF,QAAM,EAAE,KAAK,IAAI;AACjB,QAAM,WAAW,gBAAgB,IAAI;AAErC,QAAM,YAAY,MAAM,SAAS,CAAC;AAClC,MAAI,CAAC,WAAW;AACZ,WAAO,SAAS,MAAM,6DAA6D;AAAA,EACvF;AAEA,QAAM,QAAQ,UAAU,WAAW,EAAE,eAAe,SAAS;AAC7D,MAAI,CAAC,OAAO;AACR,WAAO,SAAS,MAAM,SAAS,SAAS,YAAY;AAAA,EACxD;AAEA,QAAM,SAAyB,oBAAoB,OAAO,YAAY,SAAS;AAC/E,QAAM,EAAE,eAAe,IAAI,sBAAsB,YAAY,WAAW,MAAM,IAAI;AAElF,QAAM,SAAiB;AAAA,IACnB,MAAM;AAAA,IACN,MAAM,CAAC,KAAK;AAAA,EAChB;AAEA,SAAO,SAAS,OAAO;AAAA,IACnB;AAAA,IACA,QAAQC,aAAY,MAAM;AAAA,IAC1B,gBAAgB;AAAA,IAChB;AAAA,EACJ,CAAC;AACL;;;AC1CA,SAAS,eAAAC,oBAA2B;AAG7B,IAAM,gBAA2D,CAAC,aAAa,SAAS;AAC3F,QAAM,WAAW,gBAAgB,IAAI;AACrC,QAAM,EAAE,KAAK,IAAI;AACjB,QAAM,SAAS,UAAU,WAAW,EAAE,UAAU,MAAM,MAAM;AAE5D,QAAM,SAAiB;AAAA,IACnB,MAAM;AAAA,IACN,MAAM;AAAA,EACV;AAEA,QAAM,aAAa,OAAO;AAC1B,SAAO,SAAS,OAAO;AAAA,IACnB,OAAO;AAAA,IACP;AAAA,IACA,QAAQC,aAAY,MAAM;AAAA,EAC9B,CAAC;AACL;;;ACdO,IAAM,mBAAiE,CAAC,aAAa,SAAS;AACjG,QAAM,WAAW,gBAAgB,IAAI;AACrC,QAAM,SAAS,UAAU,WAAW;AACpC,QAAM,EAAE,SAAS,KAAK,IAAI;AAE1B,QAAM,aAAa,MAAM,UAAU,CAAC;AACpC,MAAI,CAAC,WAAW,QAAQ;AACpB,WAAO,SAAS,MAAM,6FAA6F;AAAA,EACvH;AACA,QAAM,SAAS,OAAO,UAAU;AAChC,QAAM,iBAAiB,OAAO,OAAO,OAAK,WAAW,SAAS,EAAE,IAAI,CAAC;AACrE,MAAI,CAAC,eAAe,QAAQ;AACxB,WAAO,SAAS,OAAO;AAAA,MACnB,OAAO;AAAA,MACP,SAAS,CAAC;AAAA,IACd,CAAC;AAAA,EACL;AACA,QAAM,UAA2C,CAAC;AAClD,QAAM,SAAS,IAAI,4BAA4B,YAAY,SAAS;AACpE,aAAW,SAAS,gBAAgB;AAChC,UAAM,MAAM,OAAO,oBAAoB,MAAM,MAAM,YAAY,WAAW,SAAS,SAAS,CAAC;AAC7F,YAAQ,KAAK,GAAG;AAAA,EACpB;AACA,SAAO,SAAS,OAAO;AAAA,IACnB;AAAA,IACA,OAAO,QAAQ;AAAA,EACnB,CAAC;AACL;;;AChCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,SAAS,oBAAoB;AAGtB,IAAM,UAAsD,CAAC,aAAa,SAAS;AACtF,QAAM,EAAE,KAAK,IAAI;AACjB,QAAM,WAAW,gBAAgB,IAAI;AAErC,QAAM,YAAY,MAAM,SAAS,CAAC,GAAG,CAAC;AACtC,MAAI,CAAC,SAAS,QAAQ;AAClB,WAAO,SAAS,MAAM,oEAAoE;AAAA,EAC9F;AACA,MAAI,CAAC,KAAK,aAAa;AACnB,WAAO,SAAS,MAAM,qEAAqE;AAAA,EAC/F;AACA,MAAI,OAAiB,CAAC;AACtB,MAAI,KAAK,aAAa;AAClB,WAAO,KAAK,YAAY,MAAM,KAAK,EAAE,IAAI,CAAC,QAAQ,aAAa,GAAG,CAAC;AAAA,EACvE;AACA,MAAI,CAAC,KAAK,QAAQ;AACd,WAAO,SAAS,MAAM,yEAAyE;AAAA,EACnG;AACA,MAAI;AACA,UAAM,UAAU,YAAY;AAE5B,UAAM,WAAW,QAAQ,WAAW,QAAQ,EAAE,MAAM,SAAS,CAAC;AAC9D,QAAI,UAAU;AACV,aAAO,SAAS,MAAM,QAAQ,QAAQ,iBAAiB;AAAA,IAC3D;AAEA,YAAQ,KAAK,UAAU,IAAI;AAE3B,WAAO,SAAS,OAAO,QAAQ,QAAQ,sBAAsB;AAAA,EACjE,SAAS,OAAO;AACZ,WAAO,SAAS,MAAM,sBAAsB,MAAM,OAAO,EAAE;AAAA,EAC/D;AACJ;;;ACnCA,SAAgB,aAAAC,kBAAkC;AAI3C,IAAM,WAAwD,CAAC,aAAa,SAAS;AACxF,QAAM,WAAW,gBAAgB,IAAI;AACrC,QAAM,EAAE,KAAK,IAAI;AAEjB,MAAI,CAAC,MAAM,UAAU,CAAC,KAAK,OAAO,QAAQ;AACtC,WAAO,SAAS,MAAM,mGAAmG;AAAA,EAC7H;AACA,MAAI,CAAC,MAAM,UAAU,CAAC,KAAK,OAAO,QAAQ;AACtC,WAAO,SAAS,MAAM,uGAAuG;AAAA,EACjI;AACA,QAAM,YAAY,KAAK,OAAO,CAAC;AAE/B,QAAM,QAAQ,YAAY,QAAQ,WAAW,SAAS,EAAE,MAAM,UAAU,CAAC;AACzE,MAAI,CAAC,OAAO;AACR,WAAO,SAAS,MAAM,SAAS,SAAS,sDAAsD;AAAA,EAClG;AAEA,QAAM,YAAY,KAAK,OAAO,CAAC;AAC/B,MAAI,CAAC,KAAK,aAAa;AACnB,WAAO,SAAS,MAAM,uGAAuG;AAAA,EACjI;AAEA,QAAM,YAAY,MAAM,WAAW,KAAK,CAAC,SAAS,KAAK,SAAS,WAAW,KAAK,SAAS,SAAS;AAClG,MAAI,WAAW;AACX,WAAO,SAAS,MAAM,SAAS,SAAS,4BAA4B,SAAS,EAAE;AAAA,EACnF;AACA,QAAM,cAAc;AAAA,UACd,SAAS,KAAK,KAAK,WAAW;AAAA;AAGpC,MAAI;AACJ,MAAI;AACA,aAASC,WAAU,WAAW;AAAA,EAClC,SAAS,OAAO;AACZ,WAAO,SAAS,MAAM,wBAAwB,MAAM,OAAO,EAAE;AAAA,EACjE;AAEA,MAAI,CAAC,OAAO,KAAK,QAAQ;AACrB,WAAO,SAAS,MAAM,sOAAsO;AAAA,EAChQ;AAEA,QAAM,YAAY,OAAO,KAAK,CAAC;AAC/B,QAAM,QAAQ,UAAU,WAAW,KAAK,CAAC,SAAS,KAAK,SAAS,WAAW,KAAK,SAAS,SAAS;AAClG,MAAI,CAAC,OAAO;AACR,WAAO,SAAS,MAAM,yJAAyJ;AAAA,EACnL;AACA,QAAM,YAAY,qBAAqB,KAAiB;AACxD,MAAI,CAAC,WAAW;AACZ,WAAO,SAAS,MAAM,yJAAyJ;AAAA,EACnL;AACA,QAAM,eAAe,YAAY,QAAQ,MAAM,MAAM,IAAI;AACzD,MAAI,WAAW;AACX,UAAM,eAAe,aAAa,MAAM,UAAU,MAAM,UAAU,SAAS;AAE3E,eAAW,QAAQ,UAAU,YAAY;AACrC,mBAAa,UAAU,KAAK,MAAM,KAAK,IAAI;AAAA,IAC/C;AAAA,EACJ;AAEA,SAAO,SAAS,OAAO,SAAS,SAAS,mBAAmB,SAAS,EAAE;AAC3E;;;AChEA,SAAS,aAAAC,kBAA2B;AAI7B,IAAM,WAAwD,CAAC,aAAa,SAAS;AACxF,QAAM,EAAE,MAAM,aAAa,QAAQ,IAAI;AACvC,QAAM,WAAW,gBAAgB,IAAI;AAErC,QAAM,aAAa,MAAM,UAAU,CAAC,GAAG,CAAC;AACxC,MAAI,CAAC,WAAW;AACZ,WAAO,SAAS,MAAM,6EAA6E;AAAA,EACvG;AACA,MAAI;AAgEA,QAAS,qBAAT,SAA4B,WAAgC,MAAmB;AAC3E,UAAI,CAAC,UAAW,QAAO;AACvB,UAAI,CAAC,UAAU,OAAQ,QAAO;AAC9B,YAAM,SAAS,aAAa,UAAU,QAAQ,QAAQ,CAAC,GAAG,IAAI;AAC9D,UAAI,OAAO,QAAQ;AACf,eAAO;AAAA,UACH,GAAG;AAAA,UACH,QAAQ,EAAE,MAAM,SAAS,MAAM,OAAO;AAAA,QAC1C;AAAA,MACJ,OAAO;AACH,eAAO;AAAA,MACX;AAAA,IACJ;AA3EA,UAAM,UAAU,YAAY;AAE5B,UAAM,YAAY,QAAQ,WAAW,SAAS,EAAE,MAAM,UAAU,CAAC;AACjE,QAAI,WAAW;AACX,aAAO,SAAS,MAAM,SAAS,SAAS,iBAAiB;AAAA,IAC7D;AAEA,QAAI,CAAC,aAAa;AACd,aAAO,SAAS,MAAM,0GAA0G;AAAA,IACpI;AACA,QAAI;AAEJ,UAAM,gBAAgB,SAAS,QAAQ,KAAK;AAC5C,UAAM,cAAc,SAAS,SAAS;AAAA,UACpC,aAAa;AAAA,UACb,eAAe,YAAY;AAAA;AAG7B,QAAI;AACA,eAASC,WAAU,WAAW;AAAA,IAClC,SAAS,OAAO;AACZ,aAAO,SAAS,MAAM,gDAAgD,MAAM,OAAO,EAAE;AAAA,IACzF;AACA,UAAM,QAAQ,UAAU,MAAM,EAAE,eAAe,SAAS;AAExD,QAAI,CAAC,OAAO;AACR,aAAO,SAAS,MAAM,SAAS,SAAS,iBAAiB;AAAA,IAC7D;AAEA,UAAM,eAAe,QAAQ,MAAM,SAAS;AAC5C,UAAM,UAAU,MAAM,WAAW,KAAK,CAAC,SAAmB,KAAK,SAAS,WAAW,MAAM,YAAY,KAAK,UAAQ,KAAK,SAAS,IAAI,CAAC;AACrI,QAAI,CAAC,SAAS;AACV,mBAAa,MAAM,MAAM,KAAK,EAAE,UAAU,IAAI;AAAA,IAClD;AAEA,UAAM,kBAAkB,oBAAI,IAAY;AACxC,eAAW,QAAQ,MAAM,YAAY;AACjC,UAAI,KAAK,SAAS,SAAS;AACvB;AAAA,MACJ;AACA,YAAM,QAAQ;AAEd,YAAM,YAAY,qBAAqB,IAAgB;AACvD,UAAI,CAAC,WAAW;AACZ;AAAA,MACJ;AACA,UAAI,WAAW;AACX,YAAI,eAAe,aAAa,MAAM,MAAM,MAAM,UAAU,SAAS;AACrE,wBAAgB,IAAI,MAAM,IAAI;AAC9B,mBAAW,QAAQ,UAAU,YAAY;AACrC,yBAAe,aAAa,UAAU,KAAK,MAAM,KAAK,IAAI;AAAA,QAC9D;AAAA,MACJ;AAAA,IACJ;AACA,UAAM,kBAAkB,CAAC,UAAU,SAAS,IAAI;AAChD,UAAM,eAAe,CAAC,QAAuB,SAAiB;AAC1D,UAAI,CAAC,gBAAgB,SAAS,IAAI,GAAG;AACjC,eAAO;AAAA,MACX;AACA,aAAO,OAAO,OAAO,CAAC,UAAU;AAC5B,eAAO,gBAAgB,IAAI,KAAK;AAAA,MACpC,CAAC;AAAA,IACL;AAcA,UAAM,qBAAqB,oBAAI,IAAqE;AAEpG,eAAW,QAAQ,MAAM,YAAY;AACjC,UAAI,KAAK,SAAS,eAAe,KAAK,MAAM;AACxC,YAAI,YAAsB,CAAC;AAC3B,YAAI,eAAuC,CAAC;AAC5C,mBAAW,OAAO,KAAK,MAAM;AACzB,gBAAM,EAAE,OAAO,KAAK,IAAI;AACxB,cAAI,QAAQ,qBAAqB;AAC7B,gBAAI,YAAY,OAAO,OAAO;AAC1B,2BAAa,eAAe,KAAK,MAAM,KAAK;AAAA,YAChD,WAAW,YAAY,OAAO,OAAO;AACjC,oBAAM,MAAM;AACZ,kBAAI,IAAI,SAAS,SAAS;AACtB,sBAAM,SAAS,aAAa,IAAI,MAAM,KAAK,IAAI;AAC/C,oBAAI,OAAO,QAAQ;AACf,+BAAa,eAAe,KAAK,MAAM,MAAM;AAAA,gBACjD;AAAA,cACJ,WAAW,IAAI,SAAS,YAAY;AAChC,6BAAa,IAAI,GAAG,IAAI,IAAI;AAAA,cAChC;AAAA,YACJ;AAAA,UACJ;AAAA,QAEJ;AACA,YAAI,UAAU,UAAU,OAAO,KAAK,YAAY,EAAE,QAAQ;AACtD,cAAI,mBAAmB,IAAI,KAAK,IAAI,GAAG;AACnC,kBAAM,WAAW,mBAAmB,IAAI,KAAK,IAAI;AACjD,qBAAS,OAAO,CAAC,GAAG,oBAAI,IAAI,CAAC,GAAI,SAAS,QAAQ,CAAC,GAAI,GAAG,SAAS,CAAC,CAAC;AACrE,qBAAS,YAAY,EAAE,GAAG,SAAS,WAAW,GAAG,aAAa;AAAA,UAClE,OAAO;AACH,+BAAmB,IAAI,KAAK,MAAM,EAAE,MAAM,WAAW,WAAW,aAAa,CAAC;AAAA,UAClF;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AACA,eAAW,CAAC,MAAM,EAAE,WAAW,MAAAC,MAAK,CAAC,KAAK,mBAAmB,QAAQ,GAAG;AACpE,UAAI,aAAaA,OAAM,UAAU,OAAO,KAAK,SAAS,EAAE,QAAQ;AAC5D,cAAM,SAAS,aAAaA,OAAM,IAAI;AACtC,YAAI,OAAO,QAAQ;AACf,uBAAa,eAAe,MAAM;AAAA,YAC9B,GAAG;AAAA,YACH,QAAQ,EAAE,MAAM,SAAS,MAAAA,MAAK;AAAA,UAClC,CAAC;AAAA,QACL,OAAO;AACH,uBAAa,eAAe,MAAM,SAAS;AAAA,QAC/C;AAAA,MACJ,WAAWA,OAAM,QAAQ;AACrB,qBAAa,eAAe,MAAMA,KAAI;AAAA,MAC1C,WAAW,aAAa,OAAO,KAAK,SAAS,EAAE,QAAQ;AACnD,cAAM,SAAS,mBAAmB,WAAW,IAAI;AACjD,YAAI,QAAQ;AACR,uBAAa,eAAe,MAAM,MAAM;AAAA,QAC5C;AAAA,MACJ;AAAA,IACJ;AACA,WAAO,SAAS,OAAO,SAAS,SAAS,qBAAqB;AAAA,EAClE,SAAS,OAAO;AACZ,WAAO,SAAS,MAAM,uBAAuB,MAAM,OAAO,EAAE;AAAA,EAChE;AACJ;;;ACnJA,OAAOC,gBAAe;AACtB,SAAS,WAAW,cAAAC,mBAAkB;AAG/B,IAAM,cAA8D,CAAC,aAAa,SAAS;AAC9F,QAAM,EAAE,MAAM,QAAQ,IAAI;AAC1B,QAAM,WAAW,gBAAgB,IAAI;AACrC,QAAM,OAAO,SAAS;AAEtB,QAAM,SAAS,MAAM;AACrB,MAAI,CAAC,UAAU,OAAO,WAAW,GAAG;AAChC,WAAO,SAAS,MAAM,kGAAkG;AAAA,EAC5H;AAEA,MAAI,CAAC,MAAM;AACP,WAAO,SAAS,MAAM,qHAAqH;AAAA,EAC/I;AAEA,QAAM,CAAC,QAAQ,MAAM,IAAI;AACzB,QAAM,EAAE,QAAQ,IAAI;AACpB,QAAM,YAAY,QAAQ,WAAW,SAAS,EAAE,MAAM,OAAO,CAAC;AAC9D,QAAM,YAAY,QAAQ,WAAW,SAAS,EAAE,MAAM,OAAO,CAAC;AAC9D,MAAI,CAAC,WAAW;AACZ,WAAO,SAAS,MAAM,SAAS,MAAM,iCAAiC;AAAA,EAC1E;AACA,MAAI,CAAC,WAAW;AACZ,WAAO,SAAS,MAAM,SAAS,MAAM,iCAAiC;AAAA,EAC1E;AACA,QAAM,WAAW,SAAS,aAAa,SAAS,SAAS,aAAa;AACtE,QAAM,aAAc,SAAS,cAAc,SAAS,eAAe,OAAQ,uBAAuB,QAAQ,MAAM,IAAK,SAAS,cAAc;AAC5I,QAAM,qBAAqB,SAAS,gBAAgB,uBAAuB,QAAQ,MAAM;AACzF,QAAM,eAAe,IAAI,kBAAkB;AAC3C,QAAM,iBAAiB,aAAaC,YAAW,UAAU,IAAI;AAC7D,QAAM,iBAAiB,WAAW;AAClC,QAAM,KAAK,CAAC,cAA+B;AACvC,WAAO,UAAU,GAAG,SAAS,IAAI;AAAA,EACrC;AACA,QAAM,aAAa,CAAC,WAAmB,OAAO,UAAkB;AAC5D,WAAO,iBAAiB,UAAY,YAAY,QAAS,OAAO,OAAO,GAAI,IAAI,UAAU,aAAa,OAAO,OAAO,GAAG;AAAA,EAC3H;AAEA,MAAI,SAAS,YAAY,SAAS,aAAa,UAAU,SAAS,aAAa,QAAQ;AACnF,WAAO,SAAS,MAAM,SAAS,QAAQ,QAAQ,iCAAiC;AAAA,EACpF;AACA,QAAM,eAAe,CAAC,QAAgB;AAClC,WAAO,MAAM;AAAA,EACjB;AACA,QAAM,aAAa,CAAC,QAAgB;AAChC,WAAO,OAAO,WAAW,MAAM;AAAA,EACnC;AAEA,QAAM,SAAS,UAAU,WAAW;AAGpC,MAAI,QAAQ,OAAO;AACf,QAAI,CAAC,YAAY;AACb,YAAM,aAAa,SAAS,YAAY,UAAU;AAClD,YAAM,aAAa,eAAe,SAAS,SAAS;AACpD,YAAM,gBAAiB,OAAO,oBAAoB,UAAU,KAAK;AAEjE,YAAM,QAAQ,GAAG,UAAU;AAC3B,YAAM,cAAc,WAAW,UAAU;AACzC,cAAQ,MAAM,UAAU,EACnB,MAAM,OAAO,WAAW,aAAa,CAAC,EAAE,UAAU,QAAQ,EAC1D,MAAM,aAAa,WAAW,UAAU,CAAC,EACzC,UAAU,YAAY,CAAC,cAAc,YAAY,KAAK,KAAK,kBAAkB,CAAC;AAEnF,cAAQ,MAAM,UAAU,EACnB,MAAM,UAAU,UAAU,GAAG,aAAa,UAAU,CAAC,EACrD,UAAU,YAAY,CAAC,YAAY,CAAC;AAEzC,aAAO,SAAS,OAAO,qCAAqC,MAAM,QAAQ,MAAM,EAAE;AAAA,IACtF,OAAO;AACH,YAAM,MAAM,WAAW,QAAQ,IAAI;AACnC,YAAM,MAAM,GAAG,MAAM;AACrB,YAAM,YAAY,SAAS;AAE3B,YAAM,gBAAiB,OAAO,oBAAoB,MAAM,KAAK;AAC7D,YAAM,gBAAiB,OAAO,oBAAoB,MAAM,KAAK;AAC7D,UAAI,CAAC,WAAW;AACZ,gBAAQ,MAAM,cAAe,EACxB,MAAM,aAAa,UAAU,EAAE,UAAU,WAAW,CAAC,OAAO,CAAC,EAC7D,MAAM,KAAK,aAAa,EAAE,UAAU,QAAQ,EAC5C,MAAM,KAAK,aAAa,EAAE,UAAU,QAAQ,EAC5C,eAAe,MAAM,CAAC,KAAK,GAAG,CAAC,EAC/B,MAAM,OAAO,YAAY,GAAG,MAAM,EAAE,UAAU,YAAY;AAAA,UACvD;AAAA,UACA,YAAY,GAAG;AAAA,UACf;AAAA,QACJ,CAAC;AAEL,gBAAQ,MAAM,MAAM,EACf,MAAM,UAAU,MAAM,GAAG,GAAG,cAAc,GAAG,EAC7C,UAAU,YAAY,CAAC,YAAY,CAAC;AAAA,MAC7C,OAAO;AACH,gBAAQ,MAAM,cAAe,EACxB,MAAM,KAAK,aAAa,EAAE,UAAU,QAAQ,EAC5C,MAAM,KAAK,aAAa,EAAE,UAAU,QAAQ,EAC5C,MAAM,aAAa,UAAU,EAAE,UAAU,WAAW,CAAC,OAAO,CAAC,EAC7D,eAAe,MAAM,CAAC,KAAK,GAAG,CAAC;AAAA,MAExC;AAEA,aAAO,SAAS,OAAO,wDAAwD,MAAM,QAAQ,MAAM,EAAE;AAAA,IAEzG;AAAA,EACJ,WAAW,QAAQ,OAAO;AACtB,QAAI,CAAC,YAAY;AACb,YAAM,aAAa,SAAS,YAAY;AACxC,YAAM,aAAa,eAAe,SAAS,SAAS;AAEpD,YAAM,gBAAiB,OAAO,oBAAoB,UAAU,KAAK;AACjE,YAAM,QAAQ,GAAG,UAAU;AAC3B,YAAM,cAAc,WAAW,UAAU;AACzC,cAAQ,MAAM,UAAU,EACnB,MAAM,OAAO,WAAW,aAAa,CAAC,EAEtC,MAAM,aAAa,WAAW,UAAU,CAAC,EACzC,UAAU,YAAY,CAAC,cAAc,YAAY,KAAK,KAAK,kBAAkB,CAAC;AAEnF,cAAQ,MAAM,UAAU,EACnB,MAAMC,WAAU,OAAO,UAAU,UAAU,CAAC,GAAG,aAAa,IAAI,EAChE,UAAU,YAAY,CAAC,YAAY,CAAC;AAEzC,aAAO,SAAS,OAAO,sCAAsC,MAAM,QAAQ,MAAM,EAAE;AAAA,IACvF,OAAO;AACH,YAAM,MAAM,WAAW,QAAQ,IAAI;AACnC,YAAM,MAAM,WAAW,QAAQ,IAAI;AAEnC,YAAM,gBAAiB,OAAO,oBAAoB,MAAM,KAAK;AAC7D,YAAM,gBAAiB,OAAO,oBAAoB,MAAM,KAAK;AAC7D,cAAQ,MAAM,cAAe,EACxB,MAAM,aAAa,UAAU,EAAE,UAAU,WAAW,CAAC,OAAO,CAAC,EAC7D,MAAM,KAAK,aAAa,EAAE,UAAU,QAAQ,EAC5C,MAAM,KAAK,aAAa,EAAE,UAAU,QAAQ,EAC5C,eAAe,MAAM,CAAC,KAAK,GAAG,CAAC,EAC/B,MAAM,OAAO,YAAY,GAAG,MAAM,EAAE,UAAU,YAAY;AAAA,QACvD;AAAA,QACA,YAAY,GAAG;AAAA,QACf;AAAA,MACJ,CAAC;AAEL,cAAQ,MAAM,MAAM,EACf,MAAMA,WAAU,OAAO,UAAU,MAAM,CAAC,GAAG,GAAG,cAAc,IAAI,EAChE,UAAU,YAAY,CAAC,YAAY,CAAC;AAEzC,aAAO,SAAS,OAAO,yDAAyD,MAAM,QAAQ,MAAM,EAAE;AAAA,IAC1G;AAAA,EACJ;AAAE,MAAI,QAAQ,OAAO;AACjB,QAAI,CAAC,YAAY;AACb,YAAM,QAAQA,WAAU,OAAO,UAAU,MAAM,CAAC;AAChD,YAAM,UAAUA,WAAU,OAAO,WAAW,MAAM,CAAC;AAEnD,cAAQ,MAAM,MAAM,EACf,MAAM,OAAO,GAAG,MAAM,IAAI,EAC1B,UAAU,YAAY,CAAC,YAAY,CAAC;AAEzC,cAAQ,MAAM,MAAM,EACf,MAAM,SAAS,GAAG,MAAM,IAAI,EAC5B,UAAU,YAAY,CAAC,YAAY,CAAC;AACzC,aAAO,SAAS,OAAO,6DAA6D,MAAM,QAAQ,MAAM,EAAE;AAAA,IAC9G,OAAO;AACH,YAAM,mBAAmB,CAAC,QAAgB;AACtC,eAAO,iBAAkB,MAAM,OAAQ;AAAA,MAC3C;AACA,YAAM,cAAcA,WAAU,OAAO,UAAU,MAAM,CAAC;AACtD,YAAM,gBAAgBA,WAAU,OAAO,WAAW,MAAM,CAAC;AAEzD,YAAM,gBAAgB,QAAQ,MAAM,MAAM,EACrC,MAAM,aAAa,GAAG,cAAc,IAAI,EACxC,UAAU,YAAY,CAAC,YAAY,CAAC;AAEzC,YAAM,gBAAgB,iBAAiB,gBAAgB,QAAQ,MAAM,MAAM;AAC3E,oBAAc,MAAM,eAAe,GAAG,cAAc,IAAI,EACnD,UAAU,YAAY,CAAC,IAAI,iBAAiB,kBAAkB,CAAC,GAAG,CAAC;AAGxE,YAAM,MAAM,WAAW,QAAQ,IAAI;AACnC,YAAM,MAAM,GAAG,MAAM;AAErB,YAAM,QAAQ,UAAU,MAAM;AAC9B,YAAM,UAAU,WAAW,MAAM;AAEjC,YAAM,gBAAiB,OAAO,oBAAoB,MAAM,KAAK;AAC7D,YAAM,gBAAiB,OAAO,oBAAoB,MAAM,KAAK;AAC7D,cAAQ,MAAM,cAAe,EACxB,MAAM,KAAK,aAAa,EACxB,MAAM,KAAK,aAAa,EACxB,MAAM,aAAa,UAAU,EAAE,UAAU,WAAW,CAAC,OAAO,CAAC,EAE7D,MAAM,SAAS,MAAM,EAAE,UAAU,YAAY;AAAA,QAC1C,IAAK,iBAAiB,kBAAkB,CAAE;AAAA,QAC1C,YAAY,GAAG;AAAA,QACf;AAAA,QACA;AAAA,MACJ,CAAC,EACA,MAAM,OAAO,MAAM,EAAE,UAAU,YAAY;AAAA,QACxC;AAAA,QACA,YAAY,GAAG;AAAA,QACf;AAAA,QACA;AAAA,MACJ,CAAC,EACA,eAAe,MAAM,CAAC,KAAK,GAAG,CAAC;AAAA,IACxC;AAGA,WAAO,SAAS,OAAO,sDAAsD,MAAM,QAAQ,MAAM,EAAE;AAAA,EACvG;AAEA,SAAO,SAAS,MAAM,iBAAiB;AAC3C;;;AClNO,IAAM,aAA4D,CAAC,aAAa,SAAS;AAC5F,QAAM,EAAE,KAAK,IAAI;AACjB,QAAM,WAAW,gBAAgB,IAAI;AAErC,QAAM,WAAW,MAAM,QAAQ,CAAC;AAChC,MAAI,CAAC,UAAU;AACX,WAAO,SAAS,MAAM,yDAAyD;AAAA,EACnF;AAEA,MAAI;AACA,UAAM,UAAU,YAAY;AAC5B,UAAM,WAAW,QAAQ,WAAW,QAAQ,EAAE,MAAM,SAAS,CAAC;AAC9D,QAAI,CAAC,UAAU;AACX,aAAO,SAAS,MAAM,QAAQ,QAAQ,iBAAiB;AAAA,IAC3D;AACA,YAAQ,KAAK,QAAQ;AAErB,WAAO,SAAS,OAAO,QAAQ,QAAQ,uBAAuB;AAAA,EAClE,SAAS,OAAO;AACZ,WAAO,SAAS,MAAM,wBAAwB,MAAM,OAAO,EAAE;AAAA,EACjE;AACJ;;;ACrBO,IAAM,cAA8D,CAAC,aAAa,SAAS;AAC9F,QAAM,EAAE,KAAK,IAAI;AACjB,QAAM,WAAW,gBAAgB,IAAI;AAErC,MAAI,CAAC,MAAM,UAAU,CAAC,KAAK,OAAO,QAAQ;AACtC,WAAO,SAAS,MAAM,8EAA8E;AAAA,EACxG;AAEA,QAAM,YAAY,MAAM,SAAS,CAAC;AAClC,MAAI,CAAC,WAAW;AACZ,WAAO,SAAS,MAAM,0EAA0E;AAAA,EACpG;AAGA,QAAM,YAAY,KAAK,OAAO,CAAC;AAC/B,MAAI;AAEA,UAAM,UAAU,YAAY;AAE5B,UAAM,YAAY,QAAQ,WAAW,SAAS,EAAE,MAAM,UAAU,CAAC;AACjE,QAAI,CAAC,WAAW;AACZ,aAAO,SAAS,MAAM,SAAS,SAAS,iBAAiB;AAAA,IAC7D;AAEA,QAAI,CAAC,UAAU,WAAW,KAAK,CAAC,SAAS,KAAK,SAAS,WAAW,KAAK,SAAS,SAAS,GAAG;AACxF,aAAO,SAAS,MAAM,SAAS,SAAS,4BAA4B,SAAS,EAAE;AAAA,IACnF;AACA,UAAM,QAAQ,QAAQ,MAAM,SAAS;AACrC,UAAM,YAAY,SAAS;AAC3B,WAAO,SAAS,OAAO,SAAS,SAAS,uBAAuB;AAAA,EACpE,SAAS,OAAO;AACZ,WAAO,SAAS,MAAM,yBAAyB,MAAM,OAAO,EAAE;AAAA,EAClE;AACJ;;;ACjCO,IAAM,cAA8D,CAAC,aAAa,SAAS;AAC9F,QAAM,EAAE,KAAK,IAAI;AACjB,QAAM,WAAW,gBAAgB,IAAI;AAErC,QAAM,YAAY,MAAM,SAAS,CAAC;AAElC,MAAI,CAAC,WAAW;AACZ,WAAO,SAAS,MAAM,4DAA4D;AAAA,EACtF;AAEA,MAAI;AACA,UAAM,UAAU,YAAY;AAE5B,UAAM,YAAY,QAAQ,WAAW,SAAS,EAAE,MAAM,UAAU,CAAC;AACjE,QAAI,CAAC,WAAW;AACZ,aAAO,SAAS,MAAM,SAAS,SAAS,iBAAiB;AAAA,IAC7D;AAEA,YAAQ,KAAK,SAAS;AAEtB,WAAO,SAAS,OAAO,SAAS,SAAS,uBAAuB;AAAA,EACpE,SAAS,OAAO;AACZ,WAAO,SAAS,MAAM,yBAAyB,MAAM,OAAO,EAAE;AAAA,EAClE;AACJ;;;AC1BA,OAAOC,aAAW;AAIX,IAAM,iBAAoE,CAAC,aAAa,SAAS;AACpG,QAAM,EAAE,MAAM,QAAQ,IAAI;AAC1B,QAAM,WAAW,gBAAgB,IAAI;AAErC,QAAM,SAAS,MAAM;AACrB,MAAI,CAAC,UAAU,OAAO,WAAW,GAAG;AAChC,WAAO,SAAS,MAAM,8FAA8F;AAAA,EACxH;AACA,QAAM,CAAC,QAAQ,MAAM,IAAI;AAEzB,QAAM,EAAE,QAAQ,IAAI;AACpB,QAAM,YAAY,QAAQ,WAAW,SAAS,EAAE,MAAM,OAAO,CAAC;AAC9D,QAAM,YAAY,QAAQ,WAAW,SAAS,EAAE,MAAM,OAAO,CAAC;AAE9D,MAAI,CAAC,WAAW;AACZ,WAAO,SAAS,MAAM,SAAS,MAAM,YAAY;AAAA,EACrD;AACA,MAAI,CAAC,WAAW;AACZ,WAAO,SAAS,MAAM,SAAS,MAAM,YAAY;AAAA,EACrD;AACA,QAAM,SAAS,SAAS;AACxB,QAAM,SAAS,SAAS;AAExB,MAAI,UAAU,CAAC,QAAQ;AACnB,WAAO,SAAS,MAAM,SAAS,MAAM,kBAAkB,MAAM,+BAA+B,MAAM,EAAE;AAAA,EACxG;AAEA,MAAI,SAAS,cAAc;AACvB,YAAQ,IAAIC,QAAM,OAAO,mEAAmE,CAAC;AAC7F,UAAM,UAAU,UAAU,WAAW;AAAA,MACjC,CAAC,SAAS,KAAK,SAAS,YAAY,KAAK,cAAc,UAAU,KAAK,cAAc;AAAA,IACxF;AACA,UAAM,oBAAoB,QAAQ;AAAA,MAC9B,CAAC,UAAU,OAAO,YAAY;AAAA,QAC1B,CAAC,SAAS,KAAK,SAAS,eAAe,KAAK,SAAS,cAAc,KAAK,MAAM;AAAA,UAC1E,CAAC,QAAQ,IAAI,SAAS,uBAAuB,IAAI,UAAU,IAAI,QAAQ,YAAY;AAAA,QAAG;AAAA,MAC9F;AAAA,IACJ;AACA,QAAI,kBAAkB,WAAW,GAAG;AAChC,aAAO,SAAS,MAAM,YAAY,QAAQ,YAAY,sBAAsB,MAAM,QAAQ,MAAM,EAAE;AAAA,IACtG;AACA,eAAW,SAAS,mBAAmB;AACnC,cAAQ,MAAM,MAAM,EAAE,YAAY,MAAM,IAAI;AAAA,IAChD;AAEA,UAAM,UAAU,UAAU,WAAW;AAAA,MACjC,CAAC,SAAS,KAAK,SAAS,YAAY,KAAK,cAAc,UAAU,KAAK,cAAc;AAAA,IACxF;AACA,UAAM,oBAAoB,QAAQ;AAAA,MAC9B,CAAC,UAAU,OAAO,YAAY;AAAA,QAC1B,CAAC,SAAS,KAAK,SAAS,eAAe,KAAK,SAAS,cAAc,KAAK,MAAM;AAAA,UAC1E,CAAC,QAAQ,IAAI,SAAS,uBAAuB,IAAI,UAAU,IAAI,QAAQ,YAAY;AAAA,QAAG;AAAA,MAC9F;AAAA,IACJ;AACA,eAAW,SAAS,mBAAmB;AACnC,cAAQ,MAAM,MAAM,EAAE,YAAY,MAAM,IAAI;AAAA,IAChD;AACA,QAAI,kBAAkB,WAAW,KAAK,kBAAkB,WAAW,GAAG;AAClE,aAAO,SAAS,MAAM,YAAY,QAAQ,YAAY,sBAAsB,MAAM,QAAQ,MAAM,EAAE;AAAA,IACtG;AACA,WAAO,SAAS,OAAO,YAAY,QAAQ,YAAY,oBAAoB,MAAM,QAAQ,MAAM,EAAE;AAAA,EACrG;AAEA,MAAI,CAAC,UAAU,CAAC,QAAQ;AACpB,YAAQ,IAAIA,QAAM,OAAO,mEAAmE,MAAM,QAAQ,MAAM,EAAE,CAAC;AACnH,UAAM,kBAAkB,UAAU,WAAW;AAAA,MACzC,CAAC,SAAS,KAAK,SAAS,WAAW,KAAK,cAAc;AAAA,IAC1D;AACA,UAAM,kBAAkB,UAAU,WAAW;AAAA,MACzC,CAAC,SAAS,KAAK,SAAS,WAAW,KAAK,cAAc;AAAA,IAC1D;AAEA,eAAW,SAAS,iBAAiB;AACjC,cAAQ,MAAM,MAAM,EAAE,YAAY,MAAM,IAAI;AAAA,IAChD;AAEA,eAAW,SAAS,iBAAiB;AACjC,cAAQ,MAAM,MAAM,EAAE,YAAY,MAAM,IAAI;AAAA,IAChD;AACA,QAAI,gBAAgB,WAAW,KAAK,gBAAgB,WAAW,GAAG;AAC9D,aAAO,SAAS,MAAM,+BAA+B,MAAM,QAAQ,MAAM,EAAE;AAAA,IAC/E;AACA,WAAO,SAAS,OAAO,yBAAyB,MAAM,QAAQ,MAAM,UAAU;AAAA,EAClF;AAEA,QAAM,gBAAgB,QAAQ,MAAM,MAAM;AAE1C,QAAM,WAAW,UAAU,WAAW;AAAA,IAClC,CAAC,SAAU,KAAK,SAAS,WAAW,KAAK,QAAQ,WAAY,KAAK,cAAc,UAAU,KAAK,cAAc;AAAA,EAEjH;AACA,MAAI,UAAU;AACV,kBAAc,YAAY,SAAS,IAAI;AAAA,EAC3C;AAEA,QAAM,gBAAgB,QAAQ,MAAM,MAAM;AAC1C,QAAM,WAAW,UAAU,WAAW;AAAA,IAClC,CAAC,SAAU,KAAK,SAAS,WAAW,KAAK,QAAQ,WAAY,KAAK,cAAc,UAAU,KAAK,cAAc;AAAA,EACjH;AACA,MAAI,UAAU;AACV,kBAAc,YAAY,SAAS,IAAI;AAAA,EAC3C;AAEA,MAAI,YAAY,UAAU;AACtB,WAAO,SAAS,OAAO,YAAY,UAAU,QAAQ,UAAU,IAAI,oBAAoB,MAAM,QAAQ,MAAM,EAAE;AAAA,EACjH;AAEA,SAAO,SAAS,MAAM,8BAA8B,MAAM,QAAQ,MAAM,EAAE;AAC9E;;;AC/GA,SAAS,gBAAAC,qBAAoB;AAEtB,IAAM,aAA4D,CAAC,aAAa,SAAS;AAC5F,QAAM,EAAE,MAAM,QAAQ,IAAI;AAC1B,QAAM,WAAW,gBAAgB,IAAI;AAErC,QAAM,WAAW,MAAM,QAAQ,CAAC;AAChC,MAAI,CAAC,UAAU;AACX,WAAO,SAAS,MAAM,oEAAoE;AAAA,EAC9F;AACA,MAAI,CAAC,KAAK,aAAa;AACnB,WAAO,SAAS,MAAM,wEAAwE;AAAA,EAClG;AACA,MAAI,OAAiB,CAAC;AACtB,MAAI,KAAK,aAAa;AAClB,WAAO,KAAK,YAAY,MAAM,KAAK;AAAA,EACvC;AACA,MAAI,CAAC,KAAK,QAAQ;AACd,WAAO,SAAS,MAAM,4EAA4E;AAAA,EACtG;AACA,MAAI;AACA,UAAM,cAAc,MAAM,IAAI,SAAOA,cAAa,GAAG,CAAC;AACtD,UAAM,UAAU,YAAY;AAC5B,UAAM,WAAW,QAAQ,WAAW,QAAQ,EAAE,MAAM,SAAS,CAAC;AAC9D,QAAI,CAAC,UAAU;AACX,cAAQ,KAAK,UAAU,WAAW;AAClC,aAAO,SAAS,OAAO,QAAQ,QAAQ,qBAAqB;AAAA,IAChE;AACA,UAAM,YAAY,SAAS,YAAY,OAAO,QAAM,GAAG,QAAQ,YAAY,EAAE,IAAI,OAAK,EAAE,IAAI;AAE5F,UAAM,WAAW,CAAC,SAAS;AAE3B,QAAI;AACJ,QAAI,UAAU;AACV,oBAAc,MAAM,KAAK,oBAAI,IAAI,CAAC,GAAG,WAAW,GAAG,WAAW,CAAC,CAAC;AAAA,IACpE,OAAO;AACH,oBAAc;AAAA,IAClB;AAEA,YAAQ,KAAK,QAAQ;AACrB,YAAQ,KAAK,UAAU,WAAW;AAElC,WAAO,SAAS,OAAO,QAAQ,QAAQ,qBAAqB;AAAA,EAChE,SAAS,OAAO;AACZ,WAAO,SAAS,MAAM,sBAAsB,MAAM,OAAO,EAAE;AAAA,EAC/D;AACJ;;;AC/CA,SAAgB,aAAAC,kBAAkC;AAI3C,IAAM,cAA8D,CAAC,aAAa,SAAS;AAC9F,QAAM,WAAW,gBAAgB,IAAI;AACrC,QAAM,EAAE,KAAK,IAAI;AACjB,QAAM,YAAY,MAAM,SAAS,CAAC;AAClC,MAAI,CAAC,WAAW;AACZ,WAAO,SAAS,MAAM,sGAAsG;AAAA,EAChI;AACA,QAAM,YAAY,MAAM,SAAS,CAAC;AAElC,MAAI,CAAC,WAAW;AACZ,WAAO,SAAS,MAAM,uGAAuG;AAAA,EACjI;AAEA,QAAM,QAAQ,YAAY,QAAQ,WAAW,SAAS,EAAE,MAAM,UAAU,CAAC;AACzE,MAAI,CAAC,OAAO;AACR,WAAO,SAAS,MAAM,SAAS,SAAS,YAAY;AAAA,EACxD;AAEA,MAAI,CAAC,KAAK,aAAa;AACnB,WAAO,SAAS,MAAM,0GAA0G;AAAA,EACpI;AAEA,QAAM,YAAY,MAAM,WAAW,KAAK,CAAC,SAAS,KAAK,SAAS,WAAW,KAAK,SAAS,SAAS;AAClG,MAAI,CAAC,WAAW;AACZ,WAAO,SAAS,MAAM,SAAS,SAAS,4BAA4B,SAAS,EAAE;AAAA,EACnF;AACA,MAAI;AACJ,QAAM,cAAc;AAAA,UACd,SAAS,IAAI,KAAK,WAAW;AAAA;AAGnC,MAAI;AACA,aAASC,WAAU,WAAW;AAAA,EAClC,SAAS,OAAO;AACZ,WAAO,SAAS,MAAM,8KAA8K;AAAA,EACxM;AAEA,QAAM,YAAY,OAAO,KAAK,CAAC;AAC/B,QAAM,WAAW,UAAU,WAAW,KAAK,CAAC,SAAS,KAAK,SAAS,WAAW,KAAK,SAAS,SAAS;AACrG,MAAI,CAAC,UAAU;AACX,WAAO,SAAS,MAAM,4JAA4J;AAAA,EACtL;AACA,QAAM,YAAY,qBAAqB,QAAoB;AAC3D,MAAI,CAAC,WAAW;AACZ,WAAO,SAAS,MAAM,4JAA4J;AAAA,EACtL;AACA,QAAM,eAAe,YAAY,QAAQ,MAAM,MAAM,IAAI;AACzD,MAAI,WAAW;AACX,iBAAa,YAAY,SAAS;AAClC,UAAM,eAAe,aAAa,MAAM,UAAU,MAAM,UAAU,SAAS;AAE3E,eAAW,QAAQ,UAAU,YAAY;AACrC,mBAAa,UAAU,KAAK,MAAM,KAAK,IAAI;AAAA,IAC/C;AAAA,EACJ;AAEA,SAAO,SAAS,OAAO,SAAS,SAAS,mBAAmB,SAAS,EAAE;AAC3E;;;AC5DA,SAAS,aAAAC,kBAAiB;AAEnB,IAAM,eAAgE,CAAC,aAAa,SAAS;AAChG,QAAM,EAAE,KAAK,IAAI;AACjB,QAAM,WAAW,gBAAgB,IAAI;AACrC,QAAM,UAAU,YAAY;AAE5B,QAAM,gBAAgB,MAAM,aAAa,CAAC;AAC1C,MAAI,CAAC,eAAe;AAChB,WAAO,SAAS,MAAM,wFAAwF;AAAA,EAClH;AAEA,QAAM,cAAc,KAAK;AACzB,MAAI,CAAC,aAAa;AACd,WAAO,SAAS,MAAM,yFAAyF;AAAA,EACnH;AAEA,QAAM,gBAAgB,QAAQ,WAAW,aAAa,EAAE,MAAM,cAAc,CAAC;AAC7E,MAAI,eAAe;AACf,WAAO,SAAS,MAAM,aAAa,aAAa,iBAAiB;AAAA,EACrE;AAEA,MAAI;AAEJ,QAAM,cAAc,aAAa,aAAa;AAAA,UACxC,WAAW;AAAA;AAEjB,MAAI;AACA,aAASA,WAAU,WAAW;AAAA,EAClC,SAAS,OAAO;AACZ,WAAO,SAAS,MAAM,gDAAgD,MAAM,OAAO,EAAE;AAAA,EACzF;AAEA,QAAM,SAAS,YAAY,QAAQ,UAAU;AAC7C,QAAM,eAAe,OAAO,KAAK,CAAC;AAClC,SAAO,KAAK,KAAK,YAAY;AAE7B,SAAO,SAAS,OAAO,aAAa,aAAa,sBAAsB;AAC3E;;;ACvCA,OAAOC,aAAW;AAElB,SAAS,aAAAC,kBAAiB;AAEnB,SAAS,gBAAgB,OAAuB;AACnD,SAAO,MACF,QAAQ,WAAW,EAAE,EACrB,QAAQ,WAAW,EAAE;AAC9B;AACO,IAAM,kBAAsE,CAAC,aAAa,SAAS;AACtG,QAAM,EAAE,MAAM,QAAQ,IAAI;AAC1B,QAAM,WAAW,gBAAgB,IAAI;AACrC,QAAM,UAAU,YAAY;AAE5B,QAAM,gBAAgB,MAAM,aAAa,CAAC;AAC1C,MAAI,CAAC,eAAe;AAChB,WAAO,SAAS,MAAM,wFAAwF;AAAA,EAClH;AAEA,QAAM,gBAAgB,QAAQ,WAAW,aAAa,EAAE,MAAM,cAAc,CAAC;AAC7E,MAAI,CAAC,eAAe;AAChB,WAAO,SAAS,MAAM,aAAa,aAAa,iBAAiB;AAAA,EACrE;AAEA,MAAI;AAGJ,QAAM,cAAc,KAAK;AACzB,MAAI,aAAa;AACb,QAAI,CAAC,aAAa;AACd,aAAO,SAAS,MAAM,yFAAyF;AAAA,IACnH;AACA,YAAQ,IAAIC,QAAM,OAAO,gDAAgD,aAAa,mBAAmB,CAAC;AAC1G,YAAQ,KAAK,cAAc,IAAI;AAE/B,UAAM,cAAc,aAAa,aAAa;AAAA,UAC5C,WAAW;AAAA;AAEb,QAAI;AACA,eAASD,WAAU,WAAW;AAAA,IAClC,SAAS,OAAO;AACZ,aAAO,SAAS,MAAM,gDAAgD,MAAM,OAAO,EAAE;AAAA,IACzF;AAGA,UAAM,SAAS,YAAY,QAAQ,UAAU;AAC7C,UAAM,eAAe,OAAO,KAAK,CAAC;AAClC,WAAO,KAAK,KAAK,YAAY;AAAA,EACjC,WAAW,WAAW,OAAO,KAAK,OAAO,EAAE,QAAQ;AAC/C,UAAM,YAAY,QAAQ,UAAU,aAAa;AACjD,UAAM,eAAe,OAAO,KAAK,OAAO,EAAE,OAAO,SAAO,QAAQ,YAAY,QAAQ,UAAU;AAC9F,QAAI,aAAa,QAAQ;AACrB,cAAQ,IAAIC,QAAM,OAAO,4BAA4B,aAAa,KAAK,IAAI,CAAC,kBAAkB,CAAC;AAC/F,YAAM,eAAe,CAAC,UAAU,UAAU;AAC1C,cAAQ,IAAIA,QAAM,OAAO,sBAAsB,aAAa,KAAK,IAAI,CAAC,EAAE,CAAC;AAAA,IAC7E;AACA,QAAI,SAAS,QAAQ;AACjB,gBAAU,WAAW,UAAU,gBAAgB,QAAQ,MAAM,CAAC;AAAA,IAClE;AACA,QAAI,SAAS,UAAU;AACnB,gBAAU,WAAW,YAAY,gBAAgB,QAAQ,QAAQ,CAAC;AAAA,IACtE;AAAA,EACJ;AAEA,SAAO,SAAS,OAAO,aAAa,aAAa,sBAAsB;AAC3E;;;AC/DO,SAASC,iBAAgB,OAAuB;AACnD,SAAO,MACF,QAAQ,WAAW,EAAE,EACrB,QAAQ,WAAW,EAAE;AAC9B;AACO,IAAM,WAAwD,CAAC,aAAa,SAAS;AACxF,QAAM,EAAE,QAAQ,IAAI;AACpB,QAAM,WAAW,gBAAgB,IAAI;AAErC,MAAI,CAAC,SAAS,YAAY,CAAC,SAAS,KAAK;AACrC,WAAO,SAAS,MAAM,qGAAqG;AAAA,EAC/H;AAEA,QAAM,UAAU,YAAY;AAE5B,QAAM,OAAO,QAAQ,WAAW,cAAc;AAAA,IAC1C,MAAM;AAAA,EACV,CAAC;AACD,MAAI,CAAC,MAAM;AACP,WAAO,SAAS,MAAM,qBAAqB;AAAA,EAC/C;AAEA,QAAM,YAAY,QAAQ,WAAW,IAAI,QAAQ,QAAQ,MAAM,SAAU,MAAc,aAAa,KAAK,CAAC,MAAW,EAAE,OAAO,UAAU,GAAG;AAC3I,MAAI,UAAU,QAAQ,KAAK,SAAS,KAAM,MAAc,aAAa,KAAK,CAAC,MAAW,EAAE,OAAO,KAAK,GAAG;AAEvG,MAAI,OAAO,WAAW,YAAY,QAAQ,QAAQ,OAAO;AACrD,cAAU;AAAA,MACN,KAAKA,iBAAgB,QAAQ,OAAO,CAAC,CAAC;AAAA,IAC1C;AAAA,EACJ;AAEA,UAAQ,WAAW,UAAU,WAAW;AAAA,IACpC,KAAK;AAAA,EACT,CAAC;AAED,SAAO,SAAS,OAAO,yBAAyB;AACpD;;;ACvBO,IAAM,mBAAmB,IAAI,gCAAgC;AAEpE,iBAAiB,SAAS,OAAO,SAAS,QAAQ;AAClD,iBAAiB,SAAS,OAAO,SAAS,QAAQ;AAClD,iBAAiB,SAAS,OAAO,QAAQ,OAAO;AAChD,iBAAiB,SAAS,OAAO,YAAY,WAAW;AACxD,iBAAiB,SAAS,OAAO,aAAa,YAAY;AAE1D,iBAAiB,SAAS,UAAU,QAAQ,UAAU;AACtD,iBAAiB,SAAS,UAAU,SAAS,WAAW;AACxD,iBAAiB,SAAS,UAAU,SAAS,WAAW;AACxD,iBAAiB,SAAS,UAAU,YAAY,cAAc;AAC9D,iBAAiB,SAAS,UAAU,aAAa,cAAc;AAE/D,iBAAiB,SAAS,UAAU,SAAS,WAAW;AACxD,iBAAiB,SAAS,UAAU,QAAQ,UAAU;AACtD,iBAAiB,SAAS,UAAU,aAAa,eAAe;AAChE,iBAAiB,SAAS,UAAU,MAAM,QAAQ;;;AC9BlD,OAAOC,YAAW;AAClB,OAAOC,YAAW;AAClB,OAAOC,aAAW;AAEX,IAAM,gBAA+D,CAAC,aAAa,SAAS;AAC/F,QAAM,WAAW,gBAAgB,IAAI;AACrC,QAAM,SAAS,UAAU,WAAW;AACpC,QAAM,aAAa,OAAO,cAAc;AACxC,MAAI,CAAC,WAAY,QAAO,SAAS,OAAO,sBAAsB;AAE9D,QAAM,WAGD,CAAC;AAEN,aAAW,QAAQ,CAAC,cAAmB;AAEnC,UAAM,QAAQ,IAAIF,OAAM;AAAA,MACpB,MAAM,CAAC,YAAY,OAAO;AAAA,MAC1B,WAAW,CAAC,IAAI,EAAE;AAAA,IACtB,CAAC;AAGD,eAAW,aAAa,QAAQ,CAAC,eAAoC;AACjE,UAAI,CAAC,WAAY;AACjB,YAAM,KAAK,CAAC,YAAY,KAAK,YAAY,KAAK,CAAC;AAAA,IACnD,CAAC;AAED,aAAS,KAAK;AAAA,MACV,MAAM,UAAU;AAAA,MAChB,OAAO,MAAM,SAAS;AAAA,IAC1B,CAAC;AAAA,EACL,CAAC;AACD,QAAM,SAAS,SAAS,IAAI,aAAW;AACnC,WAAOC,OAAMC,QAAM,KAAK,QAAQ,IAAI,IAAI,OAAO,QAAQ,OAAO,EAAE,SAAS,GAAG,aAAa,OAAO,CAAC;AAAA,EACrG,CAAC,EAAE,KAAK,IAAI;AAEZ,SAAO,SAAS;AAAA,IAAO;AAAA,oBACP,WAAW,MAAM;AAAA,EACnC,MAAM;AAAA;AAAA,EAEJ;AACJ;;;AC5CA,OAAOC,YAAW;AAClB,OAAOC,aAAW;AAGX,SAASC,iBAAgB,OAAuB;AACnD,SAAO,MACF,QAAQ,WAAW,EAAE,EACrB,QAAQ,WAAW,EAAE;AAC9B;AACO,IAAM,QAA+C,CAAC,aAAa,SAAS;AAC/E,QAAM,WAAW,gBAAgB,IAAI;AAErC,QAAM,UAAU,YAAY;AAE5B,QAAM,OAAO,QAAQ,WAAW,cAAc;AAAA,IAC1C,MAAM;AAAA,EACV,CAAC;AACD,MAAI,CAAC,MAAM;AACP,WAAO,SAAS,MAAM,qBAAqB;AAAA,EAC/C;AAEA,QAAM,WAAY,MAAc,aAAa,KAAK,CAAC,MAAW,EAAE,OAAO,UAAU,GAAG;AACpF,MAAI,UAAW,MAAc,aAAa,KAAK,CAAC,MAAW,EAAE,OAAO,KAAK,GAAG;AAC5E,MAAI,OAAO,WAAW,YAAY,QAAQ,QAAQ,OAAO;AACrD,cAAU,SAASA,iBAAgB,QAAQ,OAAO,CAAC,CAAC,IAAI;AAAA,EAC5D;AACA,SAAO,SAAS,OAAOC,OAAM,GAAGC,QAAM,KAAK,UAAU,CAAC,KAAK,QAAQ;AAAA,EAAKA,QAAM,KAAK,KAAK,CAAC,KAAK,OAAO,IAAI,EAAE,SAAS,GAAG,eAAe,QAAS,QAAQ,GAAG,aAAa,SAAS,CAAC,CAAC;AACtL;;;ACjBO,IAAM,sBAAsB,IAAI,6BAA6B;AAEpE,oBAAoB,SAAS,OAAO,SAAS,QAAQ;AACrD,oBAAoB,SAAS,OAAO,UAAU,SAAS;AACvD,oBAAoB,SAAS,OAAO,UAAU,SAAS;AACvD,oBAAoB,SAAS,OAAO,SAAS,QAAQ;AACrD,oBAAoB,SAAS,OAAO,eAAe,aAAa;AAChE,oBAAoB,SAAS,OAAO,aAAa,YAAY;AAC7D,oBAAoB,SAAS,OAAO,kBAAkB,gBAAgB;AACtE,oBAAoB,SAAS,OAAO,cAAc,aAAa;AAC/D,oBAAoB,SAAS,OAAO,MAAM,KAAK;;;ACjBxC,IAAM,oBAAmE,CAAC,aAAa,SAAS;AACnG,QAAM,WAAW,gBAAgB,IAAI;AACrC,QAAM,SAAS,UAAU,WAAW;AACpC,QAAM,aAAa,OAAO,cAAc;AACxC,MAAI,CAAC,WAAY,QAAO,SAAS,OAAO;AAAA,IACpC,OAAO;AAAA,IACP,YAAY,CAAC;AAAA,EACjB,CAAC;AAED,QAAM,WAMD,CAAC;AAEN,aAAW,QAAQ,CAAC,cAAmB;AAEnC,UAAM,QAGD,CAAC;AAEN,eAAW,aAAa,QAAQ,CAAC,eAAoC;AACjE,UAAI,CAAC,WAAY;AACjB,YAAM,KAAK;AAAA,QACP,KAAK,YAAY;AAAA,QACjB,OAAO,YAAY;AAAA,MACvB,CAAC;AAAA,IACL,CAAC;AACD,aAAS,KAAK;AAAA,MACV,MAAM,UAAU;AAAA,MAChB,YAAY;AAAA,IAChB,CAAC;AAAA,EACL,CAAC;AAED,SAAO,SAAS,OAAO;AAAA,IACnB,OAAO,WAAW;AAAA,IAClB,YAAY;AAAA,EAChB,CAAC;AACL;;;AClCO,IAAM,mBAAmB,IAAI,6BAA6B;AAEjE,iBAAiB,SAAS,OAAO,SAAS,YAAY;AACtD,iBAAiB,SAAS,OAAO,UAAU,aAAa;AACxD,iBAAiB,SAAS,OAAO,UAAU,aAAa;AACxD,iBAAiB,SAAS,OAAO,SAAS,YAAY;AACtD,iBAAiB,SAAS,OAAO,eAAe,iBAAiB;AACjE,iBAAiB,SAAS,OAAO,aAAa,gBAAgB;AAC9D,iBAAiB,SAAS,OAAO,kBAAkB,gBAAgB;AACnE,iBAAiB,SAAS,OAAO,cAAc,iBAAiB;","names":["fs","path","pkg","getDMMF","path","fs","pkg","getDMMF","chalk","pkg","fs","getDMMF","chalk","chalk","PrismaHighlighter","chalk","chalk","boxen","chalk","boxen","chalk","chalk","boxen","boxen","PrismaHighlighter","chalk","highlightPrismaSchema","e","boxen","chalk","chalk","printSchema","PrismaHighlighter","boxen","highlightPrismaSchema","PrismaHighlighter","printSchema","chalk","printSchema","boxen","PrismaHighlighter","chalk","highlightPrismaSchema","printSchema","sortModelNames","e","sortModelNames","printSchema","printSchema","printSchema","printSchema","getSchema","getSchema","getSchema","getSchema","args","pluralize","pascalCase","pascalCase","pluralize","chalk","chalk","constantCase","getSchema","getSchema","getSchema","chalk","getSchema","chalk","normalizeQuotes","Table","boxen","chalk","boxen","chalk","normalizeQuotes","boxen","chalk"]}